[{"title":"古典密码学基础","url":"/2019/01/03/古典密码学基础/","tags":["古典密码，密码学"],"categories":["密码学"]},{"title":"Android编译器相关","url":"/2019/01/02/Android编译器相关/","content":"MIR -> LIR -> native code\n\nSSA：（编译器后端寄存器分配算法，static single assignment）静态单一复制法，是一种中间表示形式。\n之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。\n\n在某种程度上，可以认为MIR即为对dalvik指令进行SSA变换之后的指令形态。\n\n接着就调用cu.cg->Materialize()用来产生最终代码，其中重要的两个调用就是MethodMIR2LIR()和AssembleLIR()。\n通MethodMIR2LIR()将MIR转化为LIR，遍历每个BasicBlock，对每个基本块执行MethodBlockCodeGen，\n本质上最后是执行了CompileDalvikInstruction。CompileDalvikInstruction也就是通过解析指令，然后根据opcode进行分支判断，\n调用最终不同的指令生成函数，最后LIR之间也形成一个双向链表。最终将MIR转换为LIR。\n\nAssembleLIR()最终调用的是AssembleInstructions函数。程序中维护了一个编码指令表MipsMir2Lir::EncodingMap，\nAssembleInstructions即是通过查找这个表来进行翻译，将LIR转化为了MIPS指令，\n并将所翻译的指令存储到CodeBufferMir2Lir::code_buffer_之中。\n这样就完成了一次编译的完整流程。\n\n总结：\nMIR为对dalvik指令进行SSA变换之后的指令形态。\nLIR为对MIR形态的指令进行解析生成的另一种形态的指令。\nnative code为通过查找编码指令表将LIR形态的指令翻译为对应不同平台的汇编指令。","tags":["Android、compiler"]},{"title":"Android 逐步认识ART系列二","url":"/2018/12/28/Android-逐步认识ART系列二/","content":"\n# boot.oat\n\n- Contains libs and frameworks in boot class path\n    – To be pre-loaded in all apps（系统启动路径下的的需要预加载库和框架）\n\n任何应用程序都不是孤立存在的，几乎所有应用程序都会依赖Android Framework中提供的基础类，例如Activity，Intent，Parcel等类。所以在应用程序的代码中，自然少不了对于这些类的引用.\n\n考虑到几乎所有应用都存在这种引用关系，在运行时都会依赖于Framework中的类，因此系统如何处理这部分逻辑就是非常重要的了，因为这个处理的方法将影响到所有应用程序。\n\n在AOSP编译时，会将所有这些公共类放到专门的一个Oat文件中，这个文件就是：boot.oat。与之配合的还有一个boot.art文件。\n\nboot.oat可以在两个地方找到：\n1. /system/framework/[platform]/boot.oat\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     50767704 2014-11-20 19:07 boot.oat\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.oat\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     51003824 1970-05-29 01:45 system@framework@boot.oat\n```\n\n```\n/system/bin/dex2oat --image=/data/dalvik-cache/system@framework@boot.art --runtime-arg\n-Xms64m --runtime-arg -Xmx64m --dex-file=/system/framework/core-libart.jar --dex-file=/\nsystem/framework/conscrypt.jar --dex-file=/system/framework/okhttp.jar --dex-file=/\nsystem/framework/core-junit.jar --dex-file=/system/framework/bouncycastle.jar --dexfile=/system/framework/ext.jar --dex-file=/system/framework/framework.jar --dex-file=/\nsystem/framework/framework2.jar --dex-file=/system/framework/telephony-common.jar --\ndex-file=/system/framework/voip-common.jar --dex-file=/system/framework/mms-common.jar\n--dex-file=/system/framework/android.policy.jar --dex-file=/system/framework/\nservices.jar --dex-file=/system/framework/apache-xml.jar --dex-file=/system/framework/\nwebviewchromium.jar --oat-file=/data/dalvik-cache/system@framework@boot.oat --runtimearg -implicit-checks:none --instruction-set=arm --instruction-set-features=default --\nbase=0x70000000 --image-classes-zip=/system/framework/framework.jar\n```\n**上面命令编译进boot.oat中的jar:**   \n/system/framework/core-libart.jar  \n/system/framework/conscrypt.jar  \n/system/framework/okhQp.jar  \n/system/framework/core-junit.jar  \n/system/framework/bouncycastle.jar  \n/system/framework/ext.jar  \n/system/framework/framework.jar  \n/system/framework/framework2.jar  \n/system/framework/telephony-common.jar  \n/system/framework/voip-common.jar  \n/system/framework/mms-common.jar  \n/system/framework/android.policy.jar  \n/system/framework/services.jar  \n/system/framework/apache-xml.jar  \n/system/framework/webviewchromium.jar  \n\n# boot.art(boot image)\n- contains absolute pointers for methods in boot.oat(以绝对地址指向boot.oat中的方法)\n- boot.art和boot.oat的加载地址都是32位，在64位的系统上，高32位都是0\n\nboot.art中包含了指向boot.oat中方法代码的指针，它被称之为启动镜像（Boot Image），并且被加载的位置是固定的。boot.oat被加载的地址紧随着boot.art。\n\nboot.art可以在两个地方找到：\n1. /system/framework/[platform]/boot.art\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     11829248 2014-11-20 19:07 boot.art\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.art\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     11829248 1970-05-29 01:45 system@framework@boot.art\n```\n\n# Profiling\n- By default,ART compiles methods regardless of impact on performance(ART编译方法时，不会考虑对性能的影响)\n- Profiling feature allows ART to be more selective on which methods to compile(profile能够\b控制dex2oat具体要对哪些方法进行编译优化)\n- Profiling配置默认可能是关闭的。可以通过setprop手动打开\n\n```\nsetprop dalvik.vm.profiler 1\n```\n\n\b- No AOT compilation upon app install(在App安装时不会进行AOT优化，一方面时为了减少安装时间、另一方面时节省\b存储空间)\n- Profiling data is collected while app is runing(在App运行期间，会收集profile数据)\n- Profile files are placed in /data/dalvik-cache/profiles\n- Profile file name is the package name\n- Profile data is used to determine if AOT compilation will be done\n\nexample:\n```\n42/2/352  \nandroid.database.Cursor com.android.email.provider.EmailProvider.uiAccounts(java.lang.String[])/1/128  \nvoid com.android.email.NotificationController.ensureHandlerExists()/1/37\nint com.android.email.provider.EmailProvider.getFolderTypeFromMailboxType(int)/2/56\nboolean com.android.mail.browse.ConversationCursor$ConversationProvider.onCreate()/1/49\ncom.google.common.collect.ImmutableList com.google.common.collect.ImmutableList.of()/1/3\n<snip>\n```\n\n- First line is the summary inforamtion\n  > count/Null methods count/Boot path methods count\n- Subsequent lines are the profile data\n  > Methods name/Count/Size\n\n# App Image\n\n* /data/app/xxx/oat/arm/base.art\n* /data/app/xxx/oat/rm/base.odex\n\nbase.art 就是对应的App image文件。主要记录已经编译好的类的具体信息以及函数在oat文件的位置，相当于缓存，在app运行的时候会加载到虚拟机，可以加快启动速度。\n\n**在Android7.0上，dex2oat的参数 compiler-filter被指定为profile类型的几个compiler-filter之一时，dex2oat还会生成app-image文件。**\n","tags":["ART、boot.oat、boot.art、Profile"]},{"title":"Android 逐步认识ART系列一","url":"/2018/12/27/Android-逐步认识ART系列一/","content":"\n参考资料：  \n原文：https://blog.csdn.net/hl09083253cy/article/details/78418809   \n原文：https://paul.pub/android-art-vm/#id-art-vs-dalvik  \nAndroid Source：https://source.android.com.devices/tech/dalvik/configure  \n\n# JIT\n我们知道，C/C++的效率要比 Java好，因为C/C++会被直接编译成汇编指令，CPU可以直接读取运行；而Java却是需要虚拟机一步一步的解释每一条 java bytecode。\n\n而Dalvik 中使用了一个技术，叫做JIT，会在解释执行一个java方法或者一个java代码段时，进行trace，并在不断的执行过程中找到 hotspot，\n\n然后将相应的方法或者代码片段编译为对应的汇编指令，下次再执行到该方法时，会直接执行其对应的汇编指令，依次来提升部分效率。\n\n可以理解为：运行时追踪，并对hotspot进行编译生成高效的可执行指令。\n\nJIT的运行流程\n\n1. 用户运行应用，而这随后就会触发 ART 加载 .dex 文件。\n   1. 如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 .oat 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。\n   2. 如果没有 .oat 文件，则 ART 会通过 JIT 或解释器执行 .dex 文件。如果有 .oat 文件，ART 将一律使用这类文件。否则，它将在内存中使用并解压 APK 文件，从而得到 .dex 文件，但是这会导致消耗大量内存（相当于 dex 文件的大小）。\n2. 针对任何未根据speed编译过滤器编译（见下文）的应用启用JIT（也就是说，要尽可能多地编译应用中的代码）。\n3. 将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。\n4. AOT 编译 dex2oat 守护进程通过解析该文件来推进其编译。\n\n要开启 JIT 日志记录，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.extra-opts -verbose:jit\nadb shell start\n```\n要停用 JIT，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.usejit false\nadb shell start\n```\n\n# AOT\n\nAhead-of-time（AOT）是相对于Just-in-time（JIT）而言的。JIT是在运行时进行字节码到本地机器码的编译，这也是为什么Java普遍被认为效率比C++差的原因。无论是解释器的解释还是运行过程中即时编译，都比C++编译出的本地机器码执行多了一个耗费时间的过程。而AOT就是向C++编译过程靠拢的一项技术：当APK在安装的时候，系统会通过一个名称为dex2oat的工具将APK中的dex文件编译成包含本地机器码的oat文件存放下来。这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。\n\n# 单纯的JIT存在的问题\n1. 执行效率差\n\n# 单纯的AOT存在的问题\n1. 应用安装时间长\n2. 系统更新后，要重新编译所有应用\n3. 浪费存储空间（为所有方法执行编译）\n\n# AOT+JIT\n\n从Android 7.0（代号Nougat,简称N）开始，ART组合使用了AOT、JIT和配置文件引导型编译。所有这些编译模式的组合均可配置。例如，在Pixel设备上，相应的配置如下：\n\n1. 最初在安装应用程序的时候不执行任何AOT编译。应用程序运行的前几次都将使用解释模式，**并且经常执行的方法将被JIT编译**。\n2. **当设备处于空闲状态并正在充电时**，编译守护进程会根据第一次运行期间生成的Profile文件对**常用代码**运行AOT编译。\n3. 应用程序的**下一次重新启动将使用Profile文件引导的代码**，并**避免在运行时为已编译的方法进行JIT编译**。在**新运行期间得到JIT编译的方法将被添加到Profile文件中**，然后被编译守护进程使用。\n\nART包含一个编译器（dex2oat工具）和一个为启动zygote而加载的运行时（libart.so）。在应用程序安装时，APK文件会传递给dex2oat工具，该工具会为根据APK文件生成一个或多个编译产物，这些产物文件名和扩展名可能会在不同版本之间发生变化，但从Android 8.0版本开始，生成的文件是：\n\n- .vdex：包含APK的未压缩Dex代码，以及一些额外的元数据用来加速验证。\n- .odex：包含APK中方法的AOT编译代码。（注意，虽然Dalvik虚拟机时代也会生成odex文件，但和这里的odex文件仅仅是后缀一样，文件内容已经完全不同了）\n- .art（可选）：包含APK中列出的一些字符串和类的ART内部表示，用于加速应用程序的启动    \n\n# 编译选项\n\nART的编译选项分为以下两个类别：\n1. 系统ROM配置：编译系统映像时，会对哪些代码进行AOT编译。\n2. 运行时配置：ART如何在设备上编译和运行应用。\n\n用于配置这两个类别的一个核心ART选项就是”编译过滤器“，编译过滤器可控制ART如何编译DEX代码，是一个传递给dex2oat工具的选项。从Android 8.0开始，有四个官方支持的过滤器：\n   1. verify：只运行DEX代码验证\n   2. quicken：运行DEX代码验证，并优化一些DEX指令，以获得更好的解释器性能。\n   3. speed：运行DEX代码验证，并对所有方法进行AOT编译。\n   4. speed-profile：运行DEX代码验证，并对配置文件中列出的方法进行AOT编译\n\n ## 系统ROM配置\n 有一些编译选项可用于配置系统ROM，如何配置这些选项取决于/system的可用存储空间以及预先安装的应用数量。编译到系统AROM中的JAR/APK可以分为以下四个类别：\n    1. 启动类路径代码：默认使用speed编译过滤器进行编译 \n    2. 系统服务代码：默认使用speed编译过滤器进行编译\n    3. 产品专属的核心应用：默认使用speed编译过滤器进行编译\n    4. 所有其他应用：默认使用quicken编译过滤器进行编译\n\n\n","tags":["ART，OAT，JIT"]},{"title":"Android-逐步认识ART系列三","url":"/2018/12/26/dex2oat源码分析/","content":"dex2oat是将dex文件编译成Oat文件的工具，位于/system/bin/dex2oat\n\ndex2oat生成的oat文件位于设备上/data/dalvik-cache/目录下,同时，由于32位和64位的机器码有所区别，因此这个目录下还会通过子文件夹对oat文件进行分类。例如，手机上通常会有下面两个目录：  \n* /data/dalvik-cache/arm/  \n* /data/dalvik-cache/arm64/\n\n# dex2oat：\n* Retrieve classes.dex from APK (从apk中检索classes.dex)\n* verify each class（验证每个类）\n* verify each method（验证每个方法）\n* verify each dalvik instruction（验证每条dalvik指令）\n\n# dex2oat编译过程\n依次编译输入参数中的所有dex文件;  每个dex文件又按照单个class进行编译; 对于每个class，依次编译其除abstract函数、\\<cinit>之外的所有函数，包括 native（jni）/static/及一般函数，进行生成native code，并存放在compiler中。\n\n当编译完成后，会从compiler中把native code， dex文件，以及必要的组织信息，写入到OAT文件中；如果指定了生成app-image，还会再生成一份 app-image文件。\n\n# dex2oat的触发时机\ndex2oat进程的启动，可以分为两大类：一类是 installd进程触发的dex2oat；另一类是由 app中直接调用的dex2oat。\n\n ## installd中触发dex2oat有以下几个场景：\n    1. 应用安装，包括普通安装和通过shellCmd安装），安装一个app时，安装过程中需要编译dex文件，会通知installd来触发一个dex2oat进程。\n    2. 开机扫描，开机过程中，PMS扫描已安装app过程，判断需要优化时，则会对install发出通知。\n    3. BackgroundDexOptService，（空闲时段或者开机之后触发的Backgroud的 Job），会通知installd进行dex2oat\n    4. OTADexoptService，好象是OAT过程中的触发的，这个场景没有进行过实际的验证\n\n ## app中调用dex2oat\n一般是App的进程fork出一个子进程，子进程用来执行dex2oat，编译相关的dex，而父进程进行 waitpid 等待，等待完成后再运行其他逻辑。  \n例如：  \n 1. 微信安装后的首次启动，是有dex2oat的调用\n 2. 淘宝安装后的首次搜索，也有dex2oat的调用\n\n这个也是其首次启动或者搜索的一个耗时点。\n\n 由系统触发的dex2oat，都是通过通知installd来进行编译业务。\n\n 由应用触发的dex2oat，一般都是自行构建参数，直接调用dex2oat。\n\n\n# compiler-backend 类型\n\n* Portable\n* Quick\n* Optimizing\n\n ## Quick Backend\n\n > MIR -> LIR -> Native Code\n\n * Medium level IR(DEX ByteCode)\n * Low level IR\n * Native Code\n * some optimizations at each stage\n\n ## Optimizing Backend\n\n * Basically Quick with additional optimizations\n\n ## Portable Backend\n\n > MIR -> LLVM Bitcode -> LLVM optimizer -> LLVM Backend -> native code\n\n * Uses LLVM Bitcode as its LIR\n * Optimizations using LLVM optimizer\n * Code generation is done by LLVM backends\n\n\n# \b编译优化条件和对象（没太搞明白的地方）\n\n ## 什么情况下App需要使用dex2oat进行编译优化?\n * Number of methods comprising 90% of called methods has changed by > 10%.(被调用方法的比例若大于10%，则会触发dex2oat编译优化)\n\n ## \b若要使用dex2oat,哪些方法会被dex2oat考虑进去？\n * Methods comprising 90% of called methods.()\n\n# dex2oat命令行参数\n\nexample:\n```\n/system/bin/dex2oat --zip-fd=6 --zip-location=/system/app/\nEmail.apk --oat-fd=7 --oat-location=/data/dalvik-cache/\nsystem@app@Email.apk@classes.dex --profile-file=/data/\ndalvik-cache/profiles/com.android.email\n```\n参数说明：  \n--zip-fd=\\<file-descriptor>:包含classes.dex文件的zip文件描述符。  \n--oat-fd=\\<number>:\b通过此文件描述符指定输出的oat文件的路径。  \n--oat-location=\\<oat-name>:指定一个与--oat-fd指定的文件描述符相对应的象征性名字。  \n--profile-file：引导dex2oat编译优化的配置文件。文件位置：/data/dalvik-cache/profiles/应用包名\n\n其他重要参数说明(参考android7.0.0源码)：  \n-j\\<number>:指定进行\b编译优化时要用到的线程总数。默认根据硬件适配，例如：-j12  \n--dex-file=\\<dex-file>:指定要编译的文件，后缀可以是.dex、.jar、.apk，\b例如：--dex-file=/system/framework/core.jar  \n--dex-location=\\<dex-location>:dex文件路径,与--dex-file相对应，例如：--dex-file=/home/build//out/system/framework/core.jar;--dex-location=/system/framework/core.jar。    \n--zip-location=\\<zip-location>:zip文件路径。例如：--zip-location=/system/app/Calculator.apk   \n--oat-file=\\<file.oat>:输出的oat文件名。例如：--oat-file=/system/framework/boot.oat。  \n--oat-symbols=\\<file.oat>:指定输出完整符号的oat路径。例如：--oat-symbols=/symbols/system/framework/boo.art。  \n--instruction-set=(arm|arm64|mips|mips64|x86|x86_64):指定指令集架构类型，默认为arm。  \n--compile-backend=(Quick|Optimizing):指定编译器后端。默认为Optimizing。  \n--compiler-filter=(verify-none|verify-at-runtime|verify-profile|interpret-only|time|space-profile|space|balanced|speed-profile|speed|everything-profile|everything):指定编译器过滤模式，默认为speed。\n\n# dex2oat主要流程\n\nmain函数入口：\n```\nint main(int argc, char** argv) {\n  int result = art::dex2oat(argc, argv);\n  // Everything was done, do an explicit exit here to avoid running Runtime destructors that take\n  // time (bug 10645725) unless we're a debug build or running on valgrind. Note: The Dex2Oat class\n  // should not destruct the runtime in this case.\n  if (!art::kIsDebugBuild && (RUNNING_ON_MEMORY_TOOL == 0)) {\n    exit(result);\n  }\n  return result;\n}\n```\ndex2oat函数入口：\n```\nstatic int dex2oat(int argc, char** argv) {\n  b13564922();\n    \n  TimingLogger timings(\"compiler\", false, false);\n\n  // Allocate `dex2oat` on the heap instead of on the stack, as Clang\n  // might produce a stack frame too large for this function or for\n  // functions inlining it (such as main), that would not fit the\n  // requirements of the `-Wframe-larger-than` option.\n  std::unique_ptr<Dex2Oat> dex2oat = MakeUnique<Dex2Oat>(&timings);\n\n  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.\n  dex2oat->ParseArgs(argc, argv);\n\n  // If needed, process profile information for profile guided compilation.\n  // This operation involves I/O.\n  if (dex2oat->UseProfileGuidedCompilation()) {\n    if (!dex2oat->LoadProfile()) {\n      LOG(ERROR) << \"Failed to process profile file\";\n      return EXIT_FAILURE;\n    }\n  }\n\n  // Check early that the result of compilation can be written\n  if (!dex2oat->OpenFile()) {\n    return EXIT_FAILURE;\n  }\n\n  // Print the complete line when any of the following is true:\n  //   1) Debug build\n  //   2) Compiling an image\n  //   3) Compiling with --host\n  //   4) Compiling on the host (not a target build)\n  // Otherwise, print a stripped command line.\n  if (kIsDebugBuild || dex2oat->IsBootImage() || dex2oat->IsHost() || !kIsTargetBuild) {\n    LOG(INFO) << CommandLine();\n  } else {\n    LOG(INFO) << StrippedCommandLine();\n  }\n\n  if (!dex2oat->Setup()) {\n    dex2oat->EraseOatFiles();\n    return EXIT_FAILURE;\n  }\n\n  bool result;\n  if (dex2oat->IsImage()) {//App Image 或者Boot Image\n    result = CompileImage(*dex2oat);\n  } else {\n    result = CompileApp(*dex2oat);\n  }\n\n  dex2oat->Shutdown();\n  return result;\n}\n}\n```\n\n> 当使用profile-guide 编译app时，会先 LoadProfile(),进行解析出 class index 和 method index，放到 ProfileCompilationinfo 中;\n> 如果当前的编译要生成 image时，走CompileImage流程，否则走CompileApp流程;\n\n不论是编译image还是App都会包含以下一个工作：\n```\ndex2oat.Compile();//核心\n\ndex2oat.WriteOatFiles();//嵌入ELF\n\ndex2oat.FlushCloseOatFiles();\n\n dex2oat.DumpTiming()\n```\n\nCompileApp和CompileImage的区别是：\n\n 1. 编译image时需要 LoadClassProfileDescriptors() 产生 image_classes_ 集合，和生成 image（HandleImage()）;\n 2. 在生成的app image中将会包含 image_classes_ 集合中类的对象，不在 image_classes_集合中的app的类的对象，将不会被生成到 app-image中。\n 3. LoadClassProfileDescriptors（）在从 profile信息中获取 image_classes_集合时，将会把 app dex 中的类以外的类，都过滤掉，比如 classpath dex 对应的类将不会生成到 app-image;\n\ndex2oat工作流程总结：\n 1. 根据dex2oat接收到的参数，组织编译参数\n 2. 如果是 profile-guide 编译，则先进行 load app对应的 profile\n 3. 收集参数中包含的所有dex file，启动 Compiler 编译这些dex file（classpath中对应的dex file，即uses-library 引用的jar文件，不会被编译），编译生成的数据放在compiler-driver中\n 4. 使用 compiler-driver 中的数据，依据 oat文件设计的格式，组织成oat文件，嵌入到 ELF文件中\n 5. 如果指定需要生成 app-image，则使用 HandleImage()， 生成app-image， 即 ***.art 文件\n\n## 编译流程\b\n","tags":["Android、dex2oat"]},{"title":"Android 部分系统版本变更行为","url":"/2018/12/26/Android-部分系统版本变更行为/","content":"**主要关注安全方面**\n# Android 6.0部分变更行为：\n\n* 运行时权限\n\n此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。\n\n* 低电耗模式和应用待机模式\n\n此版本引入了针对空闲设备和应用的最新节能优化技术。\n  * 低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。\n  * 应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。\n\n\n* 取消支持 Apache HTTP 客户端\n\nAndroid 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：\n```\nandroid {\n    useLibrary 'org.apache.http.legacy'\n}\n```\n\n* Boring SSL\n\nAndroid 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。\n* 运行时\n\nART 运行时环境现在可正确实现 newInstance() 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 setAccessible() 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。\n\n此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。\n\n现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。\n\n在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。\n\n* APK验证\n\n该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。\n\n# Android 7.0部分变更行为：\n* 配置文件指导的 JIT/AOT 编译\n\n在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。\n\n配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。\n\n除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。\n\nAndroid 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。\n* 快速的应用安装路径\n\nAndroid 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤\n\n**关于JIT的回归**\n\n在Android 5.0上，系统在安装APK时会直接将dex文件中的代码编译成机器码。编译一个应用就已经很耗时，若编译所有应用，等待时间将会使人难以忍受。\n\n例如：  \n应用程序编译生成的OAT文件会引用Framework中的代码。一旦系统发生升级，Framework中的实现发生变化，就需要重新修正所有应用程序的OAT文件，使得它们的引用是正确的，这就需要重新编译所有的应用。\n\n由此可以看到单纯的AOT编译会存在以下问题：\n* 应用安装时间过长。\n* 系统每次更新都要重新编译所有应用。\n* 编译生成的Oat文件中，既包含了原先的Dex文件，又包含了编译后的机器代码。而实际上，对于用户来说，并非会用到应用程序中的所有功能，因此很多时候编译生成的机器码是一直用不到的。一份数据存在两份结果（尽管它们的格式是不一样的）显然是一种存储空间的浪费。\n  \n因此，为了解决上述问题，Android 7.0(代号Nougat,简称N)中添加了JIT编译器和配置文件引导型编译。JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。\n\nJIT编译器补充了ART当前的预先AOT编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT编译器，JIT编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 OTA 更新期间）时拖慢系统速度。\n\n尽管JIT和AOT使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 OnStackReplacement 编译成为可能，而这一切都会使其生成的代码略有不同。\n","tags":["Android，版本变化"]},{"title":"Android系统版本分布","url":"/2018/12/26/Android系统版本分布/","content":"\nAndroid 信息中心：https://developer.android.com/about/dashboards/?hl=zh-cn\n\nAndroid各个系统版本市场占有率表：\n![image](https://note.youdao.com/yws/api/personal/file/WEB9c984ab2b3606d4f688dee72ff7fb30f?method=download&shareKey=288a168344f4c3da4e4930c699d19ee2)\nAndroid各个系统版本市场占有率图：\n![image](https://note.youdao.com/yws/api/personal/file/WEB75a72b0c1a2257ce5215bc18bb38a8d4?method=download&shareKey=cc627bcace397474e82ad2ad8355057c)\n\n总结，由上表和上图可知：\n+ Android6.0、Android7.0,7.1、Android8.0,8.1占据了3/4的Android市场。\n+ 单个系统版本市场占有率最高的为Android 6.0，即API 23 \n+ 复合系统\b版本市场占有率最高的为Android 7.0系列，其中7.0为18.1%，7.1为10.1%\n+ \n","tags":["Android"]},{"title":"Java 打印堆栈信息","url":"/2018/12/26/Java-打印堆栈信息/","content":"#java打印堆栈信息\n\n+ 在函数内部打印函数调用堆栈\n```\nLog.d(TAG,Log.getStackTraceString(new Throwable()));\n```\n+ 出异常时打印当前堆栈\n```\ntry{\n\n}\ncatch(Exception e){\n    e.printStackTrace();\n}\n```\n+ 使用StackTraceElement[]打印\n```\nThrowable ex = new Throwable();\nStackTraceElement[] stackElements = ex.getStackTrace();\nif (stackElements != null) {\n    for (int i = 0; i < stackElements.length; i++) {\n        System.out.print(stackElements[i].getClassName()+\"/t\");\n        System.out.print(stackElements[i].getFileName()+\"/t\");\n        System.out.print(stackElements[i].getLineNumber()+\"/t\");\n        System.out.println(stackElements[i].getMethodName());\n        System.out.println(\"-----------------------------------\");\n    }\n}\n```\n+ 使用Thread打印\n```\nThread.currentThread().getStackTrace()\n```\n+ 使用exception打印\n```\nException e = new Exception(\"this is a log\");\ne.printStackTrace();\n```","tags":["Java，堆栈"]},{"title":"Android Oat文件分析","url":"/2018/12/26/Oat文件分析/","content":"\n.oatdata -> .rodata(oatHeader、dex文件相关信息、dex原始文件、类中方法与翻译为native code的对应关系)\n.oatexec -> .text(native code)\n\nOat文件结构概览：\n\n![avatar](https://note.youdao.com/yws/api/personal/file/WEBd91be5da5cc9c70b50ac5355d12d6e84?method=download&shareKey=cfbfd9c6f94f41b648fc4d3b4ebacadb)\n# elf文件结构(32位)：\n```\ntypedef uint16_t Elf32_Half; //2 bytes\ntypedef uint32_t Elf32_Word; //4 bytes\ntypedef uint32_t Elf32_Addr; //4 bytes\ntypedef uint32_t Elf32_Off;  //4 bytes\ntypedef int32_t  Elf32_Sword;//4 bytes\n```\n```\n// Object file magic string.\nstatic const char ElfMagic[] = { 0x7f, 'E', 'L', 'F', '\\0' }\n```\n```\n// e_ident size and indices.\nenum {\n  EI_MAG0       = 0,          // File identification index.\n  EI_MAG1       = 1,          // File identification index.\n  EI_MAG2       = 2,          // File identification index.\n  EI_MAG3       = 3,          // File identification index.\n  EI_CLASS      = 4          ,// File class.\n  EI_DATA       = 5,          // Data encoding.\n  EI_VERSION    = 6,          // File version.\n  EI_OSABI      = 7,          // OS/ABI identification.\n  EI_ABIVERSION = 8,          // ABI version.\n  EI_PAD        = 9,          // Start of padding bytes.\n  EI_NIDENT     = 16          // Number of bytes in e_ident.\n};\n```\nelf文件头结构：（16+4+20+12=52字节，1+2+5+6=14项）\n```\nstruct Elf32_Ehdr{\n    unsigned char e_ident[EI_NIDENT];//ELF文件魔数          16字节\n    Elf32_Half  e_type;              //ELF文件类型（32/64位）2字节  2*2\n    Elf32_Half  e_machine;           //该ELF文件所需要的架构  2字节\n    Elf32_Word  e_version;           //ELF文件版本（始终为1） 4字节   4*5\n    Elf32_Addr  e_entry;             //程序入口地址          4字节\n    Elf32_Off   e_phoff;             //segment表偏移地址     4字节\n    Elf32_Off   e_shoff;             //section表偏移地址     4字节\n    Elf32_Word  e_flags;             //标志                 4字节\n    Elf32_Half  e_ehsize;            //ELF文件头大小         2字节   2*6\n    Elf32_Half  e_phentsize;        //segment表项大小        2字节\n    Elf32_Half  e_phnum;            //segment表项数目        2字节\n    Elf32_Half  e_shentsize;        //section表项大小        2字节  \n    Elf32_Half  e_shnum;            //section表项数目        2字节\n    Elf32_Half  e_shstrndx;         //段表字符串表在section表中的下标 2字节\n};\n```\n```\n// File types\nenum {\n  ET_NONE   = 0,      // No file type\n  ET_REL    = 1,      // Relocatable file\n  ET_EXEC   = 2,      // Executable file\n  ET_DYN    = 3,      // Shared object file\n  ET_CORE   = 4,      // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n```\n```\n// Machine architectures\nenum {\n    EM_NONE = 0, // No machine\n    EM_ARM  = 40 // ARM\n    ...\n};\n```\n案例分析①：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n>7F 45 4C 46 01 01 01 03 00 00 00 00 00 00 00 00\n03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00\n70 50 48 00 00 00 00 05 34 00 20 00 05 00 28 00\n08 00 07 00\n\n魔数：7F 45 4C 46 //0x464c457f  \n位宽：01 //0x01代表32位；0x02代表64位    \n端序：01 //0x01代表小端；0x02代表打断    \n版本：01   \n操作系统：03 //0x03代表Linux  \n00 00 00 00 00 00 00 00   \n文件类型：03 00  //0x03:共享文件    \n芯片架构：28 00 // 0x28 ARM架构   \n文件版本：01 00 00 00 //0x01 (始终为1)    \n程序入口地址：00 00 00 00 //0x0   \nsegment表偏移：34 00 00 00 //0x34   \nsection表偏移：70 50 48 00 //0x485070   \n标志：00 00 00 05   //0x5000000   \n文件头大小：34 00   //0x34    \nsegment表项大小：20 00  //0x20    \nsegment表项数目：05 00  //0x05    \nsection表项大小：28 00  //0x28    \nsection表项数目：08 00  //0x08    \n段表字符串表在段表中下标：07 00 //0x07\n\n----\n\nsegment头结构：（8项，每项4个字节，32字节）\n```\nstruct Elf32_Phdr{\n    Elf32_Word  p_type;//segment类型\n    Elf32_Off   p_offset;//segment相对文件开始的偏移\n    Elf32_Addr  p_vaddr;//segment映射到内存中的首字节地址（即虚拟地址）\n    Elf32_Addr  p_paddr;//在物理地址定位有关的系统中，该字段是为该段的物理地址而保留的，对于可执行文件和共享的object而言是未指定内容的。\n    Elf32_Word  p_filesz;//在文件映像中该segment的字节数（可能是0）\n    Elf32_Word  p_memsz;//在内存映像中该segment的字节数（可能是0）\n    Elf32_Word  p_flags;//segment标志\n    Elf32_Word  p_align;//可载入的进程段必须有合适的p_vaddr、p_offset值，取页面大小的模。该字段给出了该段在内存和文件中排列值。0和1表示不需要排列。否则，p_align必须为正的2的幂\n};\n```\n```\n// Segment types.\nenum {\n    PT_NULL    = 0, // Unused segment.空值\n    PT_LOAD    = 1, // Loadable segment.加载到内存中\n    PT_DYNAMIC = 2, // Dynamic linking information.动态链接\n    PT_INTERP  = 3, // Interpreter pathname.动态链接的辅助信息\n    PT_NOTE    = 4, // Auxiliary information.其他信息\n    PT_SHLIB   = 5, // Reserved.RFU\n    PT_PHDR    = 6, // The program header table itself.segment表头的位置和大小\n    PT_TLS     = 7, // The thread-local storage template.\n    ...\n};\n```\n案例分析②：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n由ELF文件头知：segment表偏移为0x34;表大小为0x05;表项大小为0x20;推出segment头表大小为：0x05*0x20=0xa0 \n\n>06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00 //PT_PHDR  \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 //PT_LOAD   \n00 10 2A 00 00 10 2A 00 04 00 00 00 00 10 00 00   \n01 00 00 00 00 10 2A 00 00 10 2A 00 00 10 2A 00 //PT_LOAD   \n48 35 1E 00 48 35 1E 00 05 00 00 00 00 10 00 00   \n01 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_LOAD   \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n02 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_DYNAMIC    \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n\n第一个segment头：   \n06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00   \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \nsegment类型：06 00 00 00    //PT_PHDR(程序头表自身)   \nsegment文件偏移：34 00 00 00    \nsegment虚拟地址：34 00 00 00    \nsegment物理地址：34 00 00 00    \n文件映像中该segment字节数：A0 00 00 00    \n内存映像中该segment字节数：A0 00 00 00    \nsegment标志：04 00 00 00    \nsegment对齐：04 00 00 00\n\n其他segment头:    \n省略...\n\nsection头结构：（10项，每项4个字节，40字节）\n```\nstruct Elf32__Shdr{\n  Elf32_Word sh_name;      // Section name (index into string table), section名字，string table的索引\n  Elf32_Word sh_type;      // Section type (SHT_*),section的类型\n  Elf32_Word sh_flags;     // Section flags (SHF_*),section标记，用来描述多个属性\n  Elf32_Addr sh_addr;      // Address where section is to be loaded,若该section被加载到内存中，该字段表示其在内存中的位置\n  Elf32_Off  sh_offset;    // File offset of section data, in bytes,该section在文件中的偏移，SHT_NOBITS类型的section在文件中不占用空间，概念上的位置\n  Elf32_Word sh_size;      // Size of section, in bytes,section大小，SHT_NOBITS类型的section该值可能为非0，但是不占文件空间\n  Elf32_Word sh_link;      // Section type-specific header table index link,到section头表的链接\n  Elf32_Word sh_info;      // Section type-specific extra information,额外信息\n  Elf32_Word sh_addralign; // Section address alignment,地址对齐\n  Elf32_Word sh_entsize;   // Size of records contained within the section,一些sections保留着一张固定大小入口的表，对于此类型的section，该字段给除了每个入口的字节大小\n};\n```\n```\n// Section types.\nenum {\n    SHT_NULL          = 0,  // No associated section (inactive entry).\n    SHT_PROGBITS      = 1,  // Program-defined contents.\n    SHT_SYMTAB        = 2,  // Symbol table. 符号表\n    SHT_STRTAB        = 3,  // String table. 字符串表\n    SHT_RELA          = 4,  // Relocation entries; explicit addends.\n    SHT_HASH          = 5,  // Symbol hash table.\n    SHT_DYNAMIC       = 6,  // Information for dynamic linking.\n    SHT_NOTE          = 7,  // Information about the file.\n    SHT_NOBITS        = 8,  // Data occupies no space in the file.\n    SHT_REL           = 9,  // Relocation entries; no explicit addends.\n    SHT_SHLIB         = 10, // Reserved.\n    SHT_DYNSYM        = 11, // Symbol table.  动态符号表\n    SHT_INIT_ARRAY    = 14, // Pointers to initialization functions.\n    SHT_FINI_ARRAY    = 15, // Pointers to termination functions.\n    SHT_PREINIT_ARRAY = 16, // Pointers to pre-init functions.\n    SHT_GROUP         = 17, // Section group.\n    SHT_SYMTAB_SHNDX  = 18, // Indices for SHN_XINDEX entries\n};\n```\n案例分析③：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex    \n由ELF文件头知：section表偏移为0x485070;表项大小为0x28;表项数目为0x08;推出section头表大小为0x28*0x08=0x140\n\n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 0B 00 00 00   \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00   \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00 11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00   \n25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00 2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\n第一个section头：//No associated section (inactive entry).   \n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00\n\n第二个section头：(.dynsym) //Symbol table    \n>01 00 00 00 0B 00 00 00                            \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n\nsection名称：01 00 00 00    //在字符串表中的下标    \nsection类型：0B 00 00 00    //0xb 符号表 .symbol    \n\n第三个section头：(.dynstr)\n>09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00    \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00   \n\nsection名称：09 00 00 00    \nsection类型：03 00 00 00    //0x3 字符串表 .strtab    \nsection标记：02 00 00 00    \nsection虚拟地址：14 01 00 00    \nsection文件偏移：14 01 00 00 //0x0114    \nsection大小：64 00 00 00   //0x64 推出结束偏移：0x178   \nsection到section头表的链接：00 00 00 00     \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n根据section头信息，导出.dynstr内容：    \n>00 6F 61 74 64 61 74 61 00 6F 61 74 65 78 65 63   \n00 6F 61 74 6C 61 73 74 77 6F 72 64 00 64 61 74   \n61 40 61 70 70 40 63 6F 6D 2E 65 78 61 6D 70 6C   \n65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61 70 70   \n6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31 40 62   \n61 73 65 2E 61 70 6B 40 63 6C 61 73 73 65 73 2E   \n64 65 78 00\n\n对应的字符信息：    \n索引  |  值 \n---|:--:   \n0x0  |  \\00    \n0x1  | oatdata\\00\n0x9  | oatexec\\00\n0x11 | oatlastword\\00\n0x1d | data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\\00\n\n\n第四个section头：(.hash)\n>11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n\nsection名称：11 00 00 00     \nsection类型：05 00 00 00    //0x5 符号hash表    \n\n第五个section头：(.rodata)  [原dex信息,oatdata] [oat文件头起始位置]   \n>17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 \n\nsection名称：17 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：02 00 00 00    \nsection虚拟地址：00 10 00 00    \nsection文件偏移：00 10 00 00    //0x1000    \nsection大小：00 00 2A 00        //0x2A0000 推出结束偏移：0x2A1000   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头，导出.rodata内容：    \n[rodata.txt]\n\n第六个section头：(.text) [native code,oatexec]    \n>1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00  \n\nsection名称：1F 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：06 00 00 00    \nsection虚拟地址：00 10 2A 00    \nsection文件偏移：00 10 2A 00    //0x2A1000    \nsection大小：48 35 1E 00        //0x1E3548 推出结束偏移：0x484548   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头信息，导出.text内容：    \n[text.txt]\n\n**.text段 与 .dynamic段之间有一段空区域**\n\n第七个section头：(.dynamic)      \n>25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00     \n\nsection名称：25 00 00 00    \nsection类型：06 00 00 00    //Information for dynamic linking   \nsection标记：02 00 00 00    \nsection虚拟地址：00 50 48 00    \nsection文件偏移：00 50 48 00    //0x485000    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485038   \nsection到section头表的链接：01 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：08 00 00 00    \n\n第八个section头：(.shstrtab)：    \n由ELF文件头知：shstrtab在section头表总的下标为0x07,在本案例中即最后一个section \n>2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\nsection名称：2E 00 00 00    \nsection类型：03 00 00 00    //字符串表（段表字符串表）    \nsection标记：00 00 00 00    \nsection虚拟地址：00 00 00 00    \nsection文件偏移：38 50 48 00    //0x485038    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485070   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n依据section头信息，导出.shstrtab内容：    \n>00 2E 64 79 6E 73 79 6D 00 2E 64 79 6E 73 74 72   \n00 2E 68 61 73 68 00 2E 72 6F 64 61 74 61 00 2E   \n74 65 78 74 00 2E 64 79 6E 61 6D 69 63 00 2E 73   \n68 73 74 72 74 61 62 00\n\n对应的字符信息：\n索引  |  值\n---|:--:\n0x0  |  \\00\n0x01 |  .dynsym\\00\n0x09 |  .dynstr\\00\n0x11 |  .hash\\00\n0x17 |  .rodata\\00\n0x1f |  .text\\00\n0x25 |  .dynamic\\00\n0x2e |  .shstrtab\\00\n\n----\n\noat文件头结构：/art/runtime/oat.h\n```\nclass PACKED(4) OatHeader {\n    ...\n private:\n  ...\n  uint8_t magic_[4];    //魔数‘oat\\n’\n  uint8_t version_[4];  //oat文件版本号\n  uint32_t adler32_checksum_;   //校验和\n\n  InstructionSet instruction_set_;  //本地机器指令集，表示指令的类型（枚举类型）/art/runtime/instruction_set.h\n  InstructionSetFeatures instruction_set_features_; //架构特性\n  uint32_t dex_file_count_; //oat文件包含的dex文件个数\n  uint32_t executable_offset_;  //oatexec段开始位置与oatdata段开始位置的偏移值（oatexec段开始位置+executable_offset_=oatdata段开始位置）\n\n  uint32_t interpreter_to_interpreter_bridge_offset_;   //用来从解释器调用另外一个也是通过解释器来执行的类方法的trampoline代码的偏移位置\n  uint32_t interpreter_to_compiled_code_bridge_offset_; //用来从解释器调用另外一个通过本地机器指令执行的类方法的trampoline代码的偏移位置\n  uint32_t jni_dlsym_lookup_offset_;    //类方法在执行过程中，若被调用的方法是JNI函数，那么通过存放在此位置的trampoline代码来调用\n  uint32_t portable_imt_conflict_trampoline_offset_;    //...\n  uint32_t portable_resolution_trampoline_offset_;  //用来在运行时解析还未链接的类方法的trampoline代码位置（portable类型的机器指令）\n  uint32_t portable_to_interpreter_bridge_offset_;  //用来从本地机器指令（portable类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n  uint32_t quick_generic_jni_trampoline_offset_;    //...\n  uint32_t quick_imt_conflict_trampoline_offset_;   //...\n  uint32_t quick_resolution_trampoline_offset_; //用来在运行时解析还未链接的类方法的trampoline代码位置（quick类型的机器指令）\n  uint32_t quick_to_interpreter_bridge_offset_;  //用来从本地机器指令（quick类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n\n  //由于每一个应用程序都会依赖于boot.art文件，上述10个变量指向的trampoline代码段只存在于boot.art文件中，即在应用程序classes.dex生成的oat文件的oatdata段头部，上述变量值均为0\n\n  // The amount that the image this oat is associated with has been patched.\n  int32_t image_patch_delta_;   //该oat文件关联的image被patch的数量\n\n  uint32_t image_file_location_oat_checksum_;   //用来创建image空间的oat文件的校验和\n  uint32_t image_file_location_oat_data_begin_; //用来创建image空间的oat文件的oatdata段在内存的位置\n\n  uint32_t key_value_store_size_;   //用来创建image空间的文件路径的大小\n  uint8_t key_value_store_[0];  // note variable width data at end\n\n  DISALLOW_COPY_AND_ASSIGN(OatHeader);\n};\n```\n```\n// InstructionSet\nenum InstructionSet {\n  kNone,\n  kArm,\n  kArm64,\n  kThumb2,\n  kX86,\n  kX86_64,\n  kMips,\n  kMips64\n};\n```\n\n案例分析④：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n开始位置：0x1000    \n由rodata.txt中的数据及oat文件头结构知：   \n魔数：6F 61 74 0A   //大端序，0x6f61740a    \n版本号：30 33 39 00 //大端序，0x30333900    \n校验和：E4 E3 11 75   \n指令类型：03 00 00 00   \n指令集特性：01 00 00 00   \n包含的dex文件个数：01 00 00 00    \noatexec段开始位置相对于oatdata段开始位置的偏移：00 00 2A 00   \n解释器执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \n解释器执行到本地机器指令执行的trampoline代码的偏移位置：00 00 00 00   \nJNI方法调用的trampoline代码的偏移位置：00 00 00 00    \nportable_imt_conflict_trampoline_offset_：00 00 00 00   \n本地机器指令（portable）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00   \n本地机器指令（portable）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \nquick_generic_jni_trampoline_offset_：00 00 00 00   \nquick_imt_conflict_trampoline_offset_：00 00 00 00    \n本地机器指令（quick）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00    \n本地机器指令（quick）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00    \nimage_patch_delta_：00 00 00 00   \n创建image空间的oat文件的校验和：8E 72 EE 60   \n创建image空间的oat文件的oatdata段在内存的位置：00 F0 17 71    \nkey_value_store_size_：A6 01 00 00    \nkey_value_store_：(dex2oat的参数)   \n\n依据key_value_store_size_导出key_value_store_的内容：   \n>64 65 78 32 6F 61 74 2D 63 6D 64 6C 69 6E 65 00   \n2D 2D 7A 69 70 2D 66 64 3D 36 20 2D 2D 7A 69 70   \n2D 6C 6F 63 61 74 69 6F 6E 3D 2F 64 61 74 61 2F   \n61 70 70 2F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E   \n70 61 73 73 65 72 62 79 2E 6D 79 61 70 70 6C 69   \n63 61 74 69 6F 6E 2E 61 70 70 2D 31 2F 62 61 73   \n65 2E 61 70 6B 20 2D 2D 6F 61 74 2D 66 64 3D 37   \n20 2D 2D 6F 61 74 2D 6C 6F 63 61 74 69 6F 6E 3D   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 64 61 74 61 40 61 70 70 40   \n63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 70 61 73 73   \n65 72 62 79 2E 6D 79 61 70 70 6C 69 63 61 74 69   \n6F 6E 2E 61 70 70 2D 31 40 62 61 73 65 2E 61 70   \n6B 40 63 6C 61 73 73 65 73 2E 64 65 78 20 2D 2D   \n69 6E 73 74 72 75 63 74 69 6F 6E 2D 73 65 74 3D   \n61 72 6D 20 2D 2D 69 6E 73 74 72 75 63 74 69 6F   \n6E 2D 73 65 74 2D 66 65 61 74 75 72 65 73 3D 64   \n69 76 20 2D 2D 72 75 6E 74 69 6D 65 2D 61 72 67   \n20 2D 58 6D 73 36 34 6D 20 2D 2D 72 75 6E 74 69   \n6D 65 2D 61 72 67 20 2D 58 6D 78 35 31 32 6D 00   \n64 65 78 32 6F 61 74 2D 68 6F 73 74 00 41 72 6D   \n00 69 6D 61 67 65 2D 6C 6F 63 61 74 69 6F 6E 00   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 73 79 73 74 65 6D 40 66 72   \n61 6D 65 77 6F 72 6B 40 62 6F 6F 74 2E 61 72 74   \n00 78 70 6F 73 65 64 2D 6F 61 74 2D 76 65 72 73   \n69 6F 6E 00 32 00\n\n对应的字符信息：\n\ndex2oat-cmdline\\00    \n--zip-fd=6    --zip-location=/data/app/com.example.passerby.myapplication.app-1/base.apk --oat-fd=7     --oat-location=/data/dalvik-cache/arm/data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex --instruction-set=arm --instruction-set-features=div --runtime-arg -Xms64m --runtime-arg -Xmx512m\\00   \ndex2oat-host\\00   \nArm\\00    \nimage-location\\00   \n/data/dalvik-cache/arm/system@framework@boot.art\\00   \nxposed-oat-version\\00   \n2\\    \n\nOatHeader后就是Dex文件相关信息(开始位置:0x11FA):      \n根据OatHeader中dex_file_count_的值可知，此处共包含1个Dex文件的内容。    \n若用DexMetaData结构表示Dex文件的内容，其包含的字段如下： \n```   \nuint32_t dex_file_location_size;     //dex文件路径的字节数(4字节)    \nchar* dex_file_location_data;        //dex文件的路径    \nuint32_t dex_file_checksum;          //dex文件的校验和(4字节)    \nuint32_t dex_file_offset;            //dex文件相对于oatdata段开始地址的偏移(4字节)   \nconst uint32_t* methods_offsets_pointer;//是一个数组，元素共有class_defs_size（dex中类的数目）个，该数组的索引与dex中类的索引是一致的，\n                                        即第0个类对应methods_offsets_pointer[0],元素的值是相对于oatdata段开始地址的偏移，\n                                        比如dex中第0个类对应的OatClass在文件中的开始地址=methods_offsets_pointer[0]+oatdata段开始地址。   \n```\n所以，整个DexMetaData的字节数=OatHeader->dex_file_count_ * (4+dex_file_location_data+4+4+4*dex->class_defs_size)\n                          = OatHeader->dex_file_count_ * (12+ dex_file_location_data + 4 * dex->class_defs_size)\n\n案例分析⑤：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n根据OatHeader的结束位置导出Dex文件信息(0x11FA)：   \n>3B 00 00 00 2F 64   \n61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78 61 6D   \n70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61   \n70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31   \n2F 62 61 73 65 2E 61 70 6B 7C 2B D8 F3 7C 18 00   \n00 4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22   \n00 9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22   \n00 4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22   \n00 CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22   \n00 44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22   \n....\n\ndex文件路径的字节数：3B 00 00 00  //0x3B = 3*16+11个字节    \ndex文件路径：   \n2F 64 61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78     \n61 6D 70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D     \n79 61 70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70     \n2D 31 2F 62 61 73 65 2E 61 70 6B    \n\n对应的字符信息：    /data/app/com.example.passerby.myapplication.app-1/base.apk   \ndex文件校验和：7C 2B D8 F3    \ndex文件相对于oatdata段开始地址的偏移：7C 18 00 00   //0x187c  相对于oat文件的偏移：0x1000 + 0x187c = 0x287c   \n\nmethods_offsets_pointer:（每项4个字节，共class_defs_size项，即1422项，结束位置：0x1241+1422*4 = 0x2879）    \n>4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22 00     \n9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22 00     \n4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22 00     \nCC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22 00     \n44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22 \n...\n00 C0 7D 23 00 C4 7E 23 00 00\n\n根据dex文件地址(0x287c-0x2A1000)导出数据：   \n64 65 78 0A 30 33 35 00 39 DD DD F3 29 80 26 28     \n9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C     \nD0 0A 22 00 70 00 00 00 78 56 34 12 00 00 00 00     \n00 00 00 00 F4 09 22 00 19 53 00 00 70 00 00 00     \n87 08 00 00 D4 4C 01 00 51 0D 00 00 F0 6E 01 00     \nB0 3A 00 00 BC 0E 02 00 DF 3E 00 00 3C E4 03 00     \n8E 05 00 00 34 DB 05 00 DC 7D 1B 00 F4 8C 06 00   \n...\n\n可以看到dex文件的文件头：   \n魔数：64 65 78 0A 30 33 35 00  //对应的字符信息dex.035    \ndex文件校验和：39 DD DD F3    \ndex文件sha1签名：29 80 26 28 9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C    \ndex文件大小：D0 0A 22 00        //0x220AD0 推出文件结束地址： 0x287c + 0x220ad0 = 0x22334c    \n文件头大小：70 00 00 00         //0x70    \n字节序：78 56 34 12            //0x12345678 小端序    \nlink_size_:00 00 00 00    \nlink_off_:00 00 00 00   \nmap_off_:F4 09 22 00    \nstring_ids_size_:19 53 00 00    \nstring_ids_off_:70 00 00 00   \ntype_ids_size_:87 08 00 00    \ntype_ids_off_:D4 4C 01 00   \nproto_ids_size_:51 0D 00 00   \nproto_ids_off_:F0 6E 01 00    \nfield_ids_size_:B0 3A 00 00   \nfields_ids_off_:BC 0E 02 00   \nmethod_ids_size_:DF 3E 00 00    \nmethods_ids_off_:3C E4 03 00    \nclass_defs_size_:8E 05 00 00    //0x058E,1422,dex文件中共包含1422个类定义    \nclass_defs_off_:34 DB 05 00     //0x05db34,相对于dex文件头的偏移位置，相对于oat文件的偏移：0x05db34+0x287c=0x0603b0   \ndata_size_:DC 7D 1B 00    \ndata_off_:F4 8C 06 00   \n\n案例分析⑥：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex   \n\n使用dextra工具导出该oat文件中的dex或手动选中dex文件地址范围保存：（采用export的方式导出010的dex模板会识别不了，应该是导 出的格式有问题;下面所说的偏移都是相对于导出dex文件的偏移）\n在010工具的type_ids中查找MainActivity，找到对应的索引号1925，转为16进制即：85 07 00 00 ，在010中全局搜索’85 07 00 00‘，找到MainActivity类定义偏移0x68cd4。\n借助dex分析模板，找到mainActivity类定义的偏移位置：0x068cd4,由DexClassDef结构知，每个DexClassDef大小为32个字节    \n>85 07 00 00 01 00 00 00 14 05 00 00 00 00 00 00   \n3E 16 00 00 00 00 00 00 5A 9C 20 00 00 00 00 00   \n\n类类型：85 07 00 00     //0x0785，指向type_ids的索引    \n访问标志：01 00 00 00   //0x1，public   \n父类类型：14 05 00 00   //0x0514，指向type_ids的索引    \n接口偏移：00 00 00 00   //0x0，指向type_ids的索引，class不为interface,此项值为0   \n源文件名：3E 16 00 00   //0x163e，指向string_ids的索引,string_ids[5094]，MainActivity.java    \n注解偏移：00 00 00 00   //0x0，指向DexAnnotationsDirectoryItem结构，若无此项内容，该值为0   \n类数据偏移：5A 9C 20 00 //0x209c5a，指向DexClassData结构的偏移    \n类静态数据偏移：00 00 00 00 //0x0，指向DexEncodedArray结构的偏移    \n\n查看类数据：（0x209c5a）  \n>00 02 01 02 8D 67 00 01 00 9B 79 81 80 04 8C E8   \n4B 9C 79 01 A4 E8 4B 02 04 80 E9 4B 03 04 00 04   \n01 04 02 02 04 02 04 01 02 1E 04 FF 01 37 6C 21   \n01 37 6D 21 04 04 05 04 03 04 02 04 04 0C 64 27   \n00 02 7F 64 7A 00 02 7F 64 7C 00 02 7F 64 7D 00   \n02 7F 64 7E 00 02 7F 64 7F 00 02 7F 64 80 00 02   \n7F 64 81 00 02 7F 64 82 00 02 7F 64 83 00 02 7F   \n64 84 00 02 7F 64     \n...\nclassDataHeader:\n静态字段个数：0\n实例字段个数：2\n非虚方法：1\n虚方法：2\n\n字段：...\n\n非虚方法：...\n\n虚方法：...\n\n由该MainActivity类定义的偏移位置和class_defs_off偏移位置知：    \n(0x68cd4-0x5db34)/32=1421,即MainActivity是dex文件中第1422个类定义，在类定义列表中的下标为1421 \n对应methods_offsets_pointer[1421]\n\nmethods_offsets_pointer[1421]:C4 7E 23 00   //0X237EC4,该类对应的OatClass相对于oatdata的偏移    \n推出MainActivity对应的OatClass在文件中的偏移：0x237ec4+0x1000 = 0x238ec4   \n\nMainActivity对应的OatClass:(一个direct方法，一个virtual方法)   \n>08 00 00 00 B9 31 48 00 E0 7E 23 00 11 32 48 00    \nEF 5A 27 00 61 33 48 00 23 5B 27 00 09 00 03 00   \n28 01 3A 00 08 01 09 00 05 00 36 07 2C 07 48 00   \n08 06 24 06 09 00 06 00 62 00 34 06 08 06 24 06   \n3E 06 5A 06 09 00 03 00 5A 00 2C 07 08 07 09 00   \n0A 00 82 7A 9E 7A BC 00 C4 00 D6 00 CE 62 94 7A   \n72 6A 08 60 78 7A 00 00 00 00 09 00   \n...\n\n//TODO\nstatus:08 00  //kStatusVerified\ntype:00 00    //kOatClassAllCompiled(没有bitmap结构)\nOatMethodOffSets[0]:B9 31 48 00 E0 7E 23 00\nOatMethodOffSets[1]:11 32 48 00 EF 5A 27 00\n...\n\nOatClass结构分析：  \n```\n//art/runtime/oat_file.h\nclass OatClass {\n    ...\n    private:\n    OatClass(\n        const OatFile* oat_file,\n        mirror::Class::Status status,\n        OatClassType type,\n        uint32_t bitmap_size,\n        const uint32_t* bitmap_pointer,\n        const OatMethodOffsets* methods_pointer\n    );\n    const OatFile*  oat_file_;\n    mirror::Class:Status status_;    //2 bytes\n    OatClassType type_;  //2 byes\n    const uint32_t* bitmap_;\n    const OatMethodOffsets* methods_pointer_;//方法的偏移数组，指向相应的native code，4bytes，OatMethodOffset的个数是该类被编译为native code的个数\n    friend class OatDexFile;\n}\n```\n```\n// art/runtime/mirror/class.h\n enum Status {\n    kStatusRetired = -2,\n    kStatusError = -1,\n    kStatusNotReady = 0,\n    kStatusIdx = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.\n    kStatusLoaded = 2,  // DEX idx values resolved.\n    kStatusResolving = 3,  // Just cloned from temporary class object.\n    kStatusResolved = 4,  // Part of linking.\n    kStatusVerifying = 5,  // In the process of being verified.\n    kStatusRetryVerificationAtRuntime = 6,  // Compile time verification failed, retry at runtime.\n    kStatusVerifyingAtRuntime = 7,  // Retrying verification at runtime.\n    kStatusVerified = 8,  // Logically part of linking; done pre-init.\n    kStatusInitializing = 9,  // Class init in progress.\n    kStatusInitialized = 10,  // Ready to go.\n    kStatusMax = 11,\n};\n```\n```\n// art/runtime/oat.h （OatClass类型不一样，methods_pointer_数组中的偏移位置的计算方式不一样）\nenum OatClassType {\n  kOatClassAllCompiled = 0,   // OatClass is followed by an OatMethodOffsets for each method.\n  kOatClassSomeCompiled = 1,  // A bitmap of which OatMethodOffsets are present follows the OatClass.\n  kOatClassNoneCompiled = 2,  // All methods are interpretted so no OatMethodOffsets are necessary.\n  kOatClassMax = 3,\n};\n```\n```\n// art/runtime/oat.h\nclass PACKED(4) OatMethodOffsets {\n public:\n  OatMethodOffsets();\n\n  OatMethodOffsets(uint32_t code_offset,\n                   uint32_t gc_map_offset);\n\n  ~OatMethodOffsets();\n\n  uint32_t code_offset_;//native code相对于oatdata段的偏移\n  uint32_t gc_map_offset_;\n};\n```\n// OatMethodOffsets 计算方法    \n//函数参数method_idx是方法在dex表示的类中的偏移，比如类的第0个方法method_index为0，第一个方法为method_index为1，依次类推。    \n由于在OatClass中没有保存类中方法的数目，因而没有检查method_index的边界。    \n```\nconst OatMethodOffsets* OatFile::OatClass::GetOatMethodOffsets(uint32_t method_index) const {\n  // NOTE: We don't keep the number of methods and cannot do a bounds check for method_index.\n  if (methods_pointer_ == nullptr) {//没有编译成native code\n    CHECK_EQ(kOatClassNoneCompiled, type_);\n    return nullptr;\n  }\n  size_t methods_pointer_index;\n  if (bitmap_ == nullptr) {//该类所有方法被编译成native code\n    CHECK_EQ(kOatClassAllCompiled, type_);\n    methods_pointer_index = method_index;\n  } else {\n    CHECK_EQ(kOatClassSomeCompiled, type_);\n    if (!BitVector::IsBitSet(bitmap_, method_index)) {//该方法没有对应的native code\n      return nullptr;\n    }\n    size_t num_set_bits = BitVector::NumSetBits(bitmap_, method_index);//使用bitmap记录哪些方法被编译成了native code\n    methods_pointer_index = num_set_bits;//找到相应的索引\n  }\n  const OatMethodOffsets& oat_method_offsets = methods_pointer_[methods_pointer_index];\n  return &oat_method_offsets;\n}\n```\n```\n//art/runtime/base/bit_vector.cc\nuint32_t BitVector::NumSetBits(const uint32_t* storage, uint32_t end) {\n  uint32_t word_end = end >> 5; // end/32\n  uint32_t partial_word_bits = end & 0x1f;// end%32\n\n  uint32_t count = 0u;// 为1的位的数目\n  for (uint32_t word = 0u; word < word_end; word++) {//先算前word_end个字中为1的位的数目，再算不满一个字的前partial_word_bits位中为1的位的数目\n    count += POPCOUNT(storage[word]);\n  }\n  if (partial_word_bits != 0u) {\n    count += POPCOUNT(storage[word_end] & ~(0xffffffffu << partial_word_bits));\n  }\n  return count;\n}\n```\nBitmap的作用：\n* Bitmaps are used to represent which methods are compiled.\n* Each bit represents every method in the class ,starting with direct methods,then virtual methods.\n* If bit it is set,the method is compiled.\n\n从OatClass中获取指定方法的native code时，返回的是OatMethod对象，源码如下：    \n/art/runtime/oat_file.cc\n```\n//method_index描述的是目标方法在类中的编号\nconst OatFile::OatMethod OatFile::OatClass::GetOatMethod(uint32_t method_index) const {\n  const OatMethodOffsets* oat_method_offsets = GetOatMethodOffsets(method_index);//获取方法偏移\n  if (oat_method_offsets == nullptr) {\n    return OatMethod(nullptr, 0, 0);\n  }\n  if (oat_file_->IsExecutable() ||\n      Runtime::Current() == nullptr ||        // This case applies for oatdump.\n      Runtime::Current()->IsCompiler()) {\n    return OatMethod(\n        oat_file_->Begin(),\n        oat_method_offsets->code_offset_,\n        oat_method_offsets->gc_map_offset_);\n  } else {\n    // We aren't allowed to use the compiled code. We just force it down the interpreted version.\n    return OatMethod(oat_file_->Begin(), 0, 0);\n  }\n}\n```\n```\n/art/runtime/oat_file.h\nclass OatMethod{\n    public:\n    ...\n    OatMethod(\n        const byte* base,\n        const uint32_t code_offset,\n        const uint32_t gc_map_offset\n    );\n    OatMethod(){}\n    private:\n    ...\n    const byte* begin_; //oatdata段开始位置\n    uint32_t code_offset_;  //OatMethodOffsets->code_offset_\n    uint32_t native_gc_map_offset_;\n    friend class OatClass;\n};\n```\n然后就可以通过OatMethod来定位到方法的native code了（begin_+code_offset_）。\n\n总结：  \n* Oat文件其实就是类型为shared object 的Elf文件，首先有一个Elf Header，Elf Header中e_phoff字段指向了program header talbe，e_shoff字段指向了section header table；\n* section header table中有一个名字为.dynsym的section head，该section head描述的section是符号表；\n* Oat文件导出了3个符号：oatdata，oatexec，oatlastword；\n* oatdata指向oatdata段，该区域存的是只读数据，包括 OatHeader，dex相关信息，dex类中方法与native code的映射关系（由 OatClass表示），通过OatClass可以找到对应方法的native code；\n* oatexec指向oatexec段，该区域存的是方法的native code，是可执行的；\n* oatlastword指向oatexec段的最后一个字的开始地址。即oatexec段的结束地址=oatlastword->st_value+3。\n","tags":["Android Oat"]},{"title":"Hello World","url":"/2018/12/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]