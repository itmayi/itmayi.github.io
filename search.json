[{"title":"现代密码学基础六","url":"/2019/01/06/现代密码学基础六/","content":"\n## 攻击模式\n\n在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。\n\n这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类\n\n+ 唯密文攻击：攻击者仅能获得一些加密过的密文。\n+ 已知明文攻击：攻击者有一些密文对应的明文。\n+ 选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。\n+ 选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。\n+ 相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后+ 的密文或明文。但是攻击者不知道这些密钥。\n\n## 常见攻击方法\n根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有\n\n+ 暴力攻击\n+ 中间相遇攻击\n+ 线性分析\n+ 差分分析\n+ 不可能差分分析\n+ 积分分析\n+ 代数分析\n+ 相关密钥攻击\n+ 侧信道攻击\n","tags":["现代密码学","密码学攻击思路"],"categories":["密码学"]},{"title":"现代密码学基础五","url":"/2019/01/06/现代密码学基础五/","content":"\n## 数字签名\n\n在计算机世界中，我们可能会需要电子签名，因为我们大多数情况下会使用电子文件，那这时候怎么办呢？当然，我们仍然可以选择使用自己的名字。但其实还有另外一种方式，那就是采用数字签名，这种签名更加难以伪造，可信程度更高。数字签名的主要用处是确保消息确实来自于声称产生该消息的人。\n\n数字签名依赖于非对称密码，因为我们必须确保一方能够做的事情，而另一方不能够做出这样的事情。其基本原理如下\n\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/signature/figure/Digital_Signature_diagram.png)\n\n### RSA数字签名\n原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名。\n\n### DSA数字签名\n\n//TODO\n\n\n## 证书格式\n\n### DER\n使用该扩展名的证书采用**二进制编码**，当然，这些证书也可以使用 CER 或者 CRT 作为扩展名。\n\n### PEM\n使用该扩展名的证书采用 Base64 编码，文件的开始是一行 -----BEGIN。\n\n### 格式转换\n\n```\nopenssl x509 -outform der -in certificate.pem -out certificate.der\nopenssl x509 -inform der -in certificate.cer -out certificate.pem\n```\n\n","tags":["现代密码学","数字签名","证书格式"],"categories":["密码学"]},{"title":"现代密码学基础四","url":"/2019/01/06/现代密码学基础四/","content":"\n## 哈希函数\n哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。\b其一般模型如下：\n```\n任意长度(m)消息 -> hash散列函数 -> 固定长度h(m)\n```\n\n显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。\n\n散列值的目的如下\n\n+ 确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。\n+ 冗余校验\n+ 单向口令文件，比如 linux 系统的密码\n+ 入侵检测和病毒检测中的特征码检测\n\n目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。\n\n|算法类型\t|输出 Hash 值长度\n|-|-|\nMD5\t|128 bit / 256 bit\nSHA1 |\t160 bit\nSHA256\t| 256 bit\nSHA512 |\t512 bit\n\n\n\n","tags":["现代密码学","哈希函数"],"categories":["密码学"]},{"title":"现代密码学基础三","url":"/2019/01/05/现代密码学基础三/","content":"\n## 非对称加密\n\n### 简介\n在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。\n\n### RSA\nRSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n\nRSA 算法的可靠性由**极大整数因数分解**的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。\n\n#### 基本原理\n\n##### 公钥与私钥的产生\n\n+ 随机选择两个不同大质数p和q，计算N=pxq\n+ 根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)\n+ 选择一个小于r的整数e，使e和r互质。并求得e关于r的模反元素，命名为d，有ed≡1(mod r)。\n+ 将p和q的记录销毁。\n\n此时，(N,e)是公钥，(N,d)是私钥。\n\n注：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler's totient function)，它又称为Euler's totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。\n\n##### 消息加密\n\n首先需要将消息 m以一个双方约定好的格式转化为一个小于 N，且与N\n互质的整数 n。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：\n$n^e$ ≡ c (mod N)\n\n##### 消息解密\n\n利用密钥 d进行解密。\n$c^d$ ≡ n (mod N)\n\n#### 基本工具\n\n+ RSAtool\n  + 安装\n    ```\n    git clone https://github.com/ius/rsatool.git\n    cd rsatool\n    python rsatool.py -h\n    ```\n  + 生成私钥\n\n    ```\n    python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321\n    ```\n+ RSA Converter\n  + 根据给定的密钥对，生成pem文件\n  + g根据n,e,d，生成p,q\n+ openssl\n  + 查看公钥\b文件\n\n    ```\n    openssl rsa -pubin -in pubkey.pem -text -modulus\n    ```\n  + 解密\n    ```\n    rsautl -decrypt -inkey private.pem -in flag.enc -out flag\n    ```\n+ 分解整数工具\n  + 网站分解http://factordb.com/ \n  + 命令\b行分解https://github.com/ryosan-470/factordb-pycli借用 factordb 数据库。\n  + https://sourceforge.net/projects/yafu/\n\n+ python库\n  + primefac\n    整数分解库，包含了很多整数分解的算法。\n  + gmpy\n  + gmpy2\n    安装时，可能会需要自己另行安装 mfpr 与 mpc 库。\n  + pycrypto\n\n#### 侧信道攻击\n\n能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。\n\n能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。\n\n能量分析攻击分为： \n- 简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 \n- 差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。\n\n##### 攻击条件\n\n攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。\n\n### 背包加密\n\n#### 背包\b问题\n\n首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $1_1$,$a_2$,...,$a_n$\n 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题：  \n $x_1$$a_1$+$x_2$$a_2$+...+$x_n$$a_n$ = W\n\n \b其中$x_i$只能为0和1，显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。\n\n 在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$,即可得到加密结果。\n\n 但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。\n\n但是当$a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件：第 i 个数大于前面所有数的和。\n\n为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。\n\n### ECC\n\nECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有\n\n+ 以素数为模的整数域 GF(p)，通常在通用处理器上更为有效。\n+ 特征为 2 的伽罗华域 GF（2^m），可以设计专门的硬件。\n\n### 格密码\n\n格在数学上至少有两种含义\n\n+ 定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见 https://en.wikipedia.org/wiki/Lattice_(order)。\n+ 群论中的定义，是 [Math Processing Error] 中的满足某种性质的子集。当然，也可以是其它群。\n\n\n\n\n\n\n","tags":["现代密码学","非对称加密"],"categories":["密码学"]},{"title":"现代密码学基础二","url":"/2019/01/04/现代密码学基础二/","content":"\n## 块密码\n\n### 概述\n所谓块加密就是每次加密一块明文，常见的加密算法有\n\n+ IDEA 加密\n+ DES 加密\n+ AES 加密\n\n块加密也是对称加密。\n\n其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有**复杂**的加解密算法来加解密明密文。\n\n而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助\n\n+ padding，即 padding 到指定分组长度\n+ 分组加密模式，即明文分组加密的方式。\n\n### 基本策略\n\n在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。\n\n#### 混淆 \n混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下\n\n+ S 盒\n+ 乘法\n\n#### 扩散\n\n扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有\n\n+ 线性变换\n+ 置换\n+ 移位，循环移位\n\n### 常见加解密结构\n\n目前块加密中主要使用的是结构是\n\n+ 迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。\n\n#### 迭代结构\n\n##### 概述\n迭代结构基本如下，一般包括三个部分\n\n+ 密钥置换\n+ 轮加密函数\n+ 轮解密函数\n\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/figure/iterated_cipher.png)\n\n##### 轮函数\n\n目前来说，轮函数主要有主要有以下设计方法\n\n+ Feistel Network，由 Horst Feistel 发明，DES 设计者之一。\n  + DES\n+ Substitution-Permutation Network(SPN)\n  + AES\n+ 其他方案\n\n注：费思妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。因此，实现这种密码所需的代码或电路大小能几乎减半。费斯妥网络是一种迭代密码，其中的内部函数称为轮函数。\n\n注：代换-置换网络是一系列被应用于分组密码中相关的数学运算，代换（Substitution）和置换（Permutation）分别被称作S盒（替換盒，英语：S-boxes）和P盒（排列盒，英语：P-boxes）。这种加密网络使用明文和密钥作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文。\n\n##### 密钥扩展\n目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。\n\n### 常见块加密算法\n//TODO(ARX/DES/IDEA/AES/Simon and Speck)\n\n### 分组模式\n\n分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。\n\n#### 填充规则\n\n正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。\n\n常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。\n\n一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。\n\nPad with bytes all of the same value as the number of padding bytes (PKCS5 padding)\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\nPad with 0x80 followed by zero bytes (OneAndZeroes Padding)\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n这里其实就是和 md5 和 sha1 的 padding 差不多。\n\nPad with zeroes except make the last byte equal to the number of padding bytes\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\nPad with zero (null) characters\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\nPad with spaces\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n#### ECB模式\nECB 模式全称为电子密码本模式（Electronic codebook）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_decryption.png)\n\n##### 优点\n+ 实现简单。\n+ 不同明文分组的加密可以并行计算，速度很快。\n\n##### 缺点\n+ 同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_bad_linux.png)\n\n为了解决统一明文产生相同密文的问题，提出了其它的加密模式。\n\n##### 应用\n+ 用于随机数的加密保护。\n+ 用于单分组明文的加密。\n\n#### CBC模式\nCBC 全称为密码分组链接（Cipher-block chaining） 模式，这里\n\n+ IV 不要求保密\n+ IV 必须是不可预测的，而且要保证完整性。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_decryption.png)\n##### 优点 \n+ 密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。\n+ 具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。\n+ 具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。\n##### 缺点\n+ 加密不能并行，解密可以并行。\n\n##### 应用\n+ 常见的数据加密和 TLS 加密。\n+ 完整性认证和身份认证。\n\n##### 攻击\n+ 字节反转攻击\n  + IV 向量，影响第一个明文分组\n  + 第 n 个密文分组，影响第 n + 1 个明文分组\n+ Padding Oracle Attack，具体参见下面介绍\n\n#### PCBC模式\nPCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_decryption.png)\n\n##### 特点\n+ 解密过程难以并行化\n+ 互换邻接的密文块不会对后面的密文块造成影响\n\n#### CFB模式\nCFB 全称为密文反馈模式（Cipher feedback）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_decryption.png)\n\n##### 优点\n+ 适应于不同数据格式的要求\n+ 有限错误传播\n+ 自同步\n##### 缺点\n+ 加密不能并行化，解密不能并行\n\n##### 应用\n该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。\n\n#### OFB模式\nOFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_decryption.png)\n\n##### 优点\n+ 不具有错误传播特性。\n##### 缺点\n+ IV 无需保密，但是对每个消息必须选择不同的 IV。\n+ 不具有自同步能力。\n\n##### 应用\n适用于一些明文冗余度比较大的场景，如图像加密和语音加密。\n\n#### CTR模式\nCTR 全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png)\n\n#### Padding Oracle Attack\n\nPadding Oracle Attack 攻击一般需要满足以下几个条件\n\n+ 加密算法\n  + 采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。\n  + 分组模式为 CBC 模式。\n+ 攻击者能力\n  + 攻击者可以拦截上述加密算法加密的消息。\n  + 攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。\n\nPadding Oracle Attack 攻击可以达到的效果如下\n+ 在不清楚 key 和 IV 的前提下解密任意给定的密文。\n\n","tags":["现代密码学","块密码"],"categories":["密码学"]},{"title":"现代密码学基础一","url":"/2019/01/04/现代密码学基础一/","content":"\n## 流密码\n流密码一般逐字节或者逐比特处理信息。一般来说：\n+ 流密码的密钥长度会与明文的长度相同。\n+ 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。\n\n需要注意的是，流加密目前来说都是对称加密。\n\n伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。\n\n流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。\n\n流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。\n\n### 伪随机数生成器\n伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。\n\n就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。\n\n#### 随机性的严格性\n+ 随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。\n+ 不可预测性：不能从过去的序列推测出下一个出现的数。\n+ 不可重现性：除非数列保存下来，否则不能重现相同的数列。\n\n这三个性质的严格性依次递增。\n\n一般来说，随机数可以分为三类\n\n|类别|随机性|不可预测性|不可重现性|\n|-|-|-|-|\n|弱伪随机数|✅|❌|❌|\n|强伪随机数|✅|✅|❌|\n|真随机数|✅|✅|✅|\n\n一般来说，密码学中使用的随机数是第二种。\n\n#### 周期\n正如我们之前所说，一旦 PRNG 所依赖的种子确定了，那么 PRNG 生成的随机数序列基本也就确定了。这里定义 PRNG 的周期如下：对于一个 PRNG 的所有可能起始状态，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的(一般性限制条件)。\n\n#### 分类\n目前通用的伪随机数生成器主要有：\n+ 线性同余生成器，LCG\n+ 线性回归发生器\n+ 线性反馈移位寄存器（Linear feedback shift register，LFSR）\n+ Mersenne Twister\n+ xorshift generators\n+ WELL family of generators\n\n#### 问题\n通常来说，伪随机数生成器可能会有以下问题：  \n+ 在某些种子的情况下，其生成的随机数序列的周期会比较小。\n+ 生成大数时，分配的不均匀。\n+ 连续值之间关联密切，知道后续值，可以知道之前的值。\n+ 输出序列的值的大小很不均匀。\n\n### 密码安全伪随机数数生成器\n密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator，CSPRNG），也称为密码学伪随机数生成器（cryptographic pseudo-random number generator，CPRNG)，是一种特殊的伪随机数生成器。它需要满足满足一些必要的特性，以便于适合于密码学应用。\n\n密码学的很多方面都需要随机数：\n+ 密钥生成\n+ 生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式\n+ nonce，用于防止重放攻击以及分组密码的 CTR 模式等、\n+ one-time pads\n+ 某些签名方案中的盐，如 ECDSA， RSASSA-PSS\n\n注：在资讯安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。\n\n#### 需求\n毫无疑问，密码学安全伪随机数生成器的要求肯定比一般的伪随机数生成器要高。一般而言，CSPRNG 的要求可以分为两类\n\n+ 通过统计随机性测试。CSPRNG 必须通过 next-bit test，也就是说，知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于 50% 的概率预测出来下一个比特位。这里特别提及一点，姚期智曾在 1982 年证明，如果一个生成器可以通过 next-bit test，那么它也可以通过所有其他的多项式时间统计测试。\n+ 必须能够抵抗足够强的攻击，比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。\n\n#### 分类\n就目前而看， CSPRNG 的设计可以分为以下三类\n+ 基于密码学算法，如密文或者哈希值。\n+ 基于数学难题\n+ 某些特殊目的的设计\n\n### 反馈移位寄存器\n一般的，一个 n 级反馈移位寄存器如下图所示\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBc234f54efe1a0af70602bf1974c14605?method=download&shareKey=415fcf56b93e427f2b1df0417a1add43)\n+ $a_0$,$a_1$,...,$a_{n-1}$为初态。\n+ F为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。\n+ $a_{i+n}$=F($a_i$,$a_{i+1}$,...,$a_{i+n-1}$)\n\n一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即\n\n($a_i$,$a_{i+1}$,...,$a_{i+n-1}$) -> ($a_{i+1}$,..,$a_{i+n-1}$,$a_{i+n}$),对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。\n\n#### 非线性反馈寄存器\n//TODO\n\n### 特殊流密码-RC4\nRSA 由 Ron Rivest 设计，最初隶属于 RSA 安全公司，是一个专利密码产品。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。\n\nRC4 主要包含三个流程：  \n+ 初始化 S 和 T 数组。\n+ 初始化置换 S。\n+ 生成密钥流。\n\n#### 初始化 S 和 T 数组 \n```\nfor i = 0 to 255 do\n    S[i] = i\n    T[i] = K[i mod keylen])\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s_t.png)\n#### 初始化置换 S\n```\nj = 0\nfor i = 0 to 255 do \n    j = (j + S[i] + T[i]) (mod 256) \n    swap (S[i], S[j])\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s.png)\n#### 生成流密钥\n```\ni = j = 0 \nfor each message byte b\n    i = (i + 1) (mod 256)\n    j = (j + S[i]) (mod 256)\n    swap(S[i], S[j])\n    t = (S[i] + S[j]) (mod 256) \n    print S[t]\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_key.png)\n\n我们一般称前两部分为 KSA ，最后一部分是 PRGA。\n\n","tags":["现代密码学","流密码"],"categories":["密码学"]},{"title":"古典密码学基础三","url":"/2019/01/03/古典密码学基础三/","content":"\n### 培根密码\n培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。\n![image](https://note.youdao.com/yws/api/personal/file/WEB614471942b2a382c57f0cf2346e379a8?method=download&shareKey=3ce1ae584d6f0c4aaa50ad70471ac721)\n上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n\n下面这一段内容就是明文 steganography 使用\nTo encode a message each letter of the plaintext is replaced by a group of five of the letters 'A' or 'B'.\n加密后的内容，\b大写为A，小写为B。  \n|明文|s|t|e|g|a|n|o|g|r|a|p|h|y|\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\n|转换表|baaab|baaba|aabaa|aabba|aaaaa|abbaa|abbab|aabba|baaaa|aaaaa|abbba|aabbb|babba|\n|密文|tOENc|oDEaM|ESsAG|EEacH|LETTE|RofTH|EplAi|NTexT|iSREP|LACED|ByagR|OUpof|fIveL|\n\n可以看到，培根密码主要有以下特点：\n+ 只有两种字符（大小写，粗/正常题，斜/正常体等）\n+ 每一段的长度为5\n+ 加密内容会有特殊的字体之分，\b亦或大小写之分\n  \n工具：http://rumkin.com/tools/cipher/baconian.php\n\n### 栅栏密码\n栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子：  \n明文：THERE IS A CIPHER\n\n去掉空格后变为\n\n>THEREISACIPHER\n\n分成两栏，两个一组得到\n\n>TH ER EI SA CI PH ER\n\n先取出第一个字母，再取出第二个字母\n\n>TEESCPE  \nHRIAIHR\n\n连在一起就是\n\n>TEESCPEHRIAIHR\n\n上述明文也可以分为 2 栏。\n\n>THEREIS ACIPHER\n\n组合得到密文\n\n>TAHCEIRPEHIESR\n\n工具：http://ctf.ssleye.com/railfence.html\n\n### 曲路密码\n曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子：  \n>明文：The quick brown fox \njumps over the lazy dog\n\n填入 5 行 7 列表（事先约定填充的行列数）\n![image](https://note.youdao.com/yws/api/personal/file/WEBaab90fd8528f744a4b6e3ed6c78df86e?method=download&shareKey=cb2988f0247bbc4a64bb037340e21266)\n加密的回路线（事先约定填充的行列数）\n![image](https://note.youdao.com/yws/api/personal/file/WEB135692c80f25a4ec2cd7bf21aeecbdc9?method=download&shareKey=c983704ab96d9ddaadcfa3d7cf67ab6d)\n密文：gesfc inpho dtmwu qoury zejre hbxva lookT\n\n### 01248密码\n该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1->26 表示 A->Z。\n\n可以看出该密码有以下特点：\n+ 只有 0，1，2，4，8\n\n例如：8842101220480224404014224202480122\n\n按照0来分割：  \n|内容|数字|字符|\n|-|-|-|\n|88421|8+8+4+2+1=23|W|\n|122|1+2+2=5|E|\n|48|4+8=12|L|\n|2244|2+2+4+4=12|L|\n|4|4|D|\n|142242|1+4+2+2+4+2=15|0|\n|248|2+4+8=14|N|\n|122|1+2+2=5|E|\n明文：WELLDONE\n\n### JSFuck\nJSFuck 可以只用 6 个字符 []()!+ 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 alert(1) 代码如下：  \n>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]((![]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()\n\n其他一些基本的表达：\n```\nfalse       =>  ![]\ntrue        =>  !![]\nundefined   =>  [][[]]\nNaN         =>  +[![]]\n0           =>  +[]\n1           =>  +!+[]\n2           =>  !+[]+!+[]\n10          =>  [+!+[]]+[+[]]\nArray       =>  []\nNumber      =>  +[]\nString      =>  []+[]\nBoolean     =>  ![]\nFunction    =>  [][\"filter\"]\neval        =>  [][\"filter\"][\"constructor\"]( CODE )()\nwindow      =>  [][\"filter\"][\"constructor\"](\"return this\")()\n```\n工具：http://www.jsfuck.com\n\n### BrainFuck\nBrainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印 Hello World！，那么对应的程序如下：  \n```\n++++++++++[>+++++++>++++++++++>+++>+<<<<-]\n>++.>+.+++++++..+++.>++.<<+++++++++++++++.\n>.+++.------.--------.>+.>.\n```\n与其对应的还有 ook。\n\n工具：https://www.splitbrain.org/services/ook\n\n### 猪圈密码\n猪圈密码是一种以格子为基础的简单替代式密码，格子如下：  \n![image](https://note.youdao.com/yws/api/personal/file/WEB76a78a8b102de070a7fcdc8824660b2b?method=download&shareKey=71bed2948c5cec3dc77b6ce43c5967c0)\n例如：明文为 X marks the spot ，那么密文如下：  \n![image](https://note.youdao.com/yws/api/personal/file/WEB542ffbb69121a02be44c46268eae3bac?method=download&shareKey=188f938bab6d2ebea01940a2c755e75d)\n\n工具：http://www.simonsingh.net/The_Black_Chamber/pigpen.html\n\n### 舞动的小人密码 \n这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。\n![image](https://note.youdao.com/yws/api/personal/file/WEB0d432b9016f9d7f01d93260b1c0124d3?method=download&shareKey=dad1725328f62432fc4eb1f48d10f5bb)\n\n### 键盘密码\n所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。\n\n#### 手机键盘密码\n手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此。\n![image](https://note.youdao.com/yws/api/personal/file/WEB35c2548fd5300110899752984fa99371?method=download&shareKey=4008d4855211fc73f4597b224067d0b6)\n关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。\n#### 电脑键盘棋盘密码\n电脑键盘棋盘加密，利用了电脑的棋盘方阵。\n![iamge](https://note.youdao.com/yws/api/personal/file/WEB2e33ea38af7f4baf490ff9f39d715c9f?method=download&shareKey=3648b73f7f64573b1a572be93c70e8fb)\n\n#### 电脑键盘坐标密码\n电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBe0e36122c77aa2b4f9082895a8d6082b?method=download&shareKey=714cffcaddd3a713461ba4e51c85d471)\n\n#### 电脑键盘QWE\n电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBd5d37d656e0d67ee4d6abf87233c61d0?method=download&shareKey=5f547f51c40690833c88da1a7f3e0077)\n\n### CTF案例\n1. 0CTF 2014 classic\n>小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb\n\n发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到 0ops 字样，猜测就是 flag 了。\n\n2. 2017 年 xman 选拔赛——一二三，木头人 \n>我数 123 木头人，再不行动就要被扣分。\n>\n>23731263111628163518122316391715262121\n>\n>密码格式 xman{flag}\n题目中有很明显的提示 123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是 1-3 范围内的，也验证了我们的猜测。于是：  \n>23-x\n>\n>73-m\n>\n>12-a\n>\n>63-n\n>\n>11-q\n\n不对呀，密码格式是 xman{，第四个字符是 {，于是看了看 { 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么 111 就是 {。然后依次往后推，发现确实可行，，最后再把 121 视为 } 即可得到 flag.\n\n>xman{hintisenough}\n","tags":["古典密码学","其他类型密码"],"categories":["密码学"]},{"title":"古典密码学基础二","url":"/2019/01/03/古典密码学基础二/","content":"### 多表代换密码\n对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。\n\n#### 维吉尼亚密码\n维吉尼亚密码是广为人知的多表替换式密码，也称为多字母替换式密码。\n\n在一个凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E……而维吉尼亚密码则是由一些偏移量不同的恺撒密码组成。\n\n为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。\n\n例如：\n\n假设明文是ATTACKATDAWN，选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：LEMONLEMONLE\n\n对于明文的第一个字母A，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母L。类似地，明文第二个字母为T，在表格中使用对应的E行进行加密，得到密文第二个字母X。以此类推，可以得到：\n\n明文：ATTACKATDAWN  \n密钥：LEMONLEMONLE  \n密文：LXFOPVEFRNHR\n\n解密的过程则与加密相反。例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母L位于A列，因而明文第一个字母为A。密钥第二个字母E对应E行字母表，而密文第二个字母X位于此行T列，因而明文第二个字母为T。以此类推便可得到明文。\n\n用数字0-25代替字母A-Z，维吉尼亚密码的加密文法可以写成同余的形式：\n\n$C_i$=$P_i$+$K_i(mod\\ 26)$\n\n解密方法则能写成：\n\n$P_i$=$C_i$-$K_i(mod\\ 26)$","tags":["古典密码学","多表代换密码"],"categories":["密码学"]},{"title":"古典密码学基础一","url":"/2019/01/03/古典密码学基础/","content":"## 简介\n古典密码学是密码学中的其中一个类型，其大部分加密方式都是利用替换式密码或移项式密码，或者两者的混合。其与历史中经常使用，但现代已经很少使用，大部分已经不再使用。在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。\n。\n\n## 密码分类\n\n### 单表代换密码\n对字母做系统的替换，直到讯息被替换为难以理解的字。\n#### 凯撒密码\n凯撒密码是广为人知的单表式替换密码，它只使用一个密码字母集。\n\n为了使用凯撒密码加密讯息，每个密码字母集中字母将会被其位置的后三个字母替代。因此字母A將会被字母D替代、字母B將会被字母E替代、字母C將会被字母F替代等，最后，X、Y和Z將分別的被替代成A、B和C。例如，\"WIKIPEDIA\"將被加密成\"ZLNLSHGLD\"。凱撒把字母向后移\"3\"位，但其他数字也是类似。\n\n根据偏移量的不同，还存在若干特定的恺撒密码名称：\n+ 偏移量为 10：Avocat （A→K）\n+ 偏移量为 13：ROT13\n+ 偏移量为 -5：Cassis （K 6）\n+ 偏移量为 -6：Cassette （K 7）\n\n另一种替换式密码是使用关键字（等同于密钥），你可以选择一个字母或片段并去除所有的空格和重复字母，接着把它当做密码字母集的开头，把去除密钥后的其他字母接续排序。例如，如果关键字是cipher，则密码字母表会是下面的情况：\n\n一般密码字母集: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\n密钥密码字母集: c i p h e r s t u v w x y z a b d f g j k l m n o q\n\n还有一种基于密钥的凯撒密码，其基本原理是利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为密钥加密明文的每一位字母。例如：  \n密文：s0a6u3u1s0bv1a  \n密钥：guangtou  \n偏移：6,20,0,13,6,19,14,20  \n明文：y0u6u3h1y0uj1u  \n\n对于不带密钥的凯撒密码来说，破解方式有两种：  \n+ 遍历 26 个偏移量，适用于普遍情况。\n+ 在密文长度足够长的时候，使用词频分析https://quipqiup.com/\n\n其中，第一种方式肯定可以得到明文，而第二种方式则不一定可以得到正确的明文。\n\n而对于基于密钥的凯撒密码来说，一般来说必须知道对应的密钥。\n\n工具：  \n一般我们有如下的工具，其中 JPK 比较通用。\n+ JPK，可解带密钥与不带密钥\n+ http://planetcalc.com/1434/\n+ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php\n\n#### 简单替换密码\n简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。 比如：  \n明文字母 : abcdefghijklmnopqrstuvwxyz  \n密钥字母 : phqgiumeaylnofdxjkrcvstzwb\na 对应 p，d 对应 h，以此类推。  \n明文：the quick brown fox jumps over the lazy dog  \n密文：cei jvaql hkdtf udz yvoxr dsik cei npbw gdm  \n而解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。\n\n由于这种加密方式导致其所有的密钥个数是26!，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。\n\n工具：http://quipqiup.com/\n\n\n### 移位式密码\n与凯撒密码类似，区别在于移位密码不仅会处理字母，还会处理数字和特殊字符，常用 ASCII 码表进行移位。其破解方法也是遍历所有的可能性来得到可能的结果。\n\n#### \b纵线式移位密码\n一个移位式密码的具体例子就是纵线式移位密码。\b\b先\b选择一个关键字，把原来的讯息由左\b向右、由上到下依照关键字长度转写成长方形。接着把关键字的字母依照字母集顺序编号，例如a就是1，b就是2，c就是3等。例如：关键字是CAT，明文是THE SKY IS BLUE，则讯息应该被转换成：\n```   \n C A T  \n 3 1 20  \n T H E  \n S K Y  \n I S B  \n L U E  \n ```\n 最后把讯息以行为单位，依照编号大小调换位置，\b呈现的应该是 A为第一行，C为第二行，T为第三行。然后就可以把讯息转换成HKSUTSILEYBE\n\n#### 中国式密码\n 另外一种移位式密码是中国式密码，移位的方法是将讯息的字母加密成由右向左、上下交替的不规则的字母。例如，如果明文是THE DOG RAN FAR，则中国式密码看起来像这样：\n ```\n R  R   G   T\n A  A   O   H\n F  N   D   E   \n ```\n 密文将被\b是：RRGT AAOH FNDE\n\n#### \b艾特巴什码\n埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：  \n明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  \n密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A\n\b下面给出一个例子：  \n明文：the quick brown fox jumps over the lazy dog  \n密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt\n\n可以看出其密钥空间足够短，同时当密文足够长时，仍然可以采用词频分析的方法解决。\n\n工具：http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/\n\n### 仿射密码\n原理：  \n仿射密码的加密函数是 \nE(x)=(ax+b)(mod m)，其中：  \n+ x表示明文按照某种编码得到的数字\n+ a和m互质\n+ m是编码系统中字母的数目。\n\n解密函数是D(x)=$a^{-1}$(x-b)(mod m),其中$a^{-1}$是a在整数群的乘法逆元。例如：\n```   \n\b明文:A F F I N  E C I P H E R \nx:  0 5 5 8 13 4 2 8 15 7 4 17\ny=5x+8:8 33 33 48 73 28 18 48 83 43 28 93\ny mod 26:8 7 7 22 21 2 18 22 5 17 2 15 \n密文:I H H W V C S W F R C P\n```\n其对应的加密结果是 IHHWVCSWFRCP。\n\n对于解密过程，正常解密者具有 a 与 b，可以计算得到$a^{-1}$为 21，所以其解密函数是:D(x)=21(x-8)(mod 26)\n\n破解：  \n首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。\n\n其次，我们可以考虑如何攻击该密码。可以看出当a=1时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有 26 个字母，而不大于 26 的与 26 互素的个数一共有ϕ(26）=ϕ(2)Xϕ(13)=12,算上 b 的偏移可能，一共有可能的密钥空间大小也就是12×26=312 \n\n一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。\n\n这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。\n\n但是，假设我们已经知道采用的字母集，这里假设为 26 个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母$y_1$,$y_2$即可进行解密。那么我们还可以知道:  \n$y_1$=(a$x_1$+b)(mod 26)  \n$y_2$=(a$x_2$+b)(mod 26)  \n二者相减,可得：  \n$y_1$-$y_2$=a($x_1$-$x_2$)(mod 26)\n\n这里$y_1$,$y_2$已知，如果我们知道密文对应的两个不一样的字符$x_1$,$x_2$，那么我们就可以很容易得到 a，进而就可以得到 b了。\n\n ## 密码破译\n 经典密码通常很容易被破解。许多经典密码可单由密文而破解，所以它们容易遭受到唯密文攻击法攻击。有些经典密码（例如凯撒密码）的密钥个数有限，所以这类密码可以通过暴力破解尝试所有的密钥。替换式密码有较大的密钥数，但是很容易被频率分析，因为每个密码字母各代替了一个明文字母。多表式替换密码使用多个替换可防止简单的频率分析，但卡西斯基验、弗里德曼试验可用来破解这类密码。\n\n ### 卡西斯基试验\n 卡西斯基试验是基于类似the这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的CRYPTO可能被密钥ABCDEF加密成不同的密文：\n```\n密钥：ABCDEF AB CDEFA BCD EFABCDEFABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB\n```\n此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥ABCD）：\n```\n密钥：ABCDAB CD ABCDA BCD ABCDABCDABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASTP KV SIQUT GQU CSASTPIUAQJB\n```\n此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：  \n密文：**DYDUXRMH**TVDV**NQD**QNW**DYDUXRMH**ARTJGW**NQD**\n\n其中，两个DYDUXRMH的出现相隔了18个字母。因此，可以假定密钥的长度是18的约数，即长度为18、9、6、3或2。而两个NQD则相距20个字母，意味着密钥长度应为20、10、5、4或2。取两者的交集，则可以基本确定密钥长度为2。\n\n ### 弗里德曼试验\n它使用了重合指数（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。$k_p$指目标语言中两个任意字母相同的概率（英文中为0.067），$k_r$指字母表中这种情况出现的概率（英文中为1/26=0.0385），从而密钥长度可以估计为：  \n\n分子 = $k_p$-$k_r$\n\n分母 = $k_o$-$k_r$\n\n密钥长度 = $\\frac{分子}{分母}$\n\n此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。\n\n### 频率分析\n一旦能够确定密钥的长度，密文就能重新写成多列，列数与密钥长度对应。这样每一列其实就是一个凯撒密码，而此密码的密钥（偏移量）则对应于维吉尼亚密码密钥的相应字母。与破译凯撒密码类似的方法，就能将密文破译。\n\n柯克霍夫方法作为卡西斯基试验的改进，由奥古斯特·柯克霍夫（Auguste Kerckhoffs）提出。它将每一列的字母频率与转换后的明文频率相对应而得出每一列的密钥字母。一旦密钥中每一个字母都能确定，就能很简单地破译密文，从而得到明文。如果维吉尼亚字母表表格本身是杂乱而非按通常字母表顺序的话，那柯克霍夫方法就会无效，但卡西斯基试验和重复指数对于决定密钥长度仍旧是有效的。","tags":["古典密码学","单表代换密码"],"categories":["密码学"]},{"title":"Android编译器相关","url":"/2019/01/02/Android编译器相关/","content":"MIR -> LIR -> native code\n\nSSA：（编译器后端寄存器分配算法，static single assignment）静态单一复制法，是一种中间表示形式。\n之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。\n\n在某种程度上，可以认为MIR即为对dalvik指令进行SSA变换之后的指令形态。\n\n接着就调用cu.cg->Materialize()用来产生最终代码，其中重要的两个调用就是MethodMIR2LIR()和AssembleLIR()。\n通MethodMIR2LIR()将MIR转化为LIR，遍历每个BasicBlock，对每个基本块执行MethodBlockCodeGen，\n本质上最后是执行了CompileDalvikInstruction。CompileDalvikInstruction也就是通过解析指令，然后根据opcode进行分支判断，\n调用最终不同的指令生成函数，最后LIR之间也形成一个双向链表。最终将MIR转换为LIR。\n\nAssembleLIR()最终调用的是AssembleInstructions函数。程序中维护了一个编码指令表MipsMir2Lir::EncodingMap，\nAssembleInstructions即是通过查找这个表来进行翻译，将LIR转化为了MIPS指令，\n并将所翻译的指令存储到CodeBufferMir2Lir::code_buffer_之中。\n这样就完成了一次编译的完整流程。\n\n总结：\nMIR为对dalvik指令进行SSA变换之后的指令形态。\nLIR为对MIR形态的指令进行解析生成的另一种形态的指令。\nnative code为通过查找编码指令表将LIR形态的指令翻译为对应不同平台的汇编指令。","tags":["Android、compiler"]},{"title":"Android 逐步认识ART系列二","url":"/2018/12/28/Android-逐步认识ART系列二/","content":"\n# boot.oat\n\n- Contains libs and frameworks in boot class path\n    – To be pre-loaded in all apps（系统启动路径下的的需要预加载库和框架）\n\n任何应用程序都不是孤立存在的，几乎所有应用程序都会依赖Android Framework中提供的基础类，例如Activity，Intent，Parcel等类。所以在应用程序的代码中，自然少不了对于这些类的引用.\n\n考虑到几乎所有应用都存在这种引用关系，在运行时都会依赖于Framework中的类，因此系统如何处理这部分逻辑就是非常重要的了，因为这个处理的方法将影响到所有应用程序。\n\n在AOSP编译时，会将所有这些公共类放到专门的一个Oat文件中，这个文件就是：boot.oat。与之配合的还有一个boot.art文件。\n\nboot.oat可以在两个地方找到：\n1. /system/framework/[platform]/boot.oat\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     50767704 2014-11-20 19:07 boot.oat\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.oat\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     51003824 1970-05-29 01:45 system@framework@boot.oat\n```\n\n```\n/system/bin/dex2oat --image=/data/dalvik-cache/system@framework@boot.art --runtime-arg\n-Xms64m --runtime-arg -Xmx64m --dex-file=/system/framework/core-libart.jar --dex-file=/\nsystem/framework/conscrypt.jar --dex-file=/system/framework/okhttp.jar --dex-file=/\nsystem/framework/core-junit.jar --dex-file=/system/framework/bouncycastle.jar --dexfile=/system/framework/ext.jar --dex-file=/system/framework/framework.jar --dex-file=/\nsystem/framework/framework2.jar --dex-file=/system/framework/telephony-common.jar --\ndex-file=/system/framework/voip-common.jar --dex-file=/system/framework/mms-common.jar\n--dex-file=/system/framework/android.policy.jar --dex-file=/system/framework/\nservices.jar --dex-file=/system/framework/apache-xml.jar --dex-file=/system/framework/\nwebviewchromium.jar --oat-file=/data/dalvik-cache/system@framework@boot.oat --runtimearg -implicit-checks:none --instruction-set=arm --instruction-set-features=default --\nbase=0x70000000 --image-classes-zip=/system/framework/framework.jar\n```\n**上面命令编译进boot.oat中的jar:**   \n/system/framework/core-libart.jar  \n/system/framework/conscrypt.jar  \n/system/framework/okhQp.jar  \n/system/framework/core-junit.jar  \n/system/framework/bouncycastle.jar  \n/system/framework/ext.jar  \n/system/framework/framework.jar  \n/system/framework/framework2.jar  \n/system/framework/telephony-common.jar  \n/system/framework/voip-common.jar  \n/system/framework/mms-common.jar  \n/system/framework/android.policy.jar  \n/system/framework/services.jar  \n/system/framework/apache-xml.jar  \n/system/framework/webviewchromium.jar  \n\n# boot.art(boot image)\n- contains absolute pointers for methods in boot.oat(以绝对地址指向boot.oat中的方法)\n- boot.art和boot.oat的加载地址都是32位，在64位的系统上，高32位都是0\n\nboot.art中包含了指向boot.oat中方法代码的指针，它被称之为启动镜像（Boot Image），并且被加载的位置是固定的。boot.oat被加载的地址紧随着boot.art。\n\nboot.art可以在两个地方找到：\n1. /system/framework/[platform]/boot.art\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     11829248 2014-11-20 19:07 boot.art\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.art\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     11829248 1970-05-29 01:45 system@framework@boot.art\n```\n\n# Profiling\n- By default,ART compiles methods regardless of impact on performance(ART编译方法时，不会考虑对性能的影响)\n- Profiling feature allows ART to be more selective on which methods to compile(profile能够\b控制dex2oat具体要对哪些方法进行编译优化)\n- Profiling配置默认可能是关闭的。可以通过setprop手动打开\n\n```\nsetprop dalvik.vm.profiler 1\n```\n\n\b- No AOT compilation upon app install(在App安装时不会进行AOT优化，一方面时为了减少安装时间、另一方面时节省\b存储空间)\n- Profiling data is collected while app is runing(在App运行期间，会收集profile数据)\n- Profile files are placed in /data/dalvik-cache/profiles\n- Profile file name is the package name\n- Profile data is used to determine if AOT compilation will be done\n\nexample:\n```\n42/2/352  \nandroid.database.Cursor com.android.email.provider.EmailProvider.uiAccounts(java.lang.String[])/1/128  \nvoid com.android.email.NotificationController.ensureHandlerExists()/1/37\nint com.android.email.provider.EmailProvider.getFolderTypeFromMailboxType(int)/2/56\nboolean com.android.mail.browse.ConversationCursor$ConversationProvider.onCreate()/1/49\ncom.google.common.collect.ImmutableList com.google.common.collect.ImmutableList.of()/1/3\n<snip>\n```\n\n- First line is the summary inforamtion\n  > count/Null methods count/Boot path methods count\n- Subsequent lines are the profile data\n  > Methods name/Count/Size\n\n# App Image\n\n* /data/app/xxx/oat/arm/base.art\n* /data/app/xxx/oat/rm/base.odex\n\nbase.art 就是对应的App image文件。主要记录已经编译好的类的具体信息以及函数在oat文件的位置，相当于缓存，在app运行的时候会加载到虚拟机，可以加快启动速度。\n\n**在Android7.0上，dex2oat的参数 compiler-filter被指定为profile类型的几个compiler-filter之一时，dex2oat还会生成app-image文件。**\n","tags":["ART、boot.oat、boot.art、Profile"]},{"title":"Android 逐步认识ART系列一","url":"/2018/12/27/Android-逐步认识ART系列一/","content":"\n参考资料：  \n原文：https://blog.csdn.net/hl09083253cy/article/details/78418809   \n原文：https://paul.pub/android-art-vm/#id-art-vs-dalvik  \nAndroid Source：https://source.android.com.devices/tech/dalvik/configure  \n\n# JIT\n我们知道，C/C++的效率要比 Java好，因为C/C++会被直接编译成汇编指令，CPU可以直接读取运行；而Java却是需要虚拟机一步一步的解释每一条 java bytecode。\n\n而Dalvik 中使用了一个技术，叫做JIT，会在解释执行一个java方法或者一个java代码段时，进行trace，并在不断的执行过程中找到 hotspot，\n\n然后将相应的方法或者代码片段编译为对应的汇编指令，下次再执行到该方法时，会直接执行其对应的汇编指令，依次来提升部分效率。\n\n可以理解为：运行时追踪，并对hotspot进行编译生成高效的可执行指令。\n\nJIT的运行流程\n\n1. 用户运行应用，而这随后就会触发 ART 加载 .dex 文件。\n   1. 如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 .oat 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。\n   2. 如果没有 .oat 文件，则 ART 会通过 JIT 或解释器执行 .dex 文件。如果有 .oat 文件，ART 将一律使用这类文件。否则，它将在内存中使用并解压 APK 文件，从而得到 .dex 文件，但是这会导致消耗大量内存（相当于 dex 文件的大小）。\n2. 针对任何未根据speed编译过滤器编译（见下文）的应用启用JIT（也就是说，要尽可能多地编译应用中的代码）。\n3. 将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。\n4. AOT 编译 dex2oat 守护进程通过解析该文件来推进其编译。\n\n要开启 JIT 日志记录，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.extra-opts -verbose:jit\nadb shell start\n```\n要停用 JIT，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.usejit false\nadb shell start\n```\n\n# AOT\n\nAhead-of-time（AOT）是相对于Just-in-time（JIT）而言的。JIT是在运行时进行字节码到本地机器码的编译，这也是为什么Java普遍被认为效率比C++差的原因。无论是解释器的解释还是运行过程中即时编译，都比C++编译出的本地机器码执行多了一个耗费时间的过程。而AOT就是向C++编译过程靠拢的一项技术：当APK在安装的时候，系统会通过一个名称为dex2oat的工具将APK中的dex文件编译成包含本地机器码的oat文件存放下来。这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。\n\n# 单纯的JIT存在的问题\n1. 执行效率差\n\n# 单纯的AOT存在的问题\n1. 应用安装时间长\n2. 系统更新后，要重新编译所有应用\n3. 浪费存储空间（为所有方法执行编译）\n\n# AOT+JIT\n\n从Android 7.0（代号Nougat,简称N）开始，ART组合使用了AOT、JIT和配置文件引导型编译。所有这些编译模式的组合均可配置。例如，在Pixel设备上，相应的配置如下：\n\n1. 最初在安装应用程序的时候不执行任何AOT编译。应用程序运行的前几次都将使用解释模式，**并且经常执行的方法将被JIT编译**。\n2. **当设备处于空闲状态并正在充电时**，编译守护进程会根据第一次运行期间生成的Profile文件对**常用代码**运行AOT编译。\n3. 应用程序的**下一次重新启动将使用Profile文件引导的代码**，并**避免在运行时为已编译的方法进行JIT编译**。在**新运行期间得到JIT编译的方法将被添加到Profile文件中**，然后被编译守护进程使用。\n\nART包含一个编译器（dex2oat工具）和一个为启动zygote而加载的运行时（libart.so）。在应用程序安装时，APK文件会传递给dex2oat工具，该工具会为根据APK文件生成一个或多个编译产物，这些产物文件名和扩展名可能会在不同版本之间发生变化，但从Android 8.0版本开始，生成的文件是：\n\n- .vdex：包含APK的未压缩Dex代码，以及一些额外的元数据用来加速验证。\n- .odex：包含APK中方法的AOT编译代码。（注意，虽然Dalvik虚拟机时代也会生成odex文件，但和这里的odex文件仅仅是后缀一样，文件内容已经完全不同了）\n- .art（可选）：包含APK中列出的一些字符串和类的ART内部表示，用于加速应用程序的启动    \n\n# 编译选项\n\nART的编译选项分为以下两个类别：\n1. 系统ROM配置：编译系统映像时，会对哪些代码进行AOT编译。\n2. 运行时配置：ART如何在设备上编译和运行应用。\n\n用于配置这两个类别的一个核心ART选项就是”编译过滤器“，编译过滤器可控制ART如何编译DEX代码，是一个传递给dex2oat工具的选项。从Android 8.0开始，有四个官方支持的过滤器：\n   1. verify：只运行DEX代码验证\n   2. quicken：运行DEX代码验证，并优化一些DEX指令，以获得更好的解释器性能。\n   3. speed：运行DEX代码验证，并对所有方法进行AOT编译。\n   4. speed-profile：运行DEX代码验证，并对配置文件中列出的方法进行AOT编译\n\n ## 系统ROM配置\n 有一些编译选项可用于配置系统ROM，如何配置这些选项取决于/system的可用存储空间以及预先安装的应用数量。编译到系统AROM中的JAR/APK可以分为以下四个类别：\n    1. 启动类路径代码：默认使用speed编译过滤器进行编译 \n    2. 系统服务代码：默认使用speed编译过滤器进行编译\n    3. 产品专属的核心应用：默认使用speed编译过滤器进行编译\n    4. 所有其他应用：默认使用quicken编译过滤器进行编译\n\n\n","tags":["ART，OAT，JIT"]},{"title":"Android-逐步认识ART系列三","url":"/2018/12/26/dex2oat源码分析/","content":"dex2oat是将dex文件编译成Oat文件的工具，位于/system/bin/dex2oat\n\ndex2oat生成的oat文件位于设备上/data/dalvik-cache/目录下,同时，由于32位和64位的机器码有所区别，因此这个目录下还会通过子文件夹对oat文件进行分类。例如，手机上通常会有下面两个目录：  \n* /data/dalvik-cache/arm/  \n* /data/dalvik-cache/arm64/\n\n# dex2oat：\n* Retrieve classes.dex from APK (从apk中检索classes.dex)\n* verify each class（验证每个类）\n* verify each method（验证每个方法）\n* verify each dalvik instruction（验证每条dalvik指令）\n\n# dex2oat编译过程\n依次编译输入参数中的所有dex文件;  每个dex文件又按照单个class进行编译; 对于每个class，依次编译其除abstract函数、\\<cinit>之外的所有函数，包括 native（jni）/static/及一般函数，进行生成native code，并存放在compiler中。\n\n当编译完成后，会从compiler中把native code， dex文件，以及必要的组织信息，写入到OAT文件中；如果指定了生成app-image，还会再生成一份 app-image文件。\n\n# dex2oat的触发时机\ndex2oat进程的启动，可以分为两大类：一类是 installd进程触发的dex2oat；另一类是由 app中直接调用的dex2oat。\n\n ## installd中触发dex2oat有以下几个场景：\n    1. 应用安装，包括普通安装和通过shellCmd安装），安装一个app时，安装过程中需要编译dex文件，会通知installd来触发一个dex2oat进程。\n    2. 开机扫描，开机过程中，PMS扫描已安装app过程，判断需要优化时，则会对install发出通知。\n    3. BackgroundDexOptService，（空闲时段或者开机之后触发的Backgroud的 Job），会通知installd进行dex2oat\n    4. OTADexoptService，好象是OAT过程中的触发的，这个场景没有进行过实际的验证\n\n ## app中调用dex2oat\n一般是App的进程fork出一个子进程，子进程用来执行dex2oat，编译相关的dex，而父进程进行 waitpid 等待，等待完成后再运行其他逻辑。  \n例如：  \n 1. 微信安装后的首次启动，是有dex2oat的调用\n 2. 淘宝安装后的首次搜索，也有dex2oat的调用\n\n这个也是其首次启动或者搜索的一个耗时点。\n\n 由系统触发的dex2oat，都是通过通知installd来进行编译业务。\n\n 由应用触发的dex2oat，一般都是自行构建参数，直接调用dex2oat。\n\n\n# compiler-backend 类型\n\n* Portable\n* Quick\n* Optimizing\n\n ## Quick Backend\n\n > MIR -> LIR -> Native Code\n\n * Medium level IR(DEX ByteCode)\n * Low level IR\n * Native Code\n * some optimizations at each stage\n\n ## Optimizing Backend\n\n * Basically Quick with additional optimizations\n\n ## Portable Backend\n\n > MIR -> LLVM Bitcode -> LLVM optimizer -> LLVM Backend -> native code\n\n * Uses LLVM Bitcode as its LIR\n * Optimizations using LLVM optimizer\n * Code generation is done by LLVM backends\n\n\n# \b编译优化条件和对象（没太搞明白的地方）\n\n ## 什么情况下App需要使用dex2oat进行编译优化?\n * Number of methods comprising 90% of called methods has changed by > 10%.(被调用方法的比例若大于10%，则会触发dex2oat编译优化)\n\n ## \b若要使用dex2oat,哪些方法会被dex2oat考虑进去？\n * Methods comprising 90% of called methods.()\n\n# dex2oat命令行参数\n\nexample:\n```\n/system/bin/dex2oat --zip-fd=6 --zip-location=/system/app/\nEmail.apk --oat-fd=7 --oat-location=/data/dalvik-cache/\nsystem@app@Email.apk@classes.dex --profile-file=/data/\ndalvik-cache/profiles/com.android.email\n```\n参数说明：  \n--zip-fd=\\<file-descriptor>:包含classes.dex文件的zip文件描述符。  \n--oat-fd=\\<number>:\b通过此文件描述符指定输出的oat文件的路径。  \n--oat-location=\\<oat-name>:指定一个与--oat-fd指定的文件描述符相对应的象征性名字。  \n--profile-file：引导dex2oat编译优化的配置文件。文件位置：/data/dalvik-cache/profiles/应用包名\n\n其他重要参数说明(参考android7.0.0源码)：  \n-j\\<number>:指定进行\b编译优化时要用到的线程总数。默认根据硬件适配，例如：-j12  \n--dex-file=\\<dex-file>:指定要编译的文件，后缀可以是.dex、.jar、.apk，\b例如：--dex-file=/system/framework/core.jar  \n--dex-location=\\<dex-location>:dex文件路径,与--dex-file相对应，例如：--dex-file=/home/build//out/system/framework/core.jar;--dex-location=/system/framework/core.jar。    \n--zip-location=\\<zip-location>:zip文件路径。例如：--zip-location=/system/app/Calculator.apk   \n--oat-file=\\<file.oat>:输出的oat文件名。例如：--oat-file=/system/framework/boot.oat。  \n--oat-symbols=\\<file.oat>:指定输出完整符号的oat路径。例如：--oat-symbols=/symbols/system/framework/boo.art。  \n--instruction-set=(arm|arm64|mips|mips64|x86|x86_64):指定指令集架构类型，默认为arm。  \n--compile-backend=(Quick|Optimizing):指定编译器后端。默认为Optimizing。  \n--compiler-filter=(verify-none|verify-at-runtime|verify-profile|interpret-only|time|space-profile|space|balanced|speed-profile|speed|everything-profile|everything):指定编译器过滤模式，默认为speed。\n\n# dex2oat主要流程\n\nmain函数入口：\n```\nint main(int argc, char** argv) {\n  int result = art::dex2oat(argc, argv);\n  // Everything was done, do an explicit exit here to avoid running Runtime destructors that take\n  // time (bug 10645725) unless we're a debug build or running on valgrind. Note: The Dex2Oat class\n  // should not destruct the runtime in this case.\n  if (!art::kIsDebugBuild && (RUNNING_ON_MEMORY_TOOL == 0)) {\n    exit(result);\n  }\n  return result;\n}\n```\ndex2oat函数入口：\n```\nstatic int dex2oat(int argc, char** argv) {\n  b13564922();\n    \n  TimingLogger timings(\"compiler\", false, false);\n\n  // Allocate `dex2oat` on the heap instead of on the stack, as Clang\n  // might produce a stack frame too large for this function or for\n  // functions inlining it (such as main), that would not fit the\n  // requirements of the `-Wframe-larger-than` option.\n  std::unique_ptr<Dex2Oat> dex2oat = MakeUnique<Dex2Oat>(&timings);\n\n  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.\n  dex2oat->ParseArgs(argc, argv);\n\n  // If needed, process profile information for profile guided compilation.\n  // This operation involves I/O.\n  if (dex2oat->UseProfileGuidedCompilation()) {\n    if (!dex2oat->LoadProfile()) {\n      LOG(ERROR) << \"Failed to process profile file\";\n      return EXIT_FAILURE;\n    }\n  }\n\n  // Check early that the result of compilation can be written\n  if (!dex2oat->OpenFile()) {\n    return EXIT_FAILURE;\n  }\n\n  // Print the complete line when any of the following is true:\n  //   1) Debug build\n  //   2) Compiling an image\n  //   3) Compiling with --host\n  //   4) Compiling on the host (not a target build)\n  // Otherwise, print a stripped command line.\n  if (kIsDebugBuild || dex2oat->IsBootImage() || dex2oat->IsHost() || !kIsTargetBuild) {\n    LOG(INFO) << CommandLine();\n  } else {\n    LOG(INFO) << StrippedCommandLine();\n  }\n\n  if (!dex2oat->Setup()) {\n    dex2oat->EraseOatFiles();\n    return EXIT_FAILURE;\n  }\n\n  bool result;\n  if (dex2oat->IsImage()) {//App Image 或者Boot Image\n    result = CompileImage(*dex2oat);\n  } else {\n    result = CompileApp(*dex2oat);\n  }\n\n  dex2oat->Shutdown();\n  return result;\n}\n}\n```\n\n> 当使用profile-guide 编译app时，会先 LoadProfile(),进行解析出 class index 和 method index，放到 ProfileCompilationinfo 中;\n> 如果当前的编译要生成 image时，走CompileImage流程，否则走CompileApp流程;\n\n不论是编译image还是App都会包含以下一个工作：\n```\ndex2oat.Compile();//核心\n\ndex2oat.WriteOatFiles();//嵌入ELF\n\ndex2oat.FlushCloseOatFiles();\n\n dex2oat.DumpTiming()\n```\n\nCompileApp和CompileImage的区别是：\n\n 1. 编译image时需要 LoadClassProfileDescriptors() 产生 image_classes_ 集合，和生成 image（HandleImage()）;\n 2. 在生成的app image中将会包含 image_classes_ 集合中类的对象，不在 image_classes_集合中的app的类的对象，将不会被生成到 app-image中。\n 3. LoadClassProfileDescriptors（）在从 profile信息中获取 image_classes_集合时，将会把 app dex 中的类以外的类，都过滤掉，比如 classpath dex 对应的类将不会生成到 app-image;\n\ndex2oat工作流程总结：\n 1. 根据dex2oat接收到的参数，组织编译参数\n 2. 如果是 profile-guide 编译，则先进行 load app对应的 profile\n 3. 收集参数中包含的所有dex file，启动 Compiler 编译这些dex file（classpath中对应的dex file，即uses-library 引用的jar文件，不会被编译），编译生成的数据放在compiler-driver中\n 4. 使用 compiler-driver 中的数据，依据 oat文件设计的格式，组织成oat文件，嵌入到 ELF文件中\n 5. 如果指定需要生成 app-image，则使用 HandleImage()， 生成app-image， 即 ***.art 文件\n\n## 编译流程\b\n","tags":["Android、dex2oat"]},{"title":"Android 部分系统版本变更行为","url":"/2018/12/26/Android-部分系统版本变更行为/","content":"**主要关注安全方面**\n# Android 6.0部分变更行为：\n\n* 运行时权限\n\n此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。\n\n* 低电耗模式和应用待机模式\n\n此版本引入了针对空闲设备和应用的最新节能优化技术。\n  * 低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。\n  * 应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。\n\n\n* 取消支持 Apache HTTP 客户端\n\nAndroid 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：\n```\nandroid {\n    useLibrary 'org.apache.http.legacy'\n}\n```\n\n* Boring SSL\n\nAndroid 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。\n* 运行时\n\nART 运行时环境现在可正确实现 newInstance() 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 setAccessible() 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。\n\n此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。\n\n现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。\n\n在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。\n\n* APK验证\n\n该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。\n\n# Android 7.0部分变更行为：\n* 配置文件指导的 JIT/AOT 编译\n\n在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。\n\n配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。\n\n除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。\n\nAndroid 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。\n* 快速的应用安装路径\n\nAndroid 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤\n\n**关于JIT的回归**\n\n在Android 5.0上，系统在安装APK时会直接将dex文件中的代码编译成机器码。编译一个应用就已经很耗时，若编译所有应用，等待时间将会使人难以忍受。\n\n例如：  \n应用程序编译生成的OAT文件会引用Framework中的代码。一旦系统发生升级，Framework中的实现发生变化，就需要重新修正所有应用程序的OAT文件，使得它们的引用是正确的，这就需要重新编译所有的应用。\n\n由此可以看到单纯的AOT编译会存在以下问题：\n* 应用安装时间过长。\n* 系统每次更新都要重新编译所有应用。\n* 编译生成的Oat文件中，既包含了原先的Dex文件，又包含了编译后的机器代码。而实际上，对于用户来说，并非会用到应用程序中的所有功能，因此很多时候编译生成的机器码是一直用不到的。一份数据存在两份结果（尽管它们的格式是不一样的）显然是一种存储空间的浪费。\n  \n因此，为了解决上述问题，Android 7.0(代号Nougat,简称N)中添加了JIT编译器和配置文件引导型编译。JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。\n\nJIT编译器补充了ART当前的预先AOT编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT编译器，JIT编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 OTA 更新期间）时拖慢系统速度。\n\n尽管JIT和AOT使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 OnStackReplacement 编译成为可能，而这一切都会使其生成的代码略有不同。\n","tags":["Android，版本变化"]},{"title":"Android系统版本分布","url":"/2018/12/26/Android系统版本分布/","content":"\nAndroid 信息中心：https://developer.android.com/about/dashboards/?hl=zh-cn\n\nAndroid各个系统版本市场占有率表：\n![image](https://note.youdao.com/yws/api/personal/file/WEB9c984ab2b3606d4f688dee72ff7fb30f?method=download&shareKey=288a168344f4c3da4e4930c699d19ee2)\nAndroid各个系统版本市场占有率图：\n![image](https://note.youdao.com/yws/api/personal/file/WEB75a72b0c1a2257ce5215bc18bb38a8d4?method=download&shareKey=cc627bcace397474e82ad2ad8355057c)\n\n总结，由上表和上图可知：\n+ Android6.0、Android7.0,7.1、Android8.0,8.1占据了3/4的Android市场。\n+ 单个系统版本市场占有率最高的为Android 6.0，即API 23 \n+ 复合系统\b版本市场占有率最高的为Android 7.0系列，其中7.0为18.1%，7.1为10.1%\n+ \n","tags":["Android"]},{"title":"Java 打印堆栈信息","url":"/2018/12/26/Java-打印堆栈信息/","content":"#java打印堆栈信息\n\n+ 在函数内部打印函数调用堆栈\n```\nLog.d(TAG,Log.getStackTraceString(new Throwable()));\n```\n+ 出异常时打印当前堆栈\n```\ntry{\n\n}\ncatch(Exception e){\n    e.printStackTrace();\n}\n```\n+ 使用StackTraceElement[]打印\n```\nThrowable ex = new Throwable();\nStackTraceElement[] stackElements = ex.getStackTrace();\nif (stackElements != null) {\n    for (int i = 0; i < stackElements.length; i++) {\n        System.out.print(stackElements[i].getClassName()+\"/t\");\n        System.out.print(stackElements[i].getFileName()+\"/t\");\n        System.out.print(stackElements[i].getLineNumber()+\"/t\");\n        System.out.println(stackElements[i].getMethodName());\n        System.out.println(\"-----------------------------------\");\n    }\n}\n```\n+ 使用Thread打印\n```\nThread.currentThread().getStackTrace()\n```\n+ 使用exception打印\n```\nException e = new Exception(\"this is a log\");\ne.printStackTrace();\n```","tags":["Java，堆栈"]},{"title":"Android Oat文件分析","url":"/2018/12/26/Oat文件分析/","content":"\n.oatdata -> .rodata(oatHeader、dex文件相关信息、dex原始文件、类中方法与翻译为native code的对应关系)\n.oatexec -> .text(native code)\n\nOat文件结构概览：\n\n![avatar](https://note.youdao.com/yws/api/personal/file/WEBd91be5da5cc9c70b50ac5355d12d6e84?method=download&shareKey=cfbfd9c6f94f41b648fc4d3b4ebacadb)\n# elf文件结构(32位)：\n```\ntypedef uint16_t Elf32_Half; //2 bytes\ntypedef uint32_t Elf32_Word; //4 bytes\ntypedef uint32_t Elf32_Addr; //4 bytes\ntypedef uint32_t Elf32_Off;  //4 bytes\ntypedef int32_t  Elf32_Sword;//4 bytes\n```\n```\n// Object file magic string.\nstatic const char ElfMagic[] = { 0x7f, 'E', 'L', 'F', '\\0' }\n```\n```\n// e_ident size and indices.\nenum {\n  EI_MAG0       = 0,          // File identification index.\n  EI_MAG1       = 1,          // File identification index.\n  EI_MAG2       = 2,          // File identification index.\n  EI_MAG3       = 3,          // File identification index.\n  EI_CLASS      = 4          ,// File class.\n  EI_DATA       = 5,          // Data encoding.\n  EI_VERSION    = 6,          // File version.\n  EI_OSABI      = 7,          // OS/ABI identification.\n  EI_ABIVERSION = 8,          // ABI version.\n  EI_PAD        = 9,          // Start of padding bytes.\n  EI_NIDENT     = 16          // Number of bytes in e_ident.\n};\n```\nelf文件头结构：（16+4+20+12=52字节，1+2+5+6=14项）\n```\nstruct Elf32_Ehdr{\n    unsigned char e_ident[EI_NIDENT];//ELF文件魔数          16字节\n    Elf32_Half  e_type;              //ELF文件类型（32/64位）2字节  2*2\n    Elf32_Half  e_machine;           //该ELF文件所需要的架构  2字节\n    Elf32_Word  e_version;           //ELF文件版本（始终为1） 4字节   4*5\n    Elf32_Addr  e_entry;             //程序入口地址          4字节\n    Elf32_Off   e_phoff;             //segment表偏移地址     4字节\n    Elf32_Off   e_shoff;             //section表偏移地址     4字节\n    Elf32_Word  e_flags;             //标志                 4字节\n    Elf32_Half  e_ehsize;            //ELF文件头大小         2字节   2*6\n    Elf32_Half  e_phentsize;        //segment表项大小        2字节\n    Elf32_Half  e_phnum;            //segment表项数目        2字节\n    Elf32_Half  e_shentsize;        //section表项大小        2字节  \n    Elf32_Half  e_shnum;            //section表项数目        2字节\n    Elf32_Half  e_shstrndx;         //段表字符串表在section表中的下标 2字节\n};\n```\n```\n// File types\nenum {\n  ET_NONE   = 0,      // No file type\n  ET_REL    = 1,      // Relocatable file\n  ET_EXEC   = 2,      // Executable file\n  ET_DYN    = 3,      // Shared object file\n  ET_CORE   = 4,      // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n```\n```\n// Machine architectures\nenum {\n    EM_NONE = 0, // No machine\n    EM_ARM  = 40 // ARM\n    ...\n};\n```\n案例分析①：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n>7F 45 4C 46 01 01 01 03 00 00 00 00 00 00 00 00\n03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00\n70 50 48 00 00 00 00 05 34 00 20 00 05 00 28 00\n08 00 07 00\n\n魔数：7F 45 4C 46 //0x464c457f  \n位宽：01 //0x01代表32位；0x02代表64位    \n端序：01 //0x01代表小端；0x02代表打断    \n版本：01   \n操作系统：03 //0x03代表Linux  \n00 00 00 00 00 00 00 00   \n文件类型：03 00  //0x03:共享文件    \n芯片架构：28 00 // 0x28 ARM架构   \n文件版本：01 00 00 00 //0x01 (始终为1)    \n程序入口地址：00 00 00 00 //0x0   \nsegment表偏移：34 00 00 00 //0x34   \nsection表偏移：70 50 48 00 //0x485070   \n标志：00 00 00 05   //0x5000000   \n文件头大小：34 00   //0x34    \nsegment表项大小：20 00  //0x20    \nsegment表项数目：05 00  //0x05    \nsection表项大小：28 00  //0x28    \nsection表项数目：08 00  //0x08    \n段表字符串表在段表中下标：07 00 //0x07\n\n----\n\nsegment头结构：（8项，每项4个字节，32字节）\n```\nstruct Elf32_Phdr{\n    Elf32_Word  p_type;//segment类型\n    Elf32_Off   p_offset;//segment相对文件开始的偏移\n    Elf32_Addr  p_vaddr;//segment映射到内存中的首字节地址（即虚拟地址）\n    Elf32_Addr  p_paddr;//在物理地址定位有关的系统中，该字段是为该段的物理地址而保留的，对于可执行文件和共享的object而言是未指定内容的。\n    Elf32_Word  p_filesz;//在文件映像中该segment的字节数（可能是0）\n    Elf32_Word  p_memsz;//在内存映像中该segment的字节数（可能是0）\n    Elf32_Word  p_flags;//segment标志\n    Elf32_Word  p_align;//可载入的进程段必须有合适的p_vaddr、p_offset值，取页面大小的模。该字段给出了该段在内存和文件中排列值。0和1表示不需要排列。否则，p_align必须为正的2的幂\n};\n```\n```\n// Segment types.\nenum {\n    PT_NULL    = 0, // Unused segment.空值\n    PT_LOAD    = 1, // Loadable segment.加载到内存中\n    PT_DYNAMIC = 2, // Dynamic linking information.动态链接\n    PT_INTERP  = 3, // Interpreter pathname.动态链接的辅助信息\n    PT_NOTE    = 4, // Auxiliary information.其他信息\n    PT_SHLIB   = 5, // Reserved.RFU\n    PT_PHDR    = 6, // The program header table itself.segment表头的位置和大小\n    PT_TLS     = 7, // The thread-local storage template.\n    ...\n};\n```\n案例分析②：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n由ELF文件头知：segment表偏移为0x34;表大小为0x05;表项大小为0x20;推出segment头表大小为：0x05*0x20=0xa0 \n\n>06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00 //PT_PHDR  \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 //PT_LOAD   \n00 10 2A 00 00 10 2A 00 04 00 00 00 00 10 00 00   \n01 00 00 00 00 10 2A 00 00 10 2A 00 00 10 2A 00 //PT_LOAD   \n48 35 1E 00 48 35 1E 00 05 00 00 00 00 10 00 00   \n01 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_LOAD   \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n02 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_DYNAMIC    \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n\n第一个segment头：   \n06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00   \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \nsegment类型：06 00 00 00    //PT_PHDR(程序头表自身)   \nsegment文件偏移：34 00 00 00    \nsegment虚拟地址：34 00 00 00    \nsegment物理地址：34 00 00 00    \n文件映像中该segment字节数：A0 00 00 00    \n内存映像中该segment字节数：A0 00 00 00    \nsegment标志：04 00 00 00    \nsegment对齐：04 00 00 00\n\n其他segment头:    \n省略...\n\nsection头结构：（10项，每项4个字节，40字节）\n```\nstruct Elf32__Shdr{\n  Elf32_Word sh_name;      // Section name (index into string table), section名字，string table的索引\n  Elf32_Word sh_type;      // Section type (SHT_*),section的类型\n  Elf32_Word sh_flags;     // Section flags (SHF_*),section标记，用来描述多个属性\n  Elf32_Addr sh_addr;      // Address where section is to be loaded,若该section被加载到内存中，该字段表示其在内存中的位置\n  Elf32_Off  sh_offset;    // File offset of section data, in bytes,该section在文件中的偏移，SHT_NOBITS类型的section在文件中不占用空间，概念上的位置\n  Elf32_Word sh_size;      // Size of section, in bytes,section大小，SHT_NOBITS类型的section该值可能为非0，但是不占文件空间\n  Elf32_Word sh_link;      // Section type-specific header table index link,到section头表的链接\n  Elf32_Word sh_info;      // Section type-specific extra information,额外信息\n  Elf32_Word sh_addralign; // Section address alignment,地址对齐\n  Elf32_Word sh_entsize;   // Size of records contained within the section,一些sections保留着一张固定大小入口的表，对于此类型的section，该字段给除了每个入口的字节大小\n};\n```\n```\n// Section types.\nenum {\n    SHT_NULL          = 0,  // No associated section (inactive entry).\n    SHT_PROGBITS      = 1,  // Program-defined contents.\n    SHT_SYMTAB        = 2,  // Symbol table. 符号表\n    SHT_STRTAB        = 3,  // String table. 字符串表\n    SHT_RELA          = 4,  // Relocation entries; explicit addends.\n    SHT_HASH          = 5,  // Symbol hash table.\n    SHT_DYNAMIC       = 6,  // Information for dynamic linking.\n    SHT_NOTE          = 7,  // Information about the file.\n    SHT_NOBITS        = 8,  // Data occupies no space in the file.\n    SHT_REL           = 9,  // Relocation entries; no explicit addends.\n    SHT_SHLIB         = 10, // Reserved.\n    SHT_DYNSYM        = 11, // Symbol table.  动态符号表\n    SHT_INIT_ARRAY    = 14, // Pointers to initialization functions.\n    SHT_FINI_ARRAY    = 15, // Pointers to termination functions.\n    SHT_PREINIT_ARRAY = 16, // Pointers to pre-init functions.\n    SHT_GROUP         = 17, // Section group.\n    SHT_SYMTAB_SHNDX  = 18, // Indices for SHN_XINDEX entries\n};\n```\n案例分析③：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex    \n由ELF文件头知：section表偏移为0x485070;表项大小为0x28;表项数目为0x08;推出section头表大小为0x28*0x08=0x140\n\n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 0B 00 00 00   \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00   \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00 11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00   \n25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00 2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\n第一个section头：//No associated section (inactive entry).   \n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00\n\n第二个section头：(.dynsym) //Symbol table    \n>01 00 00 00 0B 00 00 00                            \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n\nsection名称：01 00 00 00    //在字符串表中的下标    \nsection类型：0B 00 00 00    //0xb 符号表 .symbol    \n\n第三个section头：(.dynstr)\n>09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00    \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00   \n\nsection名称：09 00 00 00    \nsection类型：03 00 00 00    //0x3 字符串表 .strtab    \nsection标记：02 00 00 00    \nsection虚拟地址：14 01 00 00    \nsection文件偏移：14 01 00 00 //0x0114    \nsection大小：64 00 00 00   //0x64 推出结束偏移：0x178   \nsection到section头表的链接：00 00 00 00     \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n根据section头信息，导出.dynstr内容：    \n>00 6F 61 74 64 61 74 61 00 6F 61 74 65 78 65 63   \n00 6F 61 74 6C 61 73 74 77 6F 72 64 00 64 61 74   \n61 40 61 70 70 40 63 6F 6D 2E 65 78 61 6D 70 6C   \n65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61 70 70   \n6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31 40 62   \n61 73 65 2E 61 70 6B 40 63 6C 61 73 73 65 73 2E   \n64 65 78 00\n\n对应的字符信息：    \n索引  |  值 \n---|:--:   \n0x0  |  \\00    \n0x1  | oatdata\\00\n0x9  | oatexec\\00\n0x11 | oatlastword\\00\n0x1d | data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\\00\n\n\n第四个section头：(.hash)\n>11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n\nsection名称：11 00 00 00     \nsection类型：05 00 00 00    //0x5 符号hash表    \n\n第五个section头：(.rodata)  [原dex信息,oatdata] [oat文件头起始位置]   \n>17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 \n\nsection名称：17 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：02 00 00 00    \nsection虚拟地址：00 10 00 00    \nsection文件偏移：00 10 00 00    //0x1000    \nsection大小：00 00 2A 00        //0x2A0000 推出结束偏移：0x2A1000   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头，导出.rodata内容：    \n[rodata.txt]\n\n第六个section头：(.text) [native code,oatexec]    \n>1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00  \n\nsection名称：1F 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：06 00 00 00    \nsection虚拟地址：00 10 2A 00    \nsection文件偏移：00 10 2A 00    //0x2A1000    \nsection大小：48 35 1E 00        //0x1E3548 推出结束偏移：0x484548   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头信息，导出.text内容：    \n[text.txt]\n\n**.text段 与 .dynamic段之间有一段空区域**\n\n第七个section头：(.dynamic)      \n>25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00     \n\nsection名称：25 00 00 00    \nsection类型：06 00 00 00    //Information for dynamic linking   \nsection标记：02 00 00 00    \nsection虚拟地址：00 50 48 00    \nsection文件偏移：00 50 48 00    //0x485000    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485038   \nsection到section头表的链接：01 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：08 00 00 00    \n\n第八个section头：(.shstrtab)：    \n由ELF文件头知：shstrtab在section头表总的下标为0x07,在本案例中即最后一个section \n>2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\nsection名称：2E 00 00 00    \nsection类型：03 00 00 00    //字符串表（段表字符串表）    \nsection标记：00 00 00 00    \nsection虚拟地址：00 00 00 00    \nsection文件偏移：38 50 48 00    //0x485038    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485070   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n依据section头信息，导出.shstrtab内容：    \n>00 2E 64 79 6E 73 79 6D 00 2E 64 79 6E 73 74 72   \n00 2E 68 61 73 68 00 2E 72 6F 64 61 74 61 00 2E   \n74 65 78 74 00 2E 64 79 6E 61 6D 69 63 00 2E 73   \n68 73 74 72 74 61 62 00\n\n对应的字符信息：\n索引  |  值\n---|:--:\n0x0  |  \\00\n0x01 |  .dynsym\\00\n0x09 |  .dynstr\\00\n0x11 |  .hash\\00\n0x17 |  .rodata\\00\n0x1f |  .text\\00\n0x25 |  .dynamic\\00\n0x2e |  .shstrtab\\00\n\n----\n\noat文件头结构：/art/runtime/oat.h\n```\nclass PACKED(4) OatHeader {\n    ...\n private:\n  ...\n  uint8_t magic_[4];    //魔数‘oat\\n’\n  uint8_t version_[4];  //oat文件版本号\n  uint32_t adler32_checksum_;   //校验和\n\n  InstructionSet instruction_set_;  //本地机器指令集，表示指令的类型（枚举类型）/art/runtime/instruction_set.h\n  InstructionSetFeatures instruction_set_features_; //架构特性\n  uint32_t dex_file_count_; //oat文件包含的dex文件个数\n  uint32_t executable_offset_;  //oatexec段开始位置与oatdata段开始位置的偏移值（oatexec段开始位置+executable_offset_=oatdata段开始位置）\n\n  uint32_t interpreter_to_interpreter_bridge_offset_;   //用来从解释器调用另外一个也是通过解释器来执行的类方法的trampoline代码的偏移位置\n  uint32_t interpreter_to_compiled_code_bridge_offset_; //用来从解释器调用另外一个通过本地机器指令执行的类方法的trampoline代码的偏移位置\n  uint32_t jni_dlsym_lookup_offset_;    //类方法在执行过程中，若被调用的方法是JNI函数，那么通过存放在此位置的trampoline代码来调用\n  uint32_t portable_imt_conflict_trampoline_offset_;    //...\n  uint32_t portable_resolution_trampoline_offset_;  //用来在运行时解析还未链接的类方法的trampoline代码位置（portable类型的机器指令）\n  uint32_t portable_to_interpreter_bridge_offset_;  //用来从本地机器指令（portable类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n  uint32_t quick_generic_jni_trampoline_offset_;    //...\n  uint32_t quick_imt_conflict_trampoline_offset_;   //...\n  uint32_t quick_resolution_trampoline_offset_; //用来在运行时解析还未链接的类方法的trampoline代码位置（quick类型的机器指令）\n  uint32_t quick_to_interpreter_bridge_offset_;  //用来从本地机器指令（quick类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n\n  //由于每一个应用程序都会依赖于boot.art文件，上述10个变量指向的trampoline代码段只存在于boot.art文件中，即在应用程序classes.dex生成的oat文件的oatdata段头部，上述变量值均为0\n\n  // The amount that the image this oat is associated with has been patched.\n  int32_t image_patch_delta_;   //该oat文件关联的image被patch的数量\n\n  uint32_t image_file_location_oat_checksum_;   //用来创建image空间的oat文件的校验和\n  uint32_t image_file_location_oat_data_begin_; //用来创建image空间的oat文件的oatdata段在内存的位置\n\n  uint32_t key_value_store_size_;   //用来创建image空间的文件路径的大小\n  uint8_t key_value_store_[0];  // note variable width data at end\n\n  DISALLOW_COPY_AND_ASSIGN(OatHeader);\n};\n```\n```\n// InstructionSet\nenum InstructionSet {\n  kNone,\n  kArm,\n  kArm64,\n  kThumb2,\n  kX86,\n  kX86_64,\n  kMips,\n  kMips64\n};\n```\n\n案例分析④：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n开始位置：0x1000    \n由rodata.txt中的数据及oat文件头结构知：   \n魔数：6F 61 74 0A   //大端序，0x6f61740a    \n版本号：30 33 39 00 //大端序，0x30333900    \n校验和：E4 E3 11 75   \n指令类型：03 00 00 00   \n指令集特性：01 00 00 00   \n包含的dex文件个数：01 00 00 00    \noatexec段开始位置相对于oatdata段开始位置的偏移：00 00 2A 00   \n解释器执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \n解释器执行到本地机器指令执行的trampoline代码的偏移位置：00 00 00 00   \nJNI方法调用的trampoline代码的偏移位置：00 00 00 00    \nportable_imt_conflict_trampoline_offset_：00 00 00 00   \n本地机器指令（portable）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00   \n本地机器指令（portable）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \nquick_generic_jni_trampoline_offset_：00 00 00 00   \nquick_imt_conflict_trampoline_offset_：00 00 00 00    \n本地机器指令（quick）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00    \n本地机器指令（quick）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00    \nimage_patch_delta_：00 00 00 00   \n创建image空间的oat文件的校验和：8E 72 EE 60   \n创建image空间的oat文件的oatdata段在内存的位置：00 F0 17 71    \nkey_value_store_size_：A6 01 00 00    \nkey_value_store_：(dex2oat的参数)   \n\n依据key_value_store_size_导出key_value_store_的内容：   \n>64 65 78 32 6F 61 74 2D 63 6D 64 6C 69 6E 65 00   \n2D 2D 7A 69 70 2D 66 64 3D 36 20 2D 2D 7A 69 70   \n2D 6C 6F 63 61 74 69 6F 6E 3D 2F 64 61 74 61 2F   \n61 70 70 2F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E   \n70 61 73 73 65 72 62 79 2E 6D 79 61 70 70 6C 69   \n63 61 74 69 6F 6E 2E 61 70 70 2D 31 2F 62 61 73   \n65 2E 61 70 6B 20 2D 2D 6F 61 74 2D 66 64 3D 37   \n20 2D 2D 6F 61 74 2D 6C 6F 63 61 74 69 6F 6E 3D   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 64 61 74 61 40 61 70 70 40   \n63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 70 61 73 73   \n65 72 62 79 2E 6D 79 61 70 70 6C 69 63 61 74 69   \n6F 6E 2E 61 70 70 2D 31 40 62 61 73 65 2E 61 70   \n6B 40 63 6C 61 73 73 65 73 2E 64 65 78 20 2D 2D   \n69 6E 73 74 72 75 63 74 69 6F 6E 2D 73 65 74 3D   \n61 72 6D 20 2D 2D 69 6E 73 74 72 75 63 74 69 6F   \n6E 2D 73 65 74 2D 66 65 61 74 75 72 65 73 3D 64   \n69 76 20 2D 2D 72 75 6E 74 69 6D 65 2D 61 72 67   \n20 2D 58 6D 73 36 34 6D 20 2D 2D 72 75 6E 74 69   \n6D 65 2D 61 72 67 20 2D 58 6D 78 35 31 32 6D 00   \n64 65 78 32 6F 61 74 2D 68 6F 73 74 00 41 72 6D   \n00 69 6D 61 67 65 2D 6C 6F 63 61 74 69 6F 6E 00   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 73 79 73 74 65 6D 40 66 72   \n61 6D 65 77 6F 72 6B 40 62 6F 6F 74 2E 61 72 74   \n00 78 70 6F 73 65 64 2D 6F 61 74 2D 76 65 72 73   \n69 6F 6E 00 32 00\n\n对应的字符信息：\n\ndex2oat-cmdline\\00    \n--zip-fd=6    --zip-location=/data/app/com.example.passerby.myapplication.app-1/base.apk --oat-fd=7     --oat-location=/data/dalvik-cache/arm/data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex --instruction-set=arm --instruction-set-features=div --runtime-arg -Xms64m --runtime-arg -Xmx512m\\00   \ndex2oat-host\\00   \nArm\\00    \nimage-location\\00   \n/data/dalvik-cache/arm/system@framework@boot.art\\00   \nxposed-oat-version\\00   \n2\\    \n\nOatHeader后就是Dex文件相关信息(开始位置:0x11FA):      \n根据OatHeader中dex_file_count_的值可知，此处共包含1个Dex文件的内容。    \n若用DexMetaData结构表示Dex文件的内容，其包含的字段如下： \n```   \nuint32_t dex_file_location_size;     //dex文件路径的字节数(4字节)    \nchar* dex_file_location_data;        //dex文件的路径    \nuint32_t dex_file_checksum;          //dex文件的校验和(4字节)    \nuint32_t dex_file_offset;            //dex文件相对于oatdata段开始地址的偏移(4字节)   \nconst uint32_t* methods_offsets_pointer;//是一个数组，元素共有class_defs_size（dex中类的数目）个，该数组的索引与dex中类的索引是一致的，\n                                        即第0个类对应methods_offsets_pointer[0],元素的值是相对于oatdata段开始地址的偏移，\n                                        比如dex中第0个类对应的OatClass在文件中的开始地址=methods_offsets_pointer[0]+oatdata段开始地址。   \n```\n所以，整个DexMetaData的字节数=OatHeader->dex_file_count_ * (4+dex_file_location_data+4+4+4*dex->class_defs_size)\n                          = OatHeader->dex_file_count_ * (12+ dex_file_location_data + 4 * dex->class_defs_size)\n\n案例分析⑤：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n根据OatHeader的结束位置导出Dex文件信息(0x11FA)：   \n>3B 00 00 00 2F 64   \n61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78 61 6D   \n70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61   \n70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31   \n2F 62 61 73 65 2E 61 70 6B 7C 2B D8 F3 7C 18 00   \n00 4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22   \n00 9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22   \n00 4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22   \n00 CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22   \n00 44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22   \n....\n\ndex文件路径的字节数：3B 00 00 00  //0x3B = 3*16+11个字节    \ndex文件路径：   \n2F 64 61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78     \n61 6D 70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D     \n79 61 70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70     \n2D 31 2F 62 61 73 65 2E 61 70 6B    \n\n对应的字符信息：    /data/app/com.example.passerby.myapplication.app-1/base.apk   \ndex文件校验和：7C 2B D8 F3    \ndex文件相对于oatdata段开始地址的偏移：7C 18 00 00   //0x187c  相对于oat文件的偏移：0x1000 + 0x187c = 0x287c   \n\nmethods_offsets_pointer:（每项4个字节，共class_defs_size项，即1422项，结束位置：0x1241+1422*4 = 0x2879）    \n>4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22 00     \n9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22 00     \n4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22 00     \nCC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22 00     \n44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22 \n...\n00 C0 7D 23 00 C4 7E 23 00 00\n\n根据dex文件地址(0x287c-0x2A1000)导出数据：   \n64 65 78 0A 30 33 35 00 39 DD DD F3 29 80 26 28     \n9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C     \nD0 0A 22 00 70 00 00 00 78 56 34 12 00 00 00 00     \n00 00 00 00 F4 09 22 00 19 53 00 00 70 00 00 00     \n87 08 00 00 D4 4C 01 00 51 0D 00 00 F0 6E 01 00     \nB0 3A 00 00 BC 0E 02 00 DF 3E 00 00 3C E4 03 00     \n8E 05 00 00 34 DB 05 00 DC 7D 1B 00 F4 8C 06 00   \n...\n\n可以看到dex文件的文件头：   \n魔数：64 65 78 0A 30 33 35 00  //对应的字符信息dex.035    \ndex文件校验和：39 DD DD F3    \ndex文件sha1签名：29 80 26 28 9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C    \ndex文件大小：D0 0A 22 00        //0x220AD0 推出文件结束地址： 0x287c + 0x220ad0 = 0x22334c    \n文件头大小：70 00 00 00         //0x70    \n字节序：78 56 34 12            //0x12345678 小端序    \nlink_size_:00 00 00 00    \nlink_off_:00 00 00 00   \nmap_off_:F4 09 22 00    \nstring_ids_size_:19 53 00 00    \nstring_ids_off_:70 00 00 00   \ntype_ids_size_:87 08 00 00    \ntype_ids_off_:D4 4C 01 00   \nproto_ids_size_:51 0D 00 00   \nproto_ids_off_:F0 6E 01 00    \nfield_ids_size_:B0 3A 00 00   \nfields_ids_off_:BC 0E 02 00   \nmethod_ids_size_:DF 3E 00 00    \nmethods_ids_off_:3C E4 03 00    \nclass_defs_size_:8E 05 00 00    //0x058E,1422,dex文件中共包含1422个类定义    \nclass_defs_off_:34 DB 05 00     //0x05db34,相对于dex文件头的偏移位置，相对于oat文件的偏移：0x05db34+0x287c=0x0603b0   \ndata_size_:DC 7D 1B 00    \ndata_off_:F4 8C 06 00   \n\n案例分析⑥：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex   \n\n使用dextra工具导出该oat文件中的dex或手动选中dex文件地址范围保存：（采用export的方式导出010的dex模板会识别不了，应该是导 出的格式有问题;下面所说的偏移都是相对于导出dex文件的偏移）\n在010工具的type_ids中查找MainActivity，找到对应的索引号1925，转为16进制即：85 07 00 00 ，在010中全局搜索’85 07 00 00‘，找到MainActivity类定义偏移0x68cd4。\n借助dex分析模板，找到mainActivity类定义的偏移位置：0x068cd4,由DexClassDef结构知，每个DexClassDef大小为32个字节    \n>85 07 00 00 01 00 00 00 14 05 00 00 00 00 00 00   \n3E 16 00 00 00 00 00 00 5A 9C 20 00 00 00 00 00   \n\n类类型：85 07 00 00     //0x0785，指向type_ids的索引    \n访问标志：01 00 00 00   //0x1，public   \n父类类型：14 05 00 00   //0x0514，指向type_ids的索引    \n接口偏移：00 00 00 00   //0x0，指向type_ids的索引，class不为interface,此项值为0   \n源文件名：3E 16 00 00   //0x163e，指向string_ids的索引,string_ids[5094]，MainActivity.java    \n注解偏移：00 00 00 00   //0x0，指向DexAnnotationsDirectoryItem结构，若无此项内容，该值为0   \n类数据偏移：5A 9C 20 00 //0x209c5a，指向DexClassData结构的偏移    \n类静态数据偏移：00 00 00 00 //0x0，指向DexEncodedArray结构的偏移    \n\n查看类数据：（0x209c5a）  \n>00 02 01 02 8D 67 00 01 00 9B 79 81 80 04 8C E8   \n4B 9C 79 01 A4 E8 4B 02 04 80 E9 4B 03 04 00 04   \n01 04 02 02 04 02 04 01 02 1E 04 FF 01 37 6C 21   \n01 37 6D 21 04 04 05 04 03 04 02 04 04 0C 64 27   \n00 02 7F 64 7A 00 02 7F 64 7C 00 02 7F 64 7D 00   \n02 7F 64 7E 00 02 7F 64 7F 00 02 7F 64 80 00 02   \n7F 64 81 00 02 7F 64 82 00 02 7F 64 83 00 02 7F   \n64 84 00 02 7F 64     \n...\nclassDataHeader:\n静态字段个数：0\n实例字段个数：2\n非虚方法：1\n虚方法：2\n\n字段：...\n\n非虚方法：...\n\n虚方法：...\n\n由该MainActivity类定义的偏移位置和class_defs_off偏移位置知：    \n(0x68cd4-0x5db34)/32=1421,即MainActivity是dex文件中第1422个类定义，在类定义列表中的下标为1421 \n对应methods_offsets_pointer[1421]\n\nmethods_offsets_pointer[1421]:C4 7E 23 00   //0X237EC4,该类对应的OatClass相对于oatdata的偏移    \n推出MainActivity对应的OatClass在文件中的偏移：0x237ec4+0x1000 = 0x238ec4   \n\nMainActivity对应的OatClass:(一个direct方法，一个virtual方法)   \n>08 00 00 00 B9 31 48 00 E0 7E 23 00 11 32 48 00    \nEF 5A 27 00 61 33 48 00 23 5B 27 00 09 00 03 00   \n28 01 3A 00 08 01 09 00 05 00 36 07 2C 07 48 00   \n08 06 24 06 09 00 06 00 62 00 34 06 08 06 24 06   \n3E 06 5A 06 09 00 03 00 5A 00 2C 07 08 07 09 00   \n0A 00 82 7A 9E 7A BC 00 C4 00 D6 00 CE 62 94 7A   \n72 6A 08 60 78 7A 00 00 00 00 09 00   \n...\n\n//TODO\nstatus:08 00  //kStatusVerified\ntype:00 00    //kOatClassAllCompiled(没有bitmap结构)\nOatMethodOffSets[0]:B9 31 48 00 E0 7E 23 00\nOatMethodOffSets[1]:11 32 48 00 EF 5A 27 00\n...\n\nOatClass结构分析：  \n```\n//art/runtime/oat_file.h\nclass OatClass {\n    ...\n    private:\n    OatClass(\n        const OatFile* oat_file,\n        mirror::Class::Status status,\n        OatClassType type,\n        uint32_t bitmap_size,\n        const uint32_t* bitmap_pointer,\n        const OatMethodOffsets* methods_pointer\n    );\n    const OatFile*  oat_file_;\n    mirror::Class:Status status_;    //2 bytes\n    OatClassType type_;  //2 byes\n    const uint32_t* bitmap_;\n    const OatMethodOffsets* methods_pointer_;//方法的偏移数组，指向相应的native code，4bytes，OatMethodOffset的个数是该类被编译为native code的个数\n    friend class OatDexFile;\n}\n```\n```\n// art/runtime/mirror/class.h\n enum Status {\n    kStatusRetired = -2,\n    kStatusError = -1,\n    kStatusNotReady = 0,\n    kStatusIdx = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.\n    kStatusLoaded = 2,  // DEX idx values resolved.\n    kStatusResolving = 3,  // Just cloned from temporary class object.\n    kStatusResolved = 4,  // Part of linking.\n    kStatusVerifying = 5,  // In the process of being verified.\n    kStatusRetryVerificationAtRuntime = 6,  // Compile time verification failed, retry at runtime.\n    kStatusVerifyingAtRuntime = 7,  // Retrying verification at runtime.\n    kStatusVerified = 8,  // Logically part of linking; done pre-init.\n    kStatusInitializing = 9,  // Class init in progress.\n    kStatusInitialized = 10,  // Ready to go.\n    kStatusMax = 11,\n};\n```\n```\n// art/runtime/oat.h （OatClass类型不一样，methods_pointer_数组中的偏移位置的计算方式不一样）\nenum OatClassType {\n  kOatClassAllCompiled = 0,   // OatClass is followed by an OatMethodOffsets for each method.\n  kOatClassSomeCompiled = 1,  // A bitmap of which OatMethodOffsets are present follows the OatClass.\n  kOatClassNoneCompiled = 2,  // All methods are interpretted so no OatMethodOffsets are necessary.\n  kOatClassMax = 3,\n};\n```\n```\n// art/runtime/oat.h\nclass PACKED(4) OatMethodOffsets {\n public:\n  OatMethodOffsets();\n\n  OatMethodOffsets(uint32_t code_offset,\n                   uint32_t gc_map_offset);\n\n  ~OatMethodOffsets();\n\n  uint32_t code_offset_;//native code相对于oatdata段的偏移\n  uint32_t gc_map_offset_;\n};\n```\n// OatMethodOffsets 计算方法    \n//函数参数method_idx是方法在dex表示的类中的偏移，比如类的第0个方法method_index为0，第一个方法为method_index为1，依次类推。    \n由于在OatClass中没有保存类中方法的数目，因而没有检查method_index的边界。    \n```\nconst OatMethodOffsets* OatFile::OatClass::GetOatMethodOffsets(uint32_t method_index) const {\n  // NOTE: We don't keep the number of methods and cannot do a bounds check for method_index.\n  if (methods_pointer_ == nullptr) {//没有编译成native code\n    CHECK_EQ(kOatClassNoneCompiled, type_);\n    return nullptr;\n  }\n  size_t methods_pointer_index;\n  if (bitmap_ == nullptr) {//该类所有方法被编译成native code\n    CHECK_EQ(kOatClassAllCompiled, type_);\n    methods_pointer_index = method_index;\n  } else {\n    CHECK_EQ(kOatClassSomeCompiled, type_);\n    if (!BitVector::IsBitSet(bitmap_, method_index)) {//该方法没有对应的native code\n      return nullptr;\n    }\n    size_t num_set_bits = BitVector::NumSetBits(bitmap_, method_index);//使用bitmap记录哪些方法被编译成了native code\n    methods_pointer_index = num_set_bits;//找到相应的索引\n  }\n  const OatMethodOffsets& oat_method_offsets = methods_pointer_[methods_pointer_index];\n  return &oat_method_offsets;\n}\n```\n```\n//art/runtime/base/bit_vector.cc\nuint32_t BitVector::NumSetBits(const uint32_t* storage, uint32_t end) {\n  uint32_t word_end = end >> 5; // end/32\n  uint32_t partial_word_bits = end & 0x1f;// end%32\n\n  uint32_t count = 0u;// 为1的位的数目\n  for (uint32_t word = 0u; word < word_end; word++) {//先算前word_end个字中为1的位的数目，再算不满一个字的前partial_word_bits位中为1的位的数目\n    count += POPCOUNT(storage[word]);\n  }\n  if (partial_word_bits != 0u) {\n    count += POPCOUNT(storage[word_end] & ~(0xffffffffu << partial_word_bits));\n  }\n  return count;\n}\n```\nBitmap的作用：\n* Bitmaps are used to represent which methods are compiled.\n* Each bit represents every method in the class ,starting with direct methods,then virtual methods.\n* If bit it is set,the method is compiled.\n\n从OatClass中获取指定方法的native code时，返回的是OatMethod对象，源码如下：    \n/art/runtime/oat_file.cc\n```\n//method_index描述的是目标方法在类中的编号\nconst OatFile::OatMethod OatFile::OatClass::GetOatMethod(uint32_t method_index) const {\n  const OatMethodOffsets* oat_method_offsets = GetOatMethodOffsets(method_index);//获取方法偏移\n  if (oat_method_offsets == nullptr) {\n    return OatMethod(nullptr, 0, 0);\n  }\n  if (oat_file_->IsExecutable() ||\n      Runtime::Current() == nullptr ||        // This case applies for oatdump.\n      Runtime::Current()->IsCompiler()) {\n    return OatMethod(\n        oat_file_->Begin(),\n        oat_method_offsets->code_offset_,\n        oat_method_offsets->gc_map_offset_);\n  } else {\n    // We aren't allowed to use the compiled code. We just force it down the interpreted version.\n    return OatMethod(oat_file_->Begin(), 0, 0);\n  }\n}\n```\n```\n/art/runtime/oat_file.h\nclass OatMethod{\n    public:\n    ...\n    OatMethod(\n        const byte* base,\n        const uint32_t code_offset,\n        const uint32_t gc_map_offset\n    );\n    OatMethod(){}\n    private:\n    ...\n    const byte* begin_; //oatdata段开始位置\n    uint32_t code_offset_;  //OatMethodOffsets->code_offset_\n    uint32_t native_gc_map_offset_;\n    friend class OatClass;\n};\n```\n然后就可以通过OatMethod来定位到方法的native code了（begin_+code_offset_）。\n\n总结：  \n* Oat文件其实就是类型为shared object 的Elf文件，首先有一个Elf Header，Elf Header中e_phoff字段指向了program header talbe，e_shoff字段指向了section header table；\n* section header table中有一个名字为.dynsym的section head，该section head描述的section是符号表；\n* Oat文件导出了3个符号：oatdata，oatexec，oatlastword；\n* oatdata指向oatdata段，该区域存的是只读数据，包括 OatHeader，dex相关信息，dex类中方法与native code的映射关系（由 OatClass表示），通过OatClass可以找到对应方法的native code；\n* oatexec指向oatexec段，该区域存的是方法的native code，是可执行的；\n* oatlastword指向oatexec段的最后一个字的开始地址。即oatexec段的结束地址=oatlastword->st_value+3。\n","tags":["Android Oat"]},{"title":"Hello World","url":"/2018/12/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]