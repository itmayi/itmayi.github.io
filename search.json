[{"title":"Java 打印堆栈信息","url":"/2018/12/26/Java-打印堆栈信息/","content":"#java打印堆栈信息\n\n+ 在函数内部打印函数调用堆栈\n```\nLog.d(TAG,Log.getStackTraceString(new Throwable()));\n```\n+ 出异常时打印当前堆栈\n```\ntry{\n\n}\ncatch(Exception e){\n    e.printStackTrace();\n}\n```\n+ 使用StackTraceElement[]打印\n```\nThrowable ex = new Throwable();\nStackTraceElement[] stackElements = ex.getStackTrace();\nif (stackElements != null) {\n    for (int i = 0; i < stackElements.length; i++) {\n        System.out.print(stackElements[i].getClassName()+\"/t\");\n        System.out.print(stackElements[i].getFileName()+\"/t\");\n        System.out.print(stackElements[i].getLineNumber()+\"/t\");\n        System.out.println(stackElements[i].getMethodName());\n        System.out.println(\"-----------------------------------\");\n    }\n}\n```\n+ 使用Thread打印\n```\nThread.currentThread().getStackTrace()\n```\n+ 使用exception打印\n```\nException e = new Exception(\"this is a log\");\ne.printStackTrace();\n```","tags":["Java，堆栈"]},{"title":"Android Oat文件分析","url":"/2018/12/26/Oat文件分析/","content":"\n.oatdata -> .rodata(oatHeader、dex文件相关信息、dex原始文件、类中方法与翻译为native code的对应关系)\n.oatexec -> .text(native code)\n\n# elf文件结构(32位)：\n```\ntypedef uint16_t Elf32_Half; //2 bytes\ntypedef uint32_t Elf32_Word; //4 bytes\ntypedef uint32_t Elf32_Addr; //4 bytes\ntypedef uint32_t Elf32_Off;  //4 bytes\ntypedef int32_t  Elf32_Sword;//4 bytes\n```\n```\n// Object file magic string.\nstatic const char ElfMagic[] = { 0x7f, 'E', 'L', 'F', '\\0' }\n```\n```\n// e_ident size and indices.\nenum {\n  EI_MAG0       = 0,          // File identification index.\n  EI_MAG1       = 1,          // File identification index.\n  EI_MAG2       = 2,          // File identification index.\n  EI_MAG3       = 3,          // File identification index.\n  EI_CLASS      = 4          ,// File class.\n  EI_DATA       = 5,          // Data encoding.\n  EI_VERSION    = 6,          // File version.\n  EI_OSABI      = 7,          // OS/ABI identification.\n  EI_ABIVERSION = 8,          // ABI version.\n  EI_PAD        = 9,          // Start of padding bytes.\n  EI_NIDENT     = 16          // Number of bytes in e_ident.\n};\n```\nelf文件头结构：（16+4+20+12=52字节，1+2+5+6=14项）\n```\nstruct Elf32_Ehdr{\n    unsigned char e_ident[EI_NIDENT];//ELF文件魔数          16字节\n    Elf32_Half  e_type;              //ELF文件类型（32/64位）2字节  2*2\n    Elf32_Half  e_machine;           //该ELF文件所需要的架构  2字节\n    Elf32_Word  e_version;           //ELF文件版本（始终为1） 4字节   4*5\n    Elf32_Addr  e_entry;             //程序入口地址          4字节\n    Elf32_Off   e_phoff;             //segment表偏移地址     4字节\n    Elf32_Off   e_shoff;             //section表偏移地址     4字节\n    Elf32_Word  e_flags;             //标志                 4字节\n    Elf32_Half  e_ehsize;            //ELF文件头大小         2字节   2*6\n    Elf32_Half  e_phentsize;        //segment表项大小        2字节\n    Elf32_Half  e_phnum;            //segment表项数目        2字节\n    Elf32_Half  e_shentsize;        //section表项大小        2字节  \n    Elf32_Half  e_shnum;            //section表项数目        2字节\n    Elf32_Half  e_shstrndx;         //段表字符串表在section表中的下标 2字节\n};\n```\n```\n// File types\nenum {\n  ET_NONE   = 0,      // No file type\n  ET_REL    = 1,      // Relocatable file\n  ET_EXEC   = 2,      // Executable file\n  ET_DYN    = 3,      // Shared object file\n  ET_CORE   = 4,      // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n```\n```\n// Machine architectures\nenum {\n    EM_NONE = 0, // No machine\n    EM_ARM  = 40 // ARM\n    ...\n};\n```\n案例分析①：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n>7F 45 4C 46 01 01 01 03 00 00 00 00 00 00 00 00\n03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00\n70 50 48 00 00 00 00 05 34 00 20 00 05 00 28 00\n08 00 07 00\n\n魔数：7F 45 4C 46 //0x464c457f  \n位宽：01 //0x01代表32位；0x02代表64位    \n端序：01 //0x01代表小端；0x02代表打断    \n版本：01   \n操作系统：03 //0x03代表Linux  \n00 00 00 00 00 00 00 00   \n文件类型：03 00  //0x03:共享文件    \n芯片架构：28 00 // 0x28 ARM架构   \n文件版本：01 00 00 00 //0x01 (始终为1)    \n程序入口地址：00 00 00 00 //0x0   \nsegment表偏移：34 00 00 00 //0x34   \nsection表偏移：70 50 48 00 //0x485070   \n标志：00 00 00 05   //0x5000000   \n文件头大小：34 00   //0x34    \nsegment表项大小：20 00  //0x20    \nsegment表项数目：05 00  //0x05    \nsection表项大小：28 00  //0x28    \nsection表项数目：08 00  //0x08    \n段表字符串表在段表中下标：07 00 //0x07\n\n----\n\nsegment头结构：（8项，每项4个字节，32字节）\n```\nstruct Elf32_Phdr{\n    Elf32_Word  p_type;//segment类型\n    Elf32_Off   p_offset;//segment相对文件开始的偏移\n    Elf32_Addr  p_vaddr;//segment映射到内存中的首字节地址（即虚拟地址）\n    Elf32_Addr  p_paddr;//在物理地址定位有关的系统中，该字段是为该段的物理地址而保留的，对于可执行文件和共享的object而言是未指定内容的。\n    Elf32_Word  p_filesz;//在文件映像中该segment的字节数（可能是0）\n    Elf32_Word  p_memsz;//在内存映像中该segment的字节数（可能是0）\n    Elf32_Word  p_flags;//segment标志\n    Elf32_Word  p_align;//可载入的进程段必须有合适的p_vaddr、p_offset值，取页面大小的模。该字段给出了该段在内存和文件中排列值。0和1表示不需要排列。否则，p_align必须为正的2的幂\n};\n```\n```\n// Segment types.\nenum {\n    PT_NULL    = 0, // Unused segment.空值\n    PT_LOAD    = 1, // Loadable segment.加载到内存中\n    PT_DYNAMIC = 2, // Dynamic linking information.动态链接\n    PT_INTERP  = 3, // Interpreter pathname.动态链接的辅助信息\n    PT_NOTE    = 4, // Auxiliary information.其他信息\n    PT_SHLIB   = 5, // Reserved.RFU\n    PT_PHDR    = 6, // The program header table itself.segment表头的位置和大小\n    PT_TLS     = 7, // The thread-local storage template.\n    ...\n};\n```\n案例分析②：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n由ELF文件头知：segment表偏移为0x34;表大小为0x05;表项大小为0x20;推出segment头表大小为：0x05*0x20=0xa0 \n\n>06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00 //PT_PHDR  \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 //PT_LOAD   \n00 10 2A 00 00 10 2A 00 04 00 00 00 00 10 00 00   \n01 00 00 00 00 10 2A 00 00 10 2A 00 00 10 2A 00 //PT_LOAD   \n48 35 1E 00 48 35 1E 00 05 00 00 00 00 10 00 00   \n01 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_LOAD   \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n02 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_DYNAMIC    \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n\n第一个segment头：   \n06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00   \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \nsegment类型：06 00 00 00    //PT_PHDR(程序头表自身)   \nsegment文件偏移：34 00 00 00    \nsegment虚拟地址：34 00 00 00    \nsegment物理地址：34 00 00 00    \n文件映像中该segment字节数：A0 00 00 00    \n内存映像中该segment字节数：A0 00 00 00    \nsegment标志：04 00 00 00    \nsegment对齐：04 00 00 00\n\n其他segment头:    \n省略...\n\nsection头结构：（10项，每项4个字节，40字节）\n```\nstruct Elf32__Shdr{\n  Elf32_Word sh_name;      // Section name (index into string table), section名字，string table的索引\n  Elf32_Word sh_type;      // Section type (SHT_*),section的类型\n  Elf32_Word sh_flags;     // Section flags (SHF_*),section标记，用来描述多个属性\n  Elf32_Addr sh_addr;      // Address where section is to be loaded,若该section被加载到内存中，该字段表示其在内存中的位置\n  Elf32_Off  sh_offset;    // File offset of section data, in bytes,该section在文件中的偏移，SHT_NOBITS类型的section在文件中不占用空间，概念上的位置\n  Elf32_Word sh_size;      // Size of section, in bytes,section大小，SHT_NOBITS类型的section该值可能为非0，但是不占文件空间\n  Elf32_Word sh_link;      // Section type-specific header table index link,到section头表的链接\n  Elf32_Word sh_info;      // Section type-specific extra information,额外信息\n  Elf32_Word sh_addralign; // Section address alignment,地址对齐\n  Elf32_Word sh_entsize;   // Size of records contained within the section,一些sections保留着一张固定大小入口的表，对于此类型的section，该字段给除了每个入口的字节大小\n};\n```\n```\n// Section types.\nenum {\n    SHT_NULL          = 0,  // No associated section (inactive entry).\n    SHT_PROGBITS      = 1,  // Program-defined contents.\n    SHT_SYMTAB        = 2,  // Symbol table. 符号表\n    SHT_STRTAB        = 3,  // String table. 字符串表\n    SHT_RELA          = 4,  // Relocation entries; explicit addends.\n    SHT_HASH          = 5,  // Symbol hash table.\n    SHT_DYNAMIC       = 6,  // Information for dynamic linking.\n    SHT_NOTE          = 7,  // Information about the file.\n    SHT_NOBITS        = 8,  // Data occupies no space in the file.\n    SHT_REL           = 9,  // Relocation entries; no explicit addends.\n    SHT_SHLIB         = 10, // Reserved.\n    SHT_DYNSYM        = 11, // Symbol table.  动态符号表\n    SHT_INIT_ARRAY    = 14, // Pointers to initialization functions.\n    SHT_FINI_ARRAY    = 15, // Pointers to termination functions.\n    SHT_PREINIT_ARRAY = 16, // Pointers to pre-init functions.\n    SHT_GROUP         = 17, // Section group.\n    SHT_SYMTAB_SHNDX  = 18, // Indices for SHN_XINDEX entries\n};\n```\n案例分析③：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex    \n由ELF文件头知：section表偏移为0x485070;表项大小为0x28;表项数目为0x08;推出section头表大小为0x28*0x08=0x140\n\n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 0B 00 00 00   \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00   \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00 11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00   \n25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00 2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\n第一个section头：//No associated section (inactive entry).   \n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00\n\n第二个section头：(.dynsym) //Symbol table    \n>01 00 00 00 0B 00 00 00                            \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n\nsection名称：01 00 00 00    //在字符串表中的下标    \nsection类型：0B 00 00 00    //0xb 符号表 .symbol    \n\n第三个section头：(.dynstr)\n>09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00    \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00   \n\nsection名称：09 00 00 00    \nsection类型：03 00 00 00    //0x3 字符串表 .strtab    \nsection标记：02 00 00 00    \nsection虚拟地址：14 01 00 00    \nsection文件偏移：14 01 00 00 //0x0114    \nsection大小：64 00 00 00   //0x64 推出结束偏移：0x178   \nsection到section头表的链接：00 00 00 00     \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n根据section头信息，导出.dynstr内容：    \n>00 6F 61 74 64 61 74 61 00 6F 61 74 65 78 65 63   \n00 6F 61 74 6C 61 73 74 77 6F 72 64 00 64 61 74   \n61 40 61 70 70 40 63 6F 6D 2E 65 78 61 6D 70 6C   \n65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61 70 70   \n6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31 40 62   \n61 73 65 2E 61 70 6B 40 63 6C 61 73 73 65 73 2E   \n64 65 78 00\n\n对应的字符信息：    \n索引  |  值 \n---|:--:   \n0x0  |  \\00    \n0x1  | oatdata\\00\n0x9  | oatexec\\00\n0x11 | oatlastword\\00\n0x1d | data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\\00\n\n\n第四个section头：(.hash)\n>11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n\nsection名称：11 00 00 00     \nsection类型：05 00 00 00    //0x5 符号hash表    \n\n第五个section头：(.rodata)  [原dex信息,oatdata] [oat文件头起始位置]   \n>17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 \n\nsection名称：17 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：02 00 00 00    \nsection虚拟地址：00 10 00 00    \nsection文件偏移：00 10 00 00    //0x1000    \nsection大小：00 00 2A 00        //0x2A0000 推出结束偏移：0x2A1000   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头，导出.rodata内容：    \n[rodata.txt]\n\n第六个section头：(.text) [native code,oatexec]    \n>1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00  \n\nsection名称：1F 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：06 00 00 00    \nsection虚拟地址：00 10 2A 00    \nsection文件偏移：00 10 2A 00    //0x2A1000    \nsection大小：48 35 1E 00        //0x1E3548 推出结束偏移：0x484548   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头信息，导出.text内容：    \n[text.txt]\n\n**.text段 与 .dynamic段之间有一段空区域**\n\n第七个section头：(.dynamic)      \n>25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00     \n\nsection名称：25 00 00 00    \nsection类型：06 00 00 00    //Information for dynamic linking   \nsection标记：02 00 00 00    \nsection虚拟地址：00 50 48 00    \nsection文件偏移：00 50 48 00    //0x485000    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485038   \nsection到section头表的链接：01 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：08 00 00 00    \n\n第八个section头：(.shstrtab)：    \n由ELF文件头知：shstrtab在section头表总的下标为0x07,在本案例中即最后一个section \n>2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\nsection名称：2E 00 00 00    \nsection类型：03 00 00 00    //字符串表（段表字符串表）    \nsection标记：00 00 00 00    \nsection虚拟地址：00 00 00 00    \nsection文件偏移：38 50 48 00    //0x485038    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485070   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n依据section头信息，导出.shstrtab内容：    \n>00 2E 64 79 6E 73 79 6D 00 2E 64 79 6E 73 74 72   \n00 2E 68 61 73 68 00 2E 72 6F 64 61 74 61 00 2E   \n74 65 78 74 00 2E 64 79 6E 61 6D 69 63 00 2E 73   \n68 73 74 72 74 61 62 00\n\n对应的字符信息：\n索引  |  值\n---|:--:\n0x0  |  \\00\n0x01 |  .dynsym\\00\n0x09 |  .dynstr\\00\n0x11 |  .hash\\00\n0x17 |  .rodata\\00\n0x1f |  .text\\00\n0x25 |  .dynamic\\00\n0x2e |  .shstrtab\\00\n\n----\n\noat文件头结构：/art/runtime/oat.h\n```\nclass PACKED(4) OatHeader {\n    ...\n private:\n  ...\n  uint8_t magic_[4];    //魔数‘oat\\n’\n  uint8_t version_[4];  //oat文件版本号\n  uint32_t adler32_checksum_;   //校验和\n\n  InstructionSet instruction_set_;  //本地机器指令集，表示指令的类型（枚举类型）/art/runtime/instruction_set.h\n  InstructionSetFeatures instruction_set_features_; //架构特性\n  uint32_t dex_file_count_; //oat文件包含的dex文件个数\n  uint32_t executable_offset_;  //oatexec段开始位置与oatdata段开始位置的偏移值（oatexec段开始位置+executable_offset_=oatdata段开始位置）\n\n  uint32_t interpreter_to_interpreter_bridge_offset_;   //用来从解释器调用另外一个也是通过解释器来执行的类方法的trampoline代码的偏移位置\n  uint32_t interpreter_to_compiled_code_bridge_offset_; //用来从解释器调用另外一个通过本地机器指令执行的类方法的trampoline代码的偏移位置\n  uint32_t jni_dlsym_lookup_offset_;    //类方法在执行过程中，若被调用的方法是JNI函数，那么通过存放在此位置的trampoline代码来调用\n  uint32_t portable_imt_conflict_trampoline_offset_;    //...\n  uint32_t portable_resolution_trampoline_offset_;  //用来在运行时解析还未链接的类方法的trampoline代码位置（portable类型的机器指令）\n  uint32_t portable_to_interpreter_bridge_offset_;  //用来从本地机器指令（portable类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n  uint32_t quick_generic_jni_trampoline_offset_;    //...\n  uint32_t quick_imt_conflict_trampoline_offset_;   //...\n  uint32_t quick_resolution_trampoline_offset_; //用来在运行时解析还未链接的类方法的trampoline代码位置（quick类型的机器指令）\n  uint32_t quick_to_interpreter_bridge_offset_;  //用来从本地机器指令（quick类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n\n  //由于每一个应用程序都会依赖于boot.art文件，上述10个变量指向的trampoline代码段只存在于boot.art文件中，即在应用程序classes.dex生成的oat文件的oatdata段头部，上述变量值均为0\n\n  // The amount that the image this oat is associated with has been patched.\n  int32_t image_patch_delta_;   //该oat文件关联的image被patch的数量\n\n  uint32_t image_file_location_oat_checksum_;   //用来创建image空间的oat文件的校验和\n  uint32_t image_file_location_oat_data_begin_; //用来创建image空间的oat文件的oatdata段在内存的位置\n\n  uint32_t key_value_store_size_;   //用来创建image空间的文件路径的大小\n  uint8_t key_value_store_[0];  // note variable width data at end\n\n  DISALLOW_COPY_AND_ASSIGN(OatHeader);\n};\n```\n```\n// InstructionSet\nenum InstructionSet {\n  kNone,\n  kArm,\n  kArm64,\n  kThumb2,\n  kX86,\n  kX86_64,\n  kMips,\n  kMips64\n};\n```\n\n案例分析④：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n开始位置：0x1000    \n由rodata.txt中的数据及oat文件头结构知：   \n魔数：6F 61 74 0A   //大端序，0x6f61740a    \n版本号：30 33 39 00 //大端序，0x30333900    \n校验和：E4 E3 11 75   \n指令类型：03 00 00 00   \n指令集特性：01 00 00 00   \n包含的dex文件个数：01 00 00 00    \noatexec段开始位置相对于oatdata段开始位置的偏移：00 00 2A 00   \n解释器执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \n解释器执行到本地机器指令执行的trampoline代码的偏移位置：00 00 00 00   \nJNI方法调用的trampoline代码的偏移位置：00 00 00 00    \nportable_imt_conflict_trampoline_offset_：00 00 00 00   \n本地机器指令（portable）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00   \n本地机器指令（portable）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \nquick_generic_jni_trampoline_offset_：00 00 00 00   \nquick_imt_conflict_trampoline_offset_：00 00 00 00    \n本地机器指令（quick）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00    \n本地机器指令（quick）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00    \nimage_patch_delta_：00 00 00 00   \n创建image空间的oat文件的校验和：8E 72 EE 60   \n创建image空间的oat文件的oatdata段在内存的位置：00 F0 17 71    \nkey_value_store_size_：A6 01 00 00    \nkey_value_store_：(dex2oat的参数)   \n\n依据key_value_store_size_导出key_value_store_的内容：   \n>64 65 78 32 6F 61 74 2D 63 6D 64 6C 69 6E 65 00   \n2D 2D 7A 69 70 2D 66 64 3D 36 20 2D 2D 7A 69 70   \n2D 6C 6F 63 61 74 69 6F 6E 3D 2F 64 61 74 61 2F   \n61 70 70 2F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E   \n70 61 73 73 65 72 62 79 2E 6D 79 61 70 70 6C 69   \n63 61 74 69 6F 6E 2E 61 70 70 2D 31 2F 62 61 73   \n65 2E 61 70 6B 20 2D 2D 6F 61 74 2D 66 64 3D 37   \n20 2D 2D 6F 61 74 2D 6C 6F 63 61 74 69 6F 6E 3D   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 64 61 74 61 40 61 70 70 40   \n63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 70 61 73 73   \n65 72 62 79 2E 6D 79 61 70 70 6C 69 63 61 74 69   \n6F 6E 2E 61 70 70 2D 31 40 62 61 73 65 2E 61 70   \n6B 40 63 6C 61 73 73 65 73 2E 64 65 78 20 2D 2D   \n69 6E 73 74 72 75 63 74 69 6F 6E 2D 73 65 74 3D   \n61 72 6D 20 2D 2D 69 6E 73 74 72 75 63 74 69 6F   \n6E 2D 73 65 74 2D 66 65 61 74 75 72 65 73 3D 64   \n69 76 20 2D 2D 72 75 6E 74 69 6D 65 2D 61 72 67   \n20 2D 58 6D 73 36 34 6D 20 2D 2D 72 75 6E 74 69   \n6D 65 2D 61 72 67 20 2D 58 6D 78 35 31 32 6D 00   \n64 65 78 32 6F 61 74 2D 68 6F 73 74 00 41 72 6D   \n00 69 6D 61 67 65 2D 6C 6F 63 61 74 69 6F 6E 00   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 73 79 73 74 65 6D 40 66 72   \n61 6D 65 77 6F 72 6B 40 62 6F 6F 74 2E 61 72 74   \n00 78 70 6F 73 65 64 2D 6F 61 74 2D 76 65 72 73   \n69 6F 6E 00 32 00\n\n对应的字符信息：\n\ndex2oat-cmdline\\00    \n--zip-fd=6    --zip-location=/data/app/com.example.passerby.myapplication.app-1/base.apk --oat-fd=7     --oat-location=/data/dalvik-cache/arm/data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex --instruction-set=arm --instruction-set-features=div --runtime-arg -Xms64m --runtime-arg -Xmx512m\\00   \ndex2oat-host\\00   \nArm\\00    \nimage-location\\00   \n/data/dalvik-cache/arm/system@framework@boot.art\\00   \nxposed-oat-version\\00   \n2\\    \n\nOatHeader后就是Dex文件相关信息(开始位置:0x11FA):      \n根据OatHeader中dex_file_count_的值可知，此处共包含1个Dex文件的内容。    \n若用DexMetaData结构表示Dex文件的内容，其包含的字段如下： \n```   \nuint32_t dex_file_location_size;     //dex文件路径的字节数(4字节)    \nchar* dex_file_location_data;        //dex文件的路径    \nuint32_t dex_file_checksum;          //dex文件的校验和(4字节)    \nuint32_t dex_file_offset;            //dex文件相对于oatdata段开始地址的偏移(4字节)   \nconst uint32_t* methods_offsets_pointer;//是一个数组，元素共有class_defs_size（dex中类的数目）个，该数组的索引与dex中类的索引是一致的，\n                                        即第0个类对应methods_offsets_pointer[0],元素的值是相对于oatdata段开始地址的偏移，\n                                        比如dex中第0个类对应的OatClass在文件中的开始地址=methods_offsets_pointer[0]+oatdata段开始地址。   \n```\n所以，整个DexMetaData的字节数=OatHeader->dex_file_count_ * (4+dex_file_location_data+4+4+4*dex->class_defs_size)\n                          = OatHeader->dex_file_count_ * (12+ dex_file_location_data + 4 * dex->class_defs_size)\n\n案例分析⑤：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n根据OatHeader的结束位置导出Dex文件信息(0x11FA)：   \n>3B 00 00 00 2F 64   \n61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78 61 6D   \n70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61   \n70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31   \n2F 62 61 73 65 2E 61 70 6B 7C 2B D8 F3 7C 18 00   \n00 4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22   \n00 9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22   \n00 4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22   \n00 CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22   \n00 44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22   \n....\n\ndex文件路径的字节数：3B 00 00 00  //0x3B = 3*16+11个字节    \ndex文件路径：   \n2F 64 61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78     \n61 6D 70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D     \n79 61 70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70     \n2D 31 2F 62 61 73 65 2E 61 70 6B    \n\n对应的字符信息：    /data/app/com.example.passerby.myapplication.app-1/base.apk   \ndex文件校验和：7C 2B D8 F3    \ndex文件相对于oatdata段开始地址的偏移：7C 18 00 00   //0x187c  相对于oat文件的偏移：0x1000 + 0x187c = 0x287c   \n\nmethods_offsets_pointer:（每项4个字节，共class_defs_size项，即1422项，结束位置：0x1241+1422*4 = 0x2879）    \n>4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22 00     \n9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22 00     \n4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22 00     \nCC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22 00     \n44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22 \n...\n00 C0 7D 23 00 C4 7E 23 00 00\n\n根据dex文件地址(0x287c-0x2A1000)导出数据：   \n64 65 78 0A 30 33 35 00 39 DD DD F3 29 80 26 28     \n9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C     \nD0 0A 22 00 70 00 00 00 78 56 34 12 00 00 00 00     \n00 00 00 00 F4 09 22 00 19 53 00 00 70 00 00 00     \n87 08 00 00 D4 4C 01 00 51 0D 00 00 F0 6E 01 00     \nB0 3A 00 00 BC 0E 02 00 DF 3E 00 00 3C E4 03 00     \n8E 05 00 00 34 DB 05 00 DC 7D 1B 00 F4 8C 06 00   \n...\n\n可以看到dex文件的文件头：   \n魔数：64 65 78 0A 30 33 35 00  //对应的字符信息dex.035    \ndex文件校验和：39 DD DD F3    \ndex文件sha1签名：29 80 26 28 9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C    \ndex文件大小：D0 0A 22 00        //0x220AD0 推出文件结束地址： 0x287c + 0x220ad0 = 0x22334c    \n文件头大小：70 00 00 00         //0x70    \n字节序：78 56 34 12            //0x12345678 小端序    \nlink_size_:00 00 00 00    \nlink_off_:00 00 00 00   \nmap_off_:F4 09 22 00    \nstring_ids_size_:19 53 00 00    \nstring_ids_off_:70 00 00 00   \ntype_ids_size_:87 08 00 00    \ntype_ids_off_:D4 4C 01 00   \nproto_ids_size_:51 0D 00 00   \nproto_ids_off_:F0 6E 01 00    \nfield_ids_size_:B0 3A 00 00   \nfields_ids_off_:BC 0E 02 00   \nmethod_ids_size_:DF 3E 00 00    \nmethods_ids_off_:3C E4 03 00    \nclass_defs_size_:8E 05 00 00    //0x058E,1422,dex文件中共包含1422个类定义    \nclass_defs_off_:34 DB 05 00     //0x05db34,相对于dex文件头的偏移位置，相对于oat文件的偏移：0x05db34+0x287c=0x0603b0   \ndata_size_:DC 7D 1B 00    \ndata_off_:F4 8C 06 00   \n\n案例分析⑥：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex   \n\n使用dextra工具导出该oat文件中的dex或手动选中dex文件地址范围保存：（采用export的方式导出010的dex模板会识别不了，应该是导 出的格式有问题;下面所说的偏移都是相对于导出dex文件的偏移）\n在010工具的type_ids中查找MainActivity，找到对应的索引号1925，转为16进制即：85 07 00 00 ，在010中全局搜索’85 07 00 00‘，找到MainActivity类定义偏移0x68cd4。\n借助dex分析模板，找到mainActivity类定义的偏移位置：0x068cd4,由DexClassDef结构知，每个DexClassDef大小为32个字节    \n>85 07 00 00 01 00 00 00 14 05 00 00 00 00 00 00   \n3E 16 00 00 00 00 00 00 5A 9C 20 00 00 00 00 00   \n\n类类型：85 07 00 00     //0x0785，指向type_ids的索引    \n访问标志：01 00 00 00   //0x1，public   \n父类类型：14 05 00 00   //0x0514，指向type_ids的索引    \n接口偏移：00 00 00 00   //0x0，指向type_ids的索引，class不为interface,此项值为0   \n源文件名：3E 16 00 00   //0x163e，指向string_ids的索引,string_ids[5094]，MainActivity.java    \n注解偏移：00 00 00 00   //0x0，指向DexAnnotationsDirectoryItem结构，若无此项内容，该值为0   \n类数据偏移：5A 9C 20 00 //0x209c5a，指向DexClassData结构的偏移    \n类静态数据偏移：00 00 00 00 //0x0，指向DexEncodedArray结构的偏移    \n\n查看类数据：（0x209c5a）  \n>00 02 01 02 8D 67 00 01 00 9B 79 81 80 04 8C E8   \n4B 9C 79 01 A4 E8 4B 02 04 80 E9 4B 03 04 00 04   \n01 04 02 02 04 02 04 01 02 1E 04 FF 01 37 6C 21   \n01 37 6D 21 04 04 05 04 03 04 02 04 04 0C 64 27   \n00 02 7F 64 7A 00 02 7F 64 7C 00 02 7F 64 7D 00   \n02 7F 64 7E 00 02 7F 64 7F 00 02 7F 64 80 00 02   \n7F 64 81 00 02 7F 64 82 00 02 7F 64 83 00 02 7F   \n64 84 00 02 7F 64     \n...\nclassDataHeader:\n静态字段个数：0\n实例字段个数：2\n非虚方法：1\n虚方法：2\n\n字段：...\n\n非虚方法：...\n\n虚方法：...\n\n由该MainActivity类定义的偏移位置和class_defs_off偏移位置知：    \n(0x68cd4-0x5db34)/32=1421,即MainActivity是dex文件中第1422个类定义，在类定义列表中的下标为1421 \n对应methods_offsets_pointer[1421]\n\nmethods_offsets_pointer[1421]:C4 7E 23 00   //0X237EC4,该类对应的OatClass相对于oatdata的偏移    \n推出MainActivity对应的OatClass在文件中的偏移：0x237ec4+0x1000 = 0x238ec4   \n\nMainActivity对应的OatClass:(一个direct方法，一个virtual方法)   \n>08 00 00 00 B9 31 48 00 E0 7E 23 00 11 32 48 00    \nEF 5A 27 00 61 33 48 00 23 5B 27 00 09 00 03 00   \n28 01 3A 00 08 01 09 00 05 00 36 07 2C 07 48 00   \n08 06 24 06 09 00 06 00 62 00 34 06 08 06 24 06   \n3E 06 5A 06 09 00 03 00 5A 00 2C 07 08 07 09 00   \n0A 00 82 7A 9E 7A BC 00 C4 00 D6 00 CE 62 94 7A   \n72 6A 08 60 78 7A 00 00 00 00 09 00   \n...\n\n//TODO\nstatus:08 00  //kStatusVerified\ntype:00 00    //kOatClassAllCompiled(没有bitmap结构)\nOatMethodOffSets[0]:B9 31 48 00 E0 7E 23 00\nOatMethodOffSets[1]:11 32 48 00 EF 5A 27 00\n...\n\nOatClass结构分析：  \n```\n//art/runtime/oat_file.h\nclass OatClass {\n    ...\n    private:\n    OatClass(\n        const OatFile* oat_file,\n        mirror::Class::Status status,\n        OatClassType type,\n        uint32_t bitmap_size,\n        const uint32_t* bitmap_pointer,\n        const OatMethodOffsets* methods_pointer\n    );\n    const OatFile*  oat_file_;\n    mirror::Class:Status status_;    //2 bytes\n    OatClassType type_;  //2 byes\n    const uint32_t* bitmap_;\n    const OatMethodOffsets* methods_pointer_;//方法的偏移数组，指向相应的native code，4bytes，OatMethodOffset的个数是该类被编译为native code的个数\n    friend class OatDexFile;\n}\n```\n```\n// art/runtime/mirror/class.h\n enum Status {\n    kStatusRetired = -2,\n    kStatusError = -1,\n    kStatusNotReady = 0,\n    kStatusIdx = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.\n    kStatusLoaded = 2,  // DEX idx values resolved.\n    kStatusResolving = 3,  // Just cloned from temporary class object.\n    kStatusResolved = 4,  // Part of linking.\n    kStatusVerifying = 5,  // In the process of being verified.\n    kStatusRetryVerificationAtRuntime = 6,  // Compile time verification failed, retry at runtime.\n    kStatusVerifyingAtRuntime = 7,  // Retrying verification at runtime.\n    kStatusVerified = 8,  // Logically part of linking; done pre-init.\n    kStatusInitializing = 9,  // Class init in progress.\n    kStatusInitialized = 10,  // Ready to go.\n    kStatusMax = 11,\n};\n```\n```\n// art/runtime/oat.h （OatClass类型不一样，methods_pointer_数组中的偏移位置的计算方式不一样）\nenum OatClassType {\n  kOatClassAllCompiled = 0,   // OatClass is followed by an OatMethodOffsets for each method.\n  kOatClassSomeCompiled = 1,  // A bitmap of which OatMethodOffsets are present follows the OatClass.\n  kOatClassNoneCompiled = 2,  // All methods are interpretted so no OatMethodOffsets are necessary.\n  kOatClassMax = 3,\n};\n```\n```\n// art/runtime/oat.h\nclass PACKED(4) OatMethodOffsets {\n public:\n  OatMethodOffsets();\n\n  OatMethodOffsets(uint32_t code_offset,\n                   uint32_t gc_map_offset);\n\n  ~OatMethodOffsets();\n\n  uint32_t code_offset_;//native code相对于oatdata段的偏移\n  uint32_t gc_map_offset_;\n};\n```\n// OatMethodOffsets 计算方法    \n//函数参数method_idx是方法在dex表示的类中的偏移，比如类的第0个方法method_index为0，第一个方法为method_index为1，依次类推。    \n由于在OatClass中没有保存类中方法的数目，因而没有检查method_index的边界。    \n```\nconst OatMethodOffsets* OatFile::OatClass::GetOatMethodOffsets(uint32_t method_index) const {\n  // NOTE: We don't keep the number of methods and cannot do a bounds check for method_index.\n  if (methods_pointer_ == nullptr) {//没有编译成native code\n    CHECK_EQ(kOatClassNoneCompiled, type_);\n    return nullptr;\n  }\n  size_t methods_pointer_index;\n  if (bitmap_ == nullptr) {//该类所有方法被编译成native code\n    CHECK_EQ(kOatClassAllCompiled, type_);\n    methods_pointer_index = method_index;\n  } else {\n    CHECK_EQ(kOatClassSomeCompiled, type_);\n    if (!BitVector::IsBitSet(bitmap_, method_index)) {//该方法没有对应的native code\n      return nullptr;\n    }\n    size_t num_set_bits = BitVector::NumSetBits(bitmap_, method_index);//使用bitmap记录哪些方法被编译成了native code\n    methods_pointer_index = num_set_bits;//找到相应的索引\n  }\n  const OatMethodOffsets& oat_method_offsets = methods_pointer_[methods_pointer_index];\n  return &oat_method_offsets;\n}\n```\n```\n//art/runtime/base/bit_vector.cc\nuint32_t BitVector::NumSetBits(const uint32_t* storage, uint32_t end) {\n  uint32_t word_end = end >> 5; // end/32\n  uint32_t partial_word_bits = end & 0x1f;// end%32\n\n  uint32_t count = 0u;// 为1的位的数目\n  for (uint32_t word = 0u; word < word_end; word++) {//先算前word_end个字中为1的位的数目，再算不满一个字的前partial_word_bits位中为1的位的数目\n    count += POPCOUNT(storage[word]);\n  }\n  if (partial_word_bits != 0u) {\n    count += POPCOUNT(storage[word_end] & ~(0xffffffffu << partial_word_bits));\n  }\n  return count;\n}\n```\n\n从OatClass中获取指定方法的native code时，返回的是OatMethod对象，源码如下：    \n/art/runtime/oat_file.cc\n```\n//method_index描述的是目标方法在类中的编号\nconst OatFile::OatMethod OatFile::OatClass::GetOatMethod(uint32_t method_index) const {\n  const OatMethodOffsets* oat_method_offsets = GetOatMethodOffsets(method_index);//获取方法偏移\n  if (oat_method_offsets == nullptr) {\n    return OatMethod(nullptr, 0, 0);\n  }\n  if (oat_file_->IsExecutable() ||\n      Runtime::Current() == nullptr ||        // This case applies for oatdump.\n      Runtime::Current()->IsCompiler()) {\n    return OatMethod(\n        oat_file_->Begin(),\n        oat_method_offsets->code_offset_,\n        oat_method_offsets->gc_map_offset_);\n  } else {\n    // We aren't allowed to use the compiled code. We just force it down the interpreted version.\n    return OatMethod(oat_file_->Begin(), 0, 0);\n  }\n}\n```\n```\n/art/runtime/oat_file.h\nclass OatMethod{\n    public:\n    ...\n    OatMethod(\n        const byte* base,\n        const uint32_t code_offset,\n        const uint32_t gc_map_offset\n    );\n    OatMethod(){}\n    private:\n    ...\n    const byte* begin_; //oatdata段开始位置\n    uint32_t code_offset_;  //OatMethodOffsets->code_offset_\n    uint32_t native_gc_map_offset_;\n    friend class OatClass;\n};\n```\n然后就可以通过OatMethod来定位到方法的native code了（begin_+code_offset_）。\n\n总结：  \n* Oat文件其实就是类型为shared object 的Elf文件，首先有一个Elf Header，Elf Header中e_phoff字段指向了program header talbe，e_shoff字段指向了section header table；\n* section header table中有一个名字为.dynsym的section head，该section head描述的section是符号表；\n* Oat文件导出了3个符号：oatdata，oatexec，oatlastword；\n* oatdata指向oatdata段，该区域存的是只读数据，包括 OatHeader，dex相关信息，dex类中方法与native code的映射关系（由 OatClass表示），通过OatClass可以找到对应方法的native code；\n* oatexec指向oatexec段，该区域存的是方法的native code，是可执行的；\n* oatlastword指向oatexec段的最后一个字的开始地址。即oatexec段的结束地址=oatlastword->st_value+3。\n","tags":["Android Oat"]},{"title":"Hello World","url":"/2018/12/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]