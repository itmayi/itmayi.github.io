[{"title":"Android逆向之arm汇编","url":"/2019/02/21/Android逆向之arm汇编/","content":"\n# ARM\nARM CPU有15个通用寄存器，分别编号为R0~R15。其中R13也叫SP，用于保存栈顶地址；R14也叫LR，用于保存函数的返回地址；R15也叫PC，由于ARM架构的指令预读，实际运行时PC寄存器并不指向当前执行的指令，而是指向当前指令地址加8处。\n\n有关所有ARM指令的文档下载链接如下：\n\nhttp://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt1.pdf\n\nhttp://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt2.pdf\n\nhttp://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt3.pdf\n\n## 指令样例\n\n### B/BL\n\nB/BL指令是最常用的几条指令，作用是跳转到指定的位置，相关的文档解释在ARM7-TDMI-manual-pt2.pdf的4-8页。\n\n指令的二进制解释图：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165915tb4l4ya6t4m4s0l4.png)\n\nCond位表示这条指令是会在何种条件下执行，具体到实际中每个条件都会给B指令加上后缀，比如“BNE/BEQ/BGT”等，也就是我们熟悉的条件跳转指令，作为程序的分支使用。\n\n如图是IDA反汇编中一个条件跳转示例：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165915stmeyibm3tt3bdt6.png)\n\n图中两条指令表示“如果R2等于R0则跳转到0x1C04”。\n\n“101”则是B指令的标识码。\n\nL位表示是否需要保存该指令的下一条指令到LR寄存器，这类B指令就叫BL指令，一般用于跳转到函数内部，其中LR保存返回地址。\n\nOffset是目标地址与该指令的相对偏移（需要考虑到CPU的指令预读，以及左移两位，偏移是按4字节对齐的）。\n\n下面还是按上图的那条指令作例子实际分析各个字段的意思：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165915rs4kes166z1ohn6b.png)\n\n对应二进制\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165915e6i436370q3j0t4i.png)\n\n\n按照二进制解释图中的格式排列（从高位到低位）就是：\n\n0000 - 101 - 0 - 0000 0000 0000 0000 0000 1011\n\nCond - op -\tL -\toffset\n\nCond表示EQ，等于的时候跳转（ARM7-TDMI-manual-pt2.pdf的4-5页）。\n\n101是标识。\n\nL是0，表示不需要保存下一条指令。\n\nOffset是1011，左移两位就是101100，也就是0x2C。当CPU执行到该指令时（0x1BD0处），PC应该指向0x1BD8，所以实际跳转地址就是0x1BD8+0x2C，也就是0x1C04。\n\n### LDR/STR\n\nLDR/STR指令用于向内存读/写数据，相关文档在ARM7-TDMI-manual-pt2.pdf的4-28页。\n\n指令的二进制解释如图：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165916x3h9hjhk469jhz64.png)\n\n看起来很复杂，但我们需要关注的地方不多。不再做详细解释，直接看例子：\n\n指令\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165916axk9zbx8xwnv1vku.png)\n\n对应二进制\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165916phb4kbgkm46jk2b4.png)\n\n按照二进制格式排列：\n\n1110 - 01 - 011001 - 1100 - 0010 - 0000 0000 0000\n\nCond - op -\tIPUBWL - Rn - Rd - Offset\n\nCond表示任何条件都可以（ARM7-TDMI-manual-pt2.pdf的4-5页）。\n\n01是指令标识。\n\nI是0，表示offset是一个立即数。\n\nB是0，表示传输的是一个字，ARM指令集中的“字”是8个字节。\n\nL是1，表示是读内存。\n\nRn是0xC，表示基址寄存器是R12.\n\nRd是2，表示把内存值读到R2。\n\nOffset是0，表示基址寄存器需要加上0.\n\n所以解释成指令就是：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165916axk9zbx8xwnv1vku.png)\n\n意思就是，读取R12寄存器指向的内存到R2寄存器中，一共读取4个字节（一个字）。\n\n# Thumb\n\nTHUMB指令是ARM指令的精简版，在日常的分析中也经常会碰到，具体的文档在ARM7-TDMI-manual-pt3.pdf。分析方法同上，不再缀述。一段程序中有可能同时出现这两种指令集，主要靠CPSR寄存器中的标识位确定当前执行的是何种指令集：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165916j1md2u4b2w3u3npu.png)\n\n红框即是当前指令集状态，1表示在THUMB指令集，0表示在ARM指令集。\n\n# 函数传参\n\n从汇编层面来看，不同的编译方式对函数传参的做法不同，一种比较常见的做法是把前四个参数放到R0~3寄存器中，剩下的参数放到栈中，函数的返回值放在R0中。\n\n如图，C语言中一个简单的函数调用：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165917xoassssgmmfaegpg.png)\n\n调用它的汇编代码则是：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165917vv2ypprlpdo66ulb.png)\n\n可以看到，调用R6中的函数（old_compile）后，把返回值作为参数直接调用hasHooked函数。\n\n# 浮点数基础\n\n在看汇编代码的时候，有时候会碰到浮点数以及浮点指令，这里简单说说浮点数在内存中的二进制形式。具体就是IEEE 754标准。\n\n32位浮点数的二进制格式如图：\n\n![image](https://gslab.qq.com/data/attachment/portal/201604/25/165917ck8wav68ttwtjeva.png)\n\nS为符号位，Exp为指数位，Fraction为有效数字。 指数部分即使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（32位的情况是127）的和。采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。单精度的指数部分是−126～+127加上偏移值127，指数值的大小从1～254（0和255是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。（摘自维基百科https://zh.wikipedia.org/wiki/IEEE_754）\n\n具体来看个例子，浮点数十六进制：\n\n00 00 80 3F\n\n也就是0x3F800000\n\n二进制\n\n0\t01111111\t000 0000 0000 0000 0000 0000\n\nS\tExp\tFraction\n\nS为0，代表这是一个正数。\n\nExp为0x7F，根据偏正值定义，真实值是0x7F-0x7F=0。\n\nFraction为0，注意，这里的Fraction是二进制小数。例如，Fraction为1011001则对应二进制小数1.1011001（整数部分恒为1，后接二进制小数），转换成十进制就是2^(-0)+2^(-1)+2^(-3)+2^(-4)+2^(-7).\n\n计算方法就是（S）F*2^E，其中S是符号位，E是指数位Exp，F是有效位Fraction。\n\n所以这个值就是+2^(-0)，也就是1.","tags":["arm"],"categories":["Android逆向"]},{"title":"Android逆向之smali语法","url":"/2019/02/21/Android逆向之smali语法/","content":"\n# 示例代码\n```\npublic class MainActivity extends Activity implements View.OnClickListener {\n\n    private String TAG = \"MainActivity\";\n    private static final float pi = (float) 3.14;\n\n    public volatile boolean running = false;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    @Override\n    public void onClick(View view) {\n        int result = add(4, 5);\n        System.out.println(result);\n\n        result = sub(9, 3);\n\n        if (result > 4) {\n            log(result);\n        }\n    }\n\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public synchronized int sub(int x, int y) {\n        return x + y;\n    }\n\n    public static void log(int result) {\n        Log.d(\"MainActivity\", \"the result:\" + result);\n    }\n\n\n}\n```\n其对应的smali代码如下：\n```\n#文件头描述\n.class public Lcom/social_touch/demo/MainActivity;\n.super Landroid/app/Activity;#指定MainActivity的父类\n.source \"MainActivity.java\"#源文件名称\n\n#表明实现了View.OnClickListener接口\n# interfaces\n.implements Landroid/view/View$OnClickListener;\n\n#定义float静态字段pi\n# static fields\n.field private static final pi:F = 3.14f\n\n#定义了String类型字段TAG\n# instance fields\n.field private TAG:Ljava/lang/String;\n\n#定义了boolean类型的字段running\n.field public volatile running:Z\n\n#构造方法,如果你还纳闷这个方法是怎么出来的化,就去看看jvm的基础知识吧\n# direct methods\n.method public constructor <init>()V\n    .locals 1#表示函数中使用了一个局部变量\n\n    .prologue#表示方法中代码正式开始\n    .line 8#表示对应与java源文件的低8行\n    #调用Activity中的init()方法\n    invoke-direct {p0}, Landroid/app/Activity;-><init>()V\n\n    .line 10\n    const-string v0, \"MainActivity\"\n\n    iput-object v0, p0, Lcom/social_touch/demo/MainActivity;->TAG:Ljava/lang/String;\n\n    .line 13\n    const/4 v0, 0x0\n\n    iput-boolean v0, p0, Lcom/social_touch/demo/MainActivity;->running:Z\n\n    return-void\n.end method\n\n#静态方法log()\n.method public static log(I)V\n    .locals 3\n    .parameter \"result\"#表示result参数\n\n    .prologue\n    .line 42\n    #v0寄存器中赋值为\"MainActivity\"\n    const-string v0, \"MainActivity\"\n    #创建StringBuilder对象,并将其引用赋值给v1寄存器\n    new-instance v1, Ljava/lang/StringBuilder;\n\n    #调用StringBuilder中的构造方法\n    invoke-direct {v1}, Ljava/lang/StringBuilder;-><init>()V\n\n    #v2寄存器中赋值为ther result:\n    const-string v2, \"the result:\"\n\n    #{v1,v2}大括号中v1寄存器中存储的是StringBuilder对象的引用.\n    #调用StringBuilder中的append(String str)方法,v2寄存器则是参数寄存器.\n    invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n\n    #获取上一个方法的执行结果,此时v1中存储的是append()方法执行后的结果,此处之所以仍然返回v1的    #原因在与append()方法返回的就是自身的引用\n    move-result-object v1\n\n    #继续调用append方法(),p0表示第一个参数寄存器,即上面提到的result参数\n    invoke-virtual {v1, p0}, Ljava/lang/StringBuilder;->append(I)Ljava/lang/StringBuilder;\n\n    #同上\n    move-result-object v1\n\n    #调用StringBuilder对象的toString()方法\n    invoke-virtual {v1}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;\n\n    #获取上一个方法执行结果,toString()方法返回了一个新的String对象,因此v1中此时存储了String对象的引用\n    move-result-object v1\n\n    #调用Log类中的静态方法e().因为e()是静态方法,因此{v0,v1}中的成了参数寄存器\n    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I\n\n    .line 43\n    #调用返回指令,此处没有返回任何值\n    return-void\n.end method\n\n\n# virtual methods\n.method public add(II)I\n    .locals 1\n    .parameter \"x\"#第一个参数\n    .parameter \"y\"#第二个参数\n\n    .prologue\n    .line 34\n\n    #调用add-int指令求和之后将结果赋值给v0寄存器\n    add-int v0, p1, p2\n\n    #返回v0寄存器中的值\n    return v0\n.end method\n\n\n.method public onClick(Landroid/view/View;)V\n    .locals 4\n    .parameter \"view\" #参数view\n\n    .prologue\n    const/4 v3, 0x4 #v3寄存器中赋值为4\n\n    .line 23#java源文件中的第23行\n    const/4 v1, 0x5#v1寄存器中赋值为5\n\n    #调用add()方法\n    invoke-virtual {p0, v3, v1}, Lcom/social_touch/demo/MainActivity;->add(II)I\n\n    #从v0寄存器中获取add方法的执行结果\n    move-result v0\n\n    .line 24#java源文件中的24行\n    .local v0, result:I\n\n    #v1寄存器中赋值为PrintStream对象的引用out\n    sget-object v1, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n    #执行out对象的println()方法\n    invoke-virtual {v1, v0}, Ljava/io/PrintStream;->println(I)V\n\n    .line 26\n\n    const/16 v1, 0x9#v1寄存器中赋值为9\n    const/4 v2, 0x3#v2寄存器中赋值为3\n\n    #调用sub()方法,{p0,v1,v2},p0指的是this,即当前对象,v1,v2则是参数\n    invoke-virtual {p0, v1, v2}, Lcom/social_touch/demo/MainActivity;->sub(II)I\n    #从v0寄存器中获取sub()方法的执行结果\n    move-result v0\n\n    .line 28\n    if-le v0, v3, :cond_0#如果v0寄存器的值小于v3寄存器中的值,则跳转到cond_0处继续执行\n\n    .line 29\n\n    #调用静态方法log()\n    invoke-static {v0}, Lcom/social_touch/demo/MainActivity;->log(I)V\n\n    .line 31\n    :cond_0\n    return-void\n.end method\n\n.method protected onCreate(Landroid/os/Bundle;)V\n    .locals 1\n    .parameter \"savedInstanceState\" #参数savedInstancestate\n\n    .prologue\n    .line 17\n\n    #调用父类方法onCreate()\n    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V\n\n    .line 18\n\n    const v0, 0x7f04001a#v0寄存器赋值为0x7f04001a\n\n    #调用方法setContentView()\n    invoke-virtual {p0, v0}, Lcom/social_touch/demo/MainActivity;->setContentView(I)V\n\n    .line 19\n    return-void\n.end method\n\n#declared-synchronized表示该方法是同步方法\n.method public declared-synchronized sub(II)I\n    .locals 1\n    .parameter \"x\"\n    .parameter \"y\"\n\n    .prologue\n    .line 38\n\n    monitor-enter p0#为该方法添加锁对象p0\n     add-int v0, p1, p2\n    #释放锁对象\n    monitor-exit p0\n\n    return v0\n.end method\n```\n\n# 方法调用与结果返回\ninvoke-kind{},meth@BBBB：大括号中其实是调用该方法的实例+参数列表。\n\ninvoke-kind/range{},meth@BBBB：当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，使用方法也有所不同。\n\nmove-result-xx：如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令。\n\n# 条件跳转分支\n\n\"if-eq vA, vB, :cond_**\"   如果vA等于vB则跳转到:cond_**  \n\"if-ne vA, vB, :cond_**\"   如果vA不等于vB则跳转到:cond_**  \n\"if-lt vA, vB, :cond_**\"    如果vA小于vB则跳转到:cond_**  \n\"if-ge vA, vB, :cond_**\"   如果vA大于等于vB则跳转到:cond_**  \n\"if-gt vA, vB, :cond_**\"   如果vA大于vB则跳转到:cond_**  \n\"if-le vA, vB, :cond_**\"    如果vA小于等于vB则跳转到:cond_**  \n\"if-eqz vA, :cond_**\"   如果vA等于0则跳转到:cond_**  \n\"if-nez vA, :cond_**\"   如果vA不等于0则跳转到:cond_**  \n\"if-ltz vA, :cond_**\"    如果vA小于0则跳转到:cond_**  \n\"if-gez vA, :cond_**\"   如果vA大于等于0则跳转到:cond_**  \n\"if-gtz vA, :cond_**\"   如果vA大于0则跳转到:cond_**  \n\"if-lez vA, :cond_**\"    如果vA小于等于0则跳转到:cond_*  \n\n# 句法\n其基本要求如下\n\n+ 指令以操作码 op 开始，后面直接跟上一个或者多个参数，参数间以逗号分隔。\n+ 指令的参数从指令第一部分开始，op 位于低 8 位，高 8 位可以是一个 8 位的参数，也可以是两个 4 位的参数，还可以为空。如果指令超过 16 位，则后面部分依次作为参数。\n+ 参数Vx表示寄存器，如 v0、v1 等。这里之所以采用 v 而不用 r 是为了避免与实现该虚拟机架构的机器架构中的寄存器命名产生冲突。\n+ 参数 #+X 表示常量数字。\n+ 参数 +X 表示相对指令的地址偏移。\n+ 参数 kind@X 表示常量池索引值，其中 kind 表示常量池类型，可以是以下四种类型\n  + string，字符串常量池索引\n  + type，类型常量池索引\n  + field，字段常量池索引\n  + meth，方法常量池索引\n+ 以指令 op vAA, type@BBBB 为例，指令使用了 1 个寄存器 vAA，一个 32 位的类型常量池索引。\n\n# 指令特点\n\nDalvik 指令在调用规范上大致模仿常见的架构和 C 样式的调用规范，如下\n\n+ 参数顺序为 Dest-then-source 。\n\n+ 利用后缀用来表明运算类型，从而消除歧义：\n\n  + 正常的 32 位运算不标记。\n  + 正常地 64 位运算以 -wide 为后缀。\n  + 特定类型的运算码以其类型（或简单缩写）为后缀，这些类型包括：-boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class 和 -void。\n+ 利用运算码部分后缀区分具有不同指令样式或者或选项的相同运算，这些后缀与主要名称之间以 / 分开，主要目的是使生成和解析可执行文件的代码中存在与静态常量的一对一映射关系，以便于降低让读者感到模糊不清的可能性。\n\n例如，在指令move-wide/from16 vAA, vBBBB 中\n\n+ move为基础运算码，表示这是基本运算，用来移动寄存器的值。\n+ wide为名称后缀，表示指令对 64 位数据进行运算。\n+ from16为运算码后缀，表示源为一个 16 位寄存器的引用变量。\n+ vAA为目的寄存器，取值范围为 v0 - v255。\n+ vBBBB为源寄存器，取值范围为 v0 - v65535。\n\n# 锁指令\n锁指令用于在多线程程序。包含以下两个指令\n\nmonitor-enter vAA\t为指定的对象获取锁\n\nmonitor-exit vAA\t释放指定的对象的锁\n\n","tags":["smali"],"categories":["Android逆向"]},{"title":"radare2-学习笔记二","url":"/2019/01/21/radare2-学习笔记二/","content":"\n\n","tags":["radare2"],"categories":["逆向工具"]},{"title":"radare2学习笔记","url":"/2019/01/16/radare2学习笔记/","content":"\ngithub版本的radare2安装：\n```\n$ git clone https://github.com/radare/radare2.git\n$ cd radare2\n$ ./sys/install.sh\n```\n\n也可以下载对应平台的二进制文件[download page](http://radare.org/r/down.html)\n\n安装期间我遇到的问题：`ld过程中，一个静态库对应的不是x86_64平台`\n\n问过Google后，在[issue](https://github.com/radare/radare2/issues/12044)中有提到可能是由于安装了高版本的binutils，使用`brew list|grep binutils`查看确实是有，使用`brew uninstall binutils`卸载后，重新安装后成功。\n\n主要包含的组件：  \n- rax2 ---------> 用于数值转换\n- rasm2 -------> 反汇编和汇编\n- rabin2 -------> 查看文件格式\n- radiff2 ------> 对文件进行 diff\n- ragg2/ragg2­cc ------> 用于更方便的生成shellcode\n- rahash2 ------> 各种密码算法， hash算法\n\n常用命令：  \n```\naaa 反编译所有\nis 查看符号信息\nafl 查看所有的函数列表\ns 定位函数\npdf 打印逆向的代码\nVV 逻辑视图\np 进入逻辑视图后更改视图类型\ntab 切换视图查看函数\n```\n\n**应用**：  \n\n#### 进入r2界面：\n```\n$ r2 megabeets_0x1\n -- vm is like a small cow in ascii\n[0x08048370]>\n```\n当使用r2运行它的时候，它会给我们一个欢迎界面，同时给我们一个shell操作符，并等待下一步的命令，当前它输出了一个地址 (0x08048370)，这就是它自动识别的程序入口点。\n\n#### 使用a系列命令分析应用：  \n\n`aaa`等同于`af@@ sym.*;af@entry0;afva`,详细分析\n```\n[0x08048370]> aaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[Cannot determine xref search boundariesr references (aar)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan)\n[x] Type matching analysis for all functions (aaft)\n[x] Use -AA or aaaa to perform additional experimental analysis.\n```\n\n分析完成之后，r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串这些都被称作 'flag', flags被整合进flag spaces，一个flag是所有类似特征的集合，展示所有的 flag，用 'fs' 命令\n```\n[0x08048370]> fs\n0    4 * strings\n1   37 * symbols\n2   31 * sections\n3   10 * segments\n4    5 * relocs\n5    5 * imports\n6    1 * functions\n```\n使用 `fs flagspace` 加 `f` 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).\n\n```\n[0x08048370]> fs imports;f\n0x00000000 16 loc.imp.__gmon_start\n0x08048320 6 sym.imp.strcmp\n0x08048330 6 sym.imp.strcpy\n0x08048340 6 sym.imp.puts\n0x08048350 6 sym.imp.__libc_start_main\n```\n\n**分析字符串信息**\n\n使用i系列命令：\n```\n[0x08048370]> iz\n[Strings]\nNum Paddr      Vaddr      Len Size Section  Type  String\n000 0x00000700 0x08048700  20  21 (.rodata) ascii \\n  .:: Megabeets ::.\n001 0x00000715 0x08048715  22  23 (.rodata) ascii Think you can make it?\n002 0x0000072c 0x0804872c   9  10 (.rodata) ascii Success!\\n\n003 0x00000736 0x08048736  21  22 (.rodata) ascii Nop, Wrong argument.\\n\n```\n使用f系列命令展示分析后的结果：\n```\n[0x08048370]> fs strings;f\n0x08048700 21 str..::_Megabeets_::.\n0x08048715 23 str.Think_you_can_make_it\n0x0804872c 10 str.Success\n0x08048736 22 str.Nop__Wrong_argument.\n```\n\n**查看地址引用信息（字符串、函数）**\n`| axt [addr]      find data/code references to this address`\n\n```\n[0x08048370]> axt @@ str.*\nmain 0x8048609 [DATA] push str..::_Megabeets_::.\nmain 0x8048619 [DATA] push str.Think_you_can_make_it\nmain 0x8048646 [DATA] push str.Success\nmain 0x8048658 [DATA] push str.Nop__Wrong_argument.\n```\n'@@'就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 '@@?'）， 'str.*' 是一个通配符，用来标记所有以 'str.'开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。\n\n#### 定位\n\nr2分析完一个程序后会停留在入口点，刚刚看到感兴趣的字符串都是在 'main' 这个函数里被调用的，因此我们用'seek' 命令跳转过去，在 r2 里，它的指令是 's' ,当然你仍然可以用在它后面添加 '?' 的方式来查看它所有可能的用法。\n\nseek 命令通常是接受一个地址或者数学表达式作为参数，这个表达式可以是操作指令、标志位、或者内存操作相关，现在我们想查找 main 函数，因此我们使用 's main' 指令就可以了，不过在这之前我们可以先看看 r2 到底为我们分析出了哪些函数，因此我们用 'afl' 指令，这个指令代表着分析函数列表（Analyze Functions List）\n\n```\n[0x08048370]> afl\n0x080482ec    3 35           sym._init\n0x08048320    1 6            sym.imp.strcmp\n0x08048330    1 6            sym.imp.strcpy\n0x08048340    1 6            sym.imp.puts\n0x08048350    1 6            sym.imp.__libc_start_main\n0x08048360    1 6            sub.__gmon_start_8048360\n0x08048370    1 33           entry0\n0x080483a0    1 4            sym.__x86.get_pc_thunk.bx\n0x080483b0    4 43           sym.deregister_tm_clones\n0x080483e0    4 53           sym.register_tm_clones\n0x08048420    3 30           sym.__do_global_dtors_aux\n0x08048440    4 43   -> 40   entry.init0\n0x0804846b   19 282          sym.rot13\n0x08048585    1 112          sym.beet\n0x080485f5    5 127          main\n0x08048680    4 93           sym.__libc_csu_init\n0x080486e0    1 2            sym.__libc_csu_fini\n0x080486e4    1 20           sym._fini\n```\n\n#### 反汇编\n\n`s sym.beet` 跳到main函数，`pdf`输出反汇编信息\n![image](https://note.youdao.com/yws/api/personal/file/WEBd3905e87978526c0b3871861120653b2?method=download&shareKey=0611918b440d3ae1ff84af208dec4075)\n\n\n#### 视图模式和图形模式（visual mode & graph mode）\n\n输入VV，切换到视图模式，包含引用关系；在逻辑视图模式可以使用p键切换回图形模式。\n\n![iamge](https://note.youdao.com/yws/api/personal/file/WEBaec8dab48bc65d46a020c824734710c1?method=download&shareKey=3871cebd7d30e431a84f4c752ff4e3c0)\n\n**移动**\n\n你可以使用k和j来上下移动，按回车键将在call和jump的时候跳转到目的地址，同时上图里你能看到有一些方括号里面有数字，你可以直接在键盘上按相应的数字就会跳转到对应的函数和地址处 ！\n\n**帮助**\n\n在使用r2的任何阶段，你都可以按 ?来调出帮助画面，这能帮助你更好的使用 r2 .\n\n**交叉引用**\n\nx / X 可以列出当前函数的引用状况，之后再输入相应的数字就可以跳转到指定的引用处了.\n\n#### radare2 命令解释器\n\n视图模式下，使用 :command命令来执行你想要的r2命令.\n\n**注释**\n\n通过 ;[-] 来添加相应的注释\n\n**标记**\n\nm\\<key\\> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.\n\n**退出**\n\n按 q 返回到 r2 的 shell操作界面.\n\n#### rahash2 组件使用\n\n```\n$ rahash2 -E rot -S s:13 -s \"Megabeets\\n\"\nZrtnorrgf\n```\n\n\n#### debug模式\n```\n[0x08048585]> ood?\nUsage: ood [args]   # reopen in debugger mode (with args)\n| oodr [rarun2]  same as dor ..;ood\n[0x08048585]>\n```","tags":["radare2"],"categories":["逆向工具"]},{"title":"Android使用frida-gadget插桩","url":"/2019/01/11/Android使用frida-gadget插桩/","content":"\n# frida 介绍\n\n*-来自官网*  \n[frida](https://www.frida.re/) dynamic instrumentation toolkit for developers, reverse-engineers,and security researchers.\n\n即：frida是一个适用于开发者、逆向工程师、安全研究员的动态\b\b插桩工具。\n\n使用javascript脚本注入进程，执行二进制插桩。可以与调试器共存。\n\n在脚本和原生函数中实现了双向的bridge，既可hook函数并修改参数，也可使用脚本调用原生函数。\n\n除本地\b代码外，内置对Java和Objective C运行时的支持。\n\n跨平台支持Windows，Mac，GNU/Linux，iOS，Android和 QNX。\n\n## frida 插桩实现\n\n#TODO\n\n## 安装部署（Android）\n1. 有root：下载frida-server,adb推入后以rootz执行,默认监听TCP 27042端口，可通过adb forward转发到计算机上；\n2. 无root：将frida-gadget\b.so文件集成到apk中，若目标应用时第三方apk还需要反编译修改smail文件，添加System.loadLibrary()调用。\n\n接下来着重介绍无root情况下的使用方式：\n\n*场景：Android studio，作为开发者使用frida-gadget*\n\n\n从[\bfrida-gadget](https://github.com/frida/frida/releases)下载Android版本的gadget\b压缩包，不同的平台\b对应不同的gadget压缩包，可依据文件名区分。例如：xxx-android-x86.so.xz，对应的就是x86平台的手机。若没有\b对应手机架构的压缩包，可选取兼容版本。例如：arm-v7架构，使用的ABI类型是armeabi-v7a，可兼容ABI类型是armeabi。则可选择xxx-android-arm.so.xz压缩包。\n\n在libs文件夹中新建\b\b\b平台架构对应ABI类型的文件夹，例如：armeabi/, 将解压缩出来的so文件放入Android工程的该文件下，并重命名为libgadget.so。接下来修改build.gradle，添加如下配置：\n\n在android{}中添加如下配置\n```\n    sourceSets.main{\n        jniLibs.srcDirs = ['libs']\n        jni.srcDirs = []\n    }\n```\n\n在externalNativeBuild{}中添加如下\b配置：\n```\n    ndk{\n        abiFilters \"armeabi-v7a\"\n    }\n```\n\n然后再\b通过`System.loadLibrary(\"gadget\")`加载。\n\n编辑gadget的配置文件：\n\n在libgadget.so库所在文件夹下，\b新建libgadget.config.so文件，其中libxxx.config.so中的xxx与libxxx.so保持一致，文件内容如下：\n```\n{\n  \"interaction\": {\n    \"type\": \"script\",\n    \"path\": \"/data/local/tmp/myscript.js\",\n    \"on_change\": \"reload\"\n  }\n}\n```\n\n具体关于命名的规则可参考：https://lief.quarkslab.com/doc/latest/tutorials/09_frida_lief.html\n\n编辑myscript.js文件：\n```\n'use strict';\n\nconsole.log(\"Waiting for Java..\");\n\nJava.perform(function () {\n  var Log = Java.use(\"android.util.Log\");\n  Log.v(\"frida-lief\", \"Have fun!\");\n});\n```\n\n将myscript.js推入/data/local/tmp下，赋予可执行权限\n```\nadb push myscript.js /data/local/tmp\n\nadb shell chmod 777 /data//local/tmp/myscript.js\n```\n\n构建App，并运行观察logcat，可看到日志输出：\n```\nHave fun!\n```\n\n\n## 总结：\n\n重点在于在Android studio中调用\b第三库的相关配置和使用gadget时\b需要注意的文件规范（配置文件与so库\b需在同一目录下，二者命名需一致，配置文件添加.so后缀）。\n","tags":["frida-gadget"],"categories":["Android"]},{"title":"Android studio调用第三方so库","url":"/2019/01/10/Android-studio调用第三方so库/","content":"\n# Android studio调用第三方so库\n\n1. 将so库拷贝到工程下的libs文件下**与平台CPU类型对应**的文件下，如：armeabi/、armeabi-v7a/、armeabi-v8a/、x86/、x86_64/等，\n可通过`adb shell cat /prop/cpuinfo`命令查看平台CPU信息。\n\n构建时可能会遇到的问题：\n\n提示缺少某个平台的so库\n\n在build.gradle的externNativeBuild{}中添加如下配置：\n```\nndk{\n    abiFilters \"armeabi-v7a\"\n}\n\nso库找不到\n\n检查第三方库名字是否是libxxx.so样式\n```\n\n2. 在app下的build.gradle的android{}中配置如下信息，然后重新编译\n```\nsourceSets.main {\n    jniLibs.srcDirs = ['libs']\n    jni.srcDirs = []\n}\n```\n\n到这一步，就可以在Java代码中通过System.load()单独加载。但如果想要同本地的so库交互，就还需要以下的配置。\n\n3. 在CmakeLists.txt中添加如下配置信息\n```\n#设置so库路径\nset(my_lib_path ${CMAKE_SOURCE_DIR}/libs)\n\n#将第三方库作为动态库引用\nadd_library( gadget\n             SHARED\n             IMPORTED )\n\n#指名第三方库的绝对路径\nset_target_properties( gadget\n                       PROPERTIES IMPORTED_LOCATION\n                       ${my_lib_path}/${ANDROID_ABI}/libgadget.so)\n#链接本地库和第三方库\ntarget_link_libraries( # Specifies the target library.\n                       native-lib  #本地库\n                       gadget\n                       ${log-lib} )\n```\n\n完成上述步骤后，尝试重新构建运行应用。","tags":["第三方so库调用"],"categories":["Android studio"]},{"title":"Android无源码动态调试apk","url":"/2019/01/09/Android无源码动态调试apk/","content":"\n调试环境：\n\n一台系统属性ro.debuggable = 1（意味着可调试）的真机\n\n或者一台模拟器\n\n或者使用mprop/BDOpener\b\b工具帮助修改系统ro.debuggable属性。\n\n或者修改AndroidManifest.xml文件，添加或修改android:debuggable属性为true\n\n\n# Android studio + Smalidea + jdwp\n\n下载[smalidea](https://github.com/JesusFreke/smali/wiki/smalidea)，否则无法在smali\u001d代码行下断点。\n\n导入Android studio\n>preference\u001ds ->plugins ->install from disk\n\n使用apktool或baksmali反编译apk，得到包含\bsmail文件夹的apk文件夹。\n> apktool d demo.apk\n\n将反编译得到的apk文件夹使用Android studio打开\n> 打开Android studio\n> \n> import project(Gradle,Eclipse ADT,etc)\n> \n> 右击项目文件夹，\"Mark Directory As\" -> \"Sources Root\"\n>\n> 右击项目文件夹，\"Open Module Settings\" 配置 Project SDK\n> \n> 点击 \"Edit Configurations\"，点击\"+\" ->\"Remote\"，随意输入名字，其他不用改，点击\"Apply\",\"OK\"\n\n将端口5005(默认)转发到应用进程\n> adb shell ps|grep xxx\n>\n> adb forward tcp:5005 jdwp:xxx'pid\n\n打开smail文件夹，在想要断点的smail代码行下断点，点击debug按钮\n\n**期间可能遇到的问题**：\n\nconection prematurally closed.\n\n解决方法：\n> 重启Android studio\n\nconnection refused.\n\n解决方法：\n> 重新使用adb forward 转发端口\n\n\n# IDA\n\n将apk文件拖入\bida窗口，在弹出的窗口中选择classes.dex文件。\n\n点击\bDebug ->Dubugger Options ->选中Suspend on process entry point, \"Set specific options\" ->设置adb executable路径，填入apk包名和入口activity。\n\n点击Debug ->Process Options ->设置port为8700\n\n在想要断点的smail代码行下断点。\n\n点击\"绿色按钮\" \n\n**期间可能遇到的问题**：  \n\n8700 already in use.\n\n解决方法：\n\n> 关闭占用8700端口的进程，常见的如：DDMS, Android studio等\n\n# Jeb\n\n\bMac需要设置adb路径为全局（其他应用也能够使用，~/.bash_profile中设置只在终端有效）。window只需要将adb路径加入系统环境变量PATH中。\n\n将apk拖入jeb窗口，在想要断点的smail代码行下断点\n\n点击Debugger ->start, 选择要调试的应用 -> attach\n\n\n\n\n\n\n\n\n","tags":["动态调试"],"categories":["Android"]},{"title":"TLS/SSL协议","url":"/2019/01/08/TLS-SSL协议/","content":"\n# 什么是SSL、TLS、HTTPS\n\nSSL:Secure Sockets Layer（安全套接层）最初由Netscape开发，早在1995年以SSL2.0的方式发布（SSL1.0从未对公众发布）。在一些漏洞被发现后，版本2.0在1996年被版本3.0取代。\n\nTLS:Transport Layer Security（安全传输层）以SSL3.0为基础在1999年作为SSL的新版本推出。同时SSL3.0在2015年被IEFT组织废弃。TLS1.0通常被标识为SSL3.1，TLS1.1为SSL3.2，TLS 1.2为SSL3.3。\n\nHTTPS：HTTP OVER TLS（建立在TLS之上的HTTP协议）。\n\n# HTTP与HTTPS的区别\n\nHTTP连接方式简单，无状态，使用80端口，HTTPS由SSL+HTTP构建的可实现身份认证和安全传输的网络协议，使用443端口。\n\nHTTPS能够提供：\n- 数据完整性：内容传输经过完整性校验\n\n- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥\n\n- 身份认证：第三方无法伪造服务端(客户端)身份\n\n其中，数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。\n\n完整的HTTPS连接建立大概需要以下几步：  \n  1. DNS查询，获取IP地址\n  2. TCP握手，建立连接\n  3. TLS握手，确定加密方式和密钥\n  4. 建立HTTP连接，交换数据\n\n# 证书\n\n证书包含的信息：\n  1. 证书信息：序列号，过期日期\n  2. 所有者信息：姓名等\n  3. 所有者公钥\n\n为什么需要服务端发送证书给客户端？\n\n互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。\n\n客户端为什么需要验证接收到的证书？\n\n为了防止中间人攻击。攻击者拦截服务端响应，将伪造证书发送给客户端，客户端若未验证地使用证书中的公钥加密传输数据，就会被攻击者通过私钥解密得到明文数据。\n\n客户端如何验证接收到的证书？  \n\n通过数字签名(将一段数据通过哈希和私钥加密后生成数字签名)。\b消息发送方通过将一段文本和数字签名一起发送给消息接收方，接收方接\b收到数据后，将文本通过哈希得到散列值，同时使用公钥解密数字签名得到原散列值，通过比对计算得到的散列值和原散列值判断接收到的文本是否为对应的消息发送方发出的。\n\n该验证的前提是，消息接收方知道消息发送方的公钥。公钥和消息本身一样，不能直接通过不安全的网络发送给消息接收方。\n\n此时就需要证书颁发机构（Certifate Authority，简称CA），客户端内置了所有受信任CA的证书，CA对服务端的公钥(和其他信息)数字签名后生成证书。\n\n服务端将证书发送给客户端后，客户端使用证书公钥验证证书签名。\n\n客户端信任CA，CA信任服务端，客户端信任服务端，从而形成信任链（chain of trust）。\n\n事实上，客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链(Certificate Chain)给客户端。\n\n# HTTPS\b基本原理\n\n![image](https://www.wosign.com/info/info_images/20170606135810.png)\n\n","tags":["TLS","SSL"],"categories":["数据包分析"]},{"title":"数据传输协议框架","url":"/2019/01/07/数据传输协议框架/","content":"\n# Protocol Buffer\n\nGoogle Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。支持python、Java、c++等语言。\n\n## 使用\n\n### 定义.proto文件\n\n.proto文件中定义\b着一系列协议中的实体结构：\n+ message关键字表示一个\b实体结构，由多个字段组成\n\n    例如：\n    ```\n    syntax = \"proto2\";\n\n    package tutorial;\n\n    option java_package = \"com.example.tutorial\";\n    option java_outer_classname = \"AddressBookProtos\";\n\n    message Person {\n        required string name = 1;\n        required int32 id = 2;\n        optional string email = 3;\n\n        enum PhoneType {\n            MOBILE = 0;\n            HOME = 1;\n            WORK = 2;\n        }\n\n        message PhoneNumber {\n            required string number = 1;\n            optional PhoneType type = 2 [default = HOME];\n        }\n\n        repeated PhoneNumber phones = 4;\n    }\n\n    message AddressBook {\n        repeated Person people = 1;\n    }\n    ```\n+ 字段包含修饰符、数据类型、唯一标识、初始值。\n    \n    三种修饰符：required、optional、repeated\n\n    支持的数据类型：\n    ![image](https://note.youdao.com/yws/api/personal/file/WEBd038acafb6eb2ec0003778c5413c963b?method=download&shareKey=d4cdfcbeba2aaf600b311182eb01e5fb)\n\n### 编译.proto\n\n使用protocol buffer的编译器\b将.proto文件编译为\b目标语言。\n\n例如：\n```\nprotoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/xxx.proto\n```\n\n-I 指定源路径，--java_out 选项指定生成java文件，编译完成会在目标路径下生成.java文件。\n\n### Protocol Buffer API\n\n.java 文件部分内容：\n```\n// required string name = 1;\npublic boolean hasName();\npublic String getName();\n\n...\n\n// optional string email = 3;\npublic boolean hasEmail();\npublic String getEmail();\n```\n\nPerson.Builder类中也为每个字段生成getter和setter方法,\n```\n// required string name = 1;\npublic boolean hasName();\npublic java.lang.String getName();\npublic Builder setName(String value);\npublic Builder clearName();\n...\n```\n\n创建Person实例：\n```\nPerson john =\n  Person.newBuilder()\n    .setName(\"John Doe\")\n    .setAge(15)\n    .setEmail(\"jdoe@example.com\")\n    .build();\n```\n\n\bmessage类和Builder类中内建的其他方法：\n+ isInitialized(): checks if all the required fields have been set.\n+ toString(): returns a human-readable representation of the message, particularly useful for debugging\n+ mergeFrom(Message other): (builder only) merges the contents of other into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.\n+ clear(): (builder only) clears all the fields back to the empty state.\n\n### 解析和序列化\n\n+ byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes\n+ static Person parseFrom(byte[] data);: parses a message from the given byte array\n+ void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream\n+ static Person parseFrom(InputStream input);: reads and parses a message from an InputStream\n\n## 完整实例\n\n### \bwrite a message\n\n```\nimport com.example.tutorial.AddressBookProtos.AddressBook;\nimport com.example.tutorial.AddressBookProtos.Person;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nclass AddPerson {\n  // This function fills in a Person message based on user input.\n  static Person PromptForAddress(BufferedReader stdin,\n                                 PrintStream stdout) throws IOException {\n    Person.Builder person = Person.newBuilder();\n\n    stdout.print(\"Enter person ID: \");\n    person.setId(Integer.valueOf(stdin.readLine()));\n\n    stdout.print(\"Enter name: \");\n    person.setName(stdin.readLine());\n\n    stdout.print(\"Enter email address (blank for none): \");\n    String email = stdin.readLine();\n    if (email.length() > 0) {\n      person.setEmail(email);\n    }\n\n    while (true) {\n      stdout.print(\"Enter a phone number (or leave blank to finish): \");\n      String number = stdin.readLine();\n      if (number.length() == 0) {\n        break;\n      }\n\n      Person.PhoneNumber.Builder phoneNumber =\n        Person.PhoneNumber.newBuilder().setNumber(number);\n\n      stdout.print(\"Is this a mobile, home, or work phone? \");\n      String type = stdin.readLine();\n      if (type.equals(\"mobile\")) {\n        phoneNumber.setType(Person.PhoneType.MOBILE);\n      } else if (type.equals(\"home\")) {\n        phoneNumber.setType(Person.PhoneType.HOME);\n      } else if (type.equals(\"work\")) {\n        phoneNumber.setType(Person.PhoneType.WORK);\n      } else {\n        stdout.println(\"Unknown phone type.  Using default.\");\n      }\n\n      person.addPhones(phoneNumber);\n    }\n\n    return person.build();\n  }\n\n  // Main function:  Reads the entire address book from a file,\n  //   adds one person based on user input, then writes it back out to the same\n  //   file.\n  public static void main(String[] args) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"Usage:  AddPerson ADDRESS_BOOK_FILE\");\n      System.exit(-1);\n    }\n\n    AddressBook.Builder addressBook = AddressBook.newBuilder();\n\n    // Read the existing address book.\n    try {\n      addressBook.mergeFrom(new FileInputStream(args[0]));\n    } catch (FileNotFoundException e) {\n      System.out.println(args[0] + \": File not found.  Creating a new file.\");\n    }\n\n    // Add an address.\n    addressBook.addPeople(\n      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),\n                       System.out));\n\n    // Write the new address book back to disk.\n    FileOutputStream output = new FileOutputStream(args[0]);\n    addressBook.build().writeTo(output);\n    output.close();\n  }\n}\n```\n\n### read a message\n\n```\nimport com.example.tutorial.AddressBookProtos.AddressBook;\nimport com.example.tutorial.AddressBookProtos.Person;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nclass ListPeople {\n  // Iterates though all people in the AddressBook and prints info about them.\n  static void Print(AddressBook addressBook) {\n    for (Person person: addressBook.getPeopleList()) {\n      System.out.println(\"Person ID: \" + person.getId());\n      System.out.println(\"  Name: \" + person.getName());\n      if (person.hasEmail()) {\n        System.out.println(\"  E-mail address: \" + person.getEmail());\n      }\n\n      for (Person.PhoneNumber phoneNumber : person.getPhonesList()) {\n        switch (phoneNumber.getType()) {\n          case MOBILE:\n            System.out.print(\"  Mobile phone #: \");\n            break;\n          case HOME:\n            System.out.print(\"  Home phone #: \");\n            break;\n          case WORK:\n            System.out.print(\"  Work phone #: \");\n            break;\n        }\n        System.out.println(phoneNumber.getNumber());\n      }\n    }\n  }\n\n  // Main function:  Reads the entire address book from a file and prints all\n  //   the information inside.\n  public static void main(String[] args) throws Exception {\n    if (args.length != 1) {\n      System.err.println(\"Usage:  ListPeople ADDRESS_BOOK_FILE\");\n      System.exit(-1);\n    }\n\n    // Read the existing address book.\n    AddressBook addressBook =\n      AddressBook.parseFrom(new FileInputStream(args[0]));\n\n    Print(addressBook);\n  }\n}\n```\n\n# Flat Buffer\n\nFlatBuffers是一个跨平台的序列化库，旨在实现最高的内存效率。实现了与 Protocol Buffers，Thrift，Apache Avro，SBE 和 Cap'n Proto 类似的序列化格式。它允许我们直接访问序列化数据，而无需先解析/解压缩，同时仍具有良好的向前/向后兼容性。其最初为 Android 游戏和注重性能的应用而开发了FlatBuffers。\n\nFlatBuffers 的主要目标是避免反序列化。这是通过定义二进制数据协议来实现的，一种将定义好的将数据转换为二进制数据的方法。由该协议创建的二进制结构可以 wire 发送，并且无需进一步处理即可读取。相比较而言，在传输 JSON 时，我们需要将数据转换为字符串，通过 wire 发送，解析字符串，并将其转换为本地对象。Flatbuffers 不需要这些操作。你用二进制装入数据，发送相同的二进制文件，并直接从二进制文件读取。\n\n尽管 FlatBuffers 有自己的接口定义语言来定义要与之序列化的数据，但它也支持 Protocol Buffers 中的 .proto格式。\n\n在 schema 中定义对象类型，然后可以将它们编译为 C++ 或 Java 等各种主流语言，以实现零开销读写。FlatBuffers 还支持将 JSON 数据动态地分析到 buffer 中。\n\n除了解析效率以外，二进制格式还带来了另一个优势，数据的二进制表示通常更具有效率。我们可以使用 4 字节的 UInt 而不是 10 个字符来存储 10 位数字的整数。\n\nFlatBuffers 与 Protocol Buffers 确实比较相似，主要的区别在于 FlatBuffers 在访问数据之前不需要解析/解包。两者代码也是一个数量级的。但是 Protocol Buffers 既没有可选的文本导入/导出功能，也没有 union 这个语言特性，这两点 FlatBuffers 都有。\n\nFlatBuffers 专注于移动硬件（内存大小和内存带宽比桌面端硬件更受限制），以及具有最高性能需求的应用程序：游戏。\n\n## \b支持设备\nWindows、mmacOS、Linux、Android等\n\n## 支持语言\nPython、Java、c++等\n\n## \b使用步骤\n\n### 编写想要序列化的数据结构的schema（IDL,接口定义）文件\n```\n// example IDL file\n\nnamespace MyGame;\n\nattribute \"priority\";\n\nenum Color : byte { Red = 1, Green, Blue }\n\nunion Any { Monster, Weapon, Pickup }\n\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated, priority: 1);\n  inventory:[ubyte];\n  color:Color = Blue;\n  test:Any;\n}\n\nroot_type Monster;\n```\n在上述的schema文件中\b有两个重要的概念，struct和table。\n\n#### table\n\nTable 是在 FlatBuffers 中定义对象的主要方式，由一个名称（这里是 Monster）和一个字段列表组成。每个字段都有一个名称，一个类型和一个可选的默认值（如果省略，它默认为 0 / NULL）。\n\nTable 中每个字段都是可选 optional 的：它不必出现在 wire 表示中，并且可以选择省略每个单独对象的字段。这种设计也是 FlatBuffer 的前向和后向兼容机制。\n\n假设当前schema是这样的：\n```\ntable { a:int; b:int; }\n```\n\n##### 添加字段\n\n只能在表定义的末尾添加新的字段。旧数据仍会正确读取，并在读取时为您提供默认值。旧代码将简单地忽略新字段。如果希望灵活地使用 schema 中字段的任何顺序，您可以手动分配ids。  \n例如：  \n```\ntable { a:int; b:int; c:int; }\n或者\ntable { c:int (id: 2); a:int (id: 0); b:int (id: 1); }\n```\n##### 删除字段\n不能从 schema 中删除不再使用的字段，但可以简单地停止将它们写入数据中。此外，可以将它们标记为 deprecated，如上例所示，被标记的字段不会再生成 C ++ 的访问器，从而强制该字段不再被使用。\n\n##### 更改字段\n可以更改字段名称和 table 名称。\n```\ntable { a:uint; b:uint; }\n```\n直接修改字段的类型，这样做可能可行，也有情况不行。只有在类型改变是相同大小的情况下，是可行的。如果旧数据不包含任何负数，这将是安全的，如果包含了负数，这样改变会出现问题。\n```\ntable { a:int = 1; b:int = 2; }\n```\n这样修改不可行。任何写入数值为 0 的旧数据都不会再写入 buffer，并依赖于重新创建的默认值。现在这些值将显示为1和2。有些情况下可能不会出错，但必须小心。\n```\ntable { aa:int; bb:int; }\n```\n上面这种修改方法，修改原来的变量名以后，可能会出现问题。由于已经重命名了字段，这将破坏所有使用此版本 schema 的代码（和 JSON 文件），这与实际的二进制缓冲区不兼容。\n\ntable 是 FlatBuffers 的基石，因为对于大多数需要序列化应用来说，数据结构改变是必不可少的。通常情况下，处理数据结构的变更在大多数序列化解决方案的解析过程中可以透明地完成的。但是一个 FlatBuffer 在被访问之前不会被分析。\n\n为了解决数据结构变更的问题，table 通过 vtable 间接访问字段。每个 table 都带有一个 vtable（可以在具有相同布局的多个 table 之间共享），并且包含存储此特定类型 vtable 实例的字段的信息。vtable 还可能表明该字段不存在（因为此 FlatBuffer 是使用旧版本的软件编写的，仅仅因为信息对于此实例不是必需的，或者被视为已弃用），在这种情况下会返回默认值。\n\ntable 的内存开销很小（因为 vtables 很小并且共享）访问成本也很小（间接访问），但是提供了很大的灵活性。table 甚至可能比等价的 struct 花费更少的内存，因为字段在等于默认值时不需要存储在 buffer 中。\n\n#### structs\n\ntructs 和 table 非常相似，只是 structs 没有任何字段是可选的（所以也没有默认值），字段可能不会被添加或被弃用。结构可能只包含标量或其他结构。如果确定以后不会进行任何更改。structs 使用的内存少于 table，并且访问速度更快（它们总是以串联方式存储在其父对象中，并且不使用虚拟表）。  \n\nstructs 不提供前向/后向兼容性，但占用内存更小。对于不太可能改变的非常小的对象（例如坐标对或RGBA颜色）存成 struct 是非常有用的。\n\n#### Types\n\nFlatBuffers 支持的 标量 类型有以下几种：\n\n+ 8 bit: byte (int8), ubyte (uint8), bool\n+ 16 bit: short (int16), ushort (uint16)\n+ 32 bit: int (int32), uint (uint32), float (float32)\n+ 64 bit: long (int64), ulong (uint64), double (float64)\n\n括号里面的名字对应的是类型的别名。\n\nFlatBuffers 支持的 非标量 类型有以下几种：\n\n+ 任何类型的数组。不过不支持嵌套数组，可以用 table 内定义数组的方式来取代嵌套数组。\n+ UTF-8 和 7-bit ASCII 的字符串。其他格式的编码字符串或者二进制数据，需要用 [byte] 或者 [ubyte] 来替代。\n+ table、structs、enums、unions\n\n标量类型的字段有默认值，非标量的字段(string/vector/table)如果没有值的话，默认值为 NULL。\n\n一旦一个类型声明了，尽量不要改变它的类型，一旦改变了，很可能就会出现错误。上面也提到过了，如果把 int 改成 uint，数据如果有负数，那么就会出错。\n\n#### Enums\n定义一系列命名常量，每个命名常量可以分别给一个定值，也可以默认的从前一个值增加一。默认的第一个值是 0。正如在上面例子中看到的枚举声明，使用:(上面例子中是 byte 字节）指定枚举的基本整型，然后确定用这个枚举类型声明的每个字段的类型。\n\n通常，只应添加枚举值，不要去删除枚举值（对枚举不存在弃用一说）。这需要开发者代码通过处理未知的枚举值来自行处理向前兼容性的问题\n\n#### Unions\n这个是 Protocol buffers 中还不支持的类型。\n\nunion 是 C 语言中的概念，一个 union 中可以放置多种类型，共同使用一个内存区域。\n\n但是在 FlatBuffers 中，Unions 可以像 Enums 一样共享许多属性，但不是常量的新名称，而是使用 table 的名称。可以声明一个 Unions 字段，该字段可以包含对这些类型中的任何一个的引用，即这块内存区域只能由其中一种类型使用。另外还会生成一个带有后缀 _type 的隐藏字段，该字段包含相应的枚举值，从而可以在运行时知道要将哪些类型转换为类型。\n\nunion 跟 enum 比较类似，但是 union 包含的是 table，enum 包含的是 scalar或者 struct。\n\nUnions 是一种能够在一个 FlatBuffer 中发送多种消息类型的好方法。请注意，因为union 字段实际上是两个字段(有一个隐藏字段)，所以它必须始终是表的一部分，它本身不能作为 FlatBuffer 的 root。\n\n### 使用flatc编译\n\n使用FlatBuffer编译器flatc生成数据结构源代码（C++头文件或者Java类）\n\n### 使用相关接口读取或写入flat buffer\nhttps://github.com/google/flatbuffers/blob/master/tests/JavaTest.java\n\n# Protocol Buffer 与 Flat Buffer\n\n+ 弃用的字段，不用手动分配字段的 ID。在 .proto 中扩展一个对象，需要在数字中寻找一个空闲的空位（因为 protocol buffers 有更紧凑的表示方式，所以必须选择更小的数字）。除了这点不方便之外，它还使得删除字段成为问题：如果保留它们，从语意表达上不是很明显的表达出这个字段不能读写了，保留它们，还会生成访问器。如果删除它们，就会有出现严重 bug 的风险，因为当有人重用了这些 ID，会导致读取到旧的数据，这样数据会发生错乱。\n+ FlatBuffers 区分 table 和 struct。所有 table 字段都是可选的，并且所有 struct 字段都是必需的。\n+ FlatBuffers 具有原生数组类型而不是 repeated。这给你一个长度，而不必收集所有项目，并且在标量的情况下提供更紧凑的表示，并且确保相邻性。\n+ FlatBuffers 具有 union 类型，这个也是 protocol buffers 没有的。一个 union 可以替代很多个 optional 字段，这样也可以节约每个字段都要一一检查的时间。\n+ FlatBuffers 能够为所有标量定义默认值，而不必在每次访问时处理它们的 optional，并且默认值不存在 buffer 中，也不用担心空间的问题。\n+ 可以统一处理模式和数据定义（并且和 JSON 兼容）的解析器。protocol buffers 不兼容 JSON。FlatBuffers 的 flatc 编译器可带的参数也更加强大，具体可带参数列表见此文档\n+ schema 扩展了一些 protocol buffers 没有的 Attributes\n\n除去功能上的不同，再就是一些 schema 语法上的细微不同：\n\n+ 定义对象，protocol buffers 是 message，FlatBuffers 是 table\n+ ID，protocol buffers 默认是从 1 开始标号，FlatBuffers 默认从 0 开始\n","tags":["Protocol BUffer","Flat Buffer"],"categories":["数据包分析"]},{"title":"wireshark数据包分析","url":"/2019/01/07/wireshark数据包分析/","content":"\n## TCP报文\n\nTCP：（TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP 是面向连接的所以只能用于点对点的通讯）源IP地址：发送包的IP地址；目的IP地址：接收包的IP地址；源端口：源系统上的连接的端口；目的端口：目的系统上的连接的端口。  TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN，ACK。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。第一次握手：建立连接时，客户端发送SYN包(SEQ=x)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN(ACK=x+1),同时自己也送一个SYN包(SEQ=y),即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=y+1),此包发送完毕，客户端和服务器进入Established状态，完成三次握手\n\n### 封包详细信息\n![image](https://img-blog.csdn.net/20170114092218164)\nA. 第一行，帧Frame 36838 指的是要发送的数据块，其中，所抓帧的序号为36838，捕获字节数等于传送字节数：70字节；\n\nB. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为88:5d:90:00:00:25；目标Mac地址为00:25:22:b5:b9:92；\n\nC. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.21.175；目标IP地址为192.168.21.156；\n\nD. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(10086)；目标端口(50132)；序列号(1361)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为16；\n\nE. 第五行，数据共有16字节\n\n#### Frame信息分析\n![image](https://img-blog.csdn.net/20170114104835215)\nA. Arrival Time：到达时间，值为Jan 14, 2017 08:52:56.239204000\n\nB. EPoch Time：信息出现时间，值为1484355176.239204000秒\n\nC. [ Time delta from previous captured frame: 0.001472000 seconds] ：与之前捕获的数据帧时间差：0.001472000秒；\n\n     [Time delta from previous displayed frame: 0.001472000 seconds]：与之前显示的帧时间差： 0.001472000秒；\n\n     [Time since reference or first frame: 1278.276505000 seconds]：距参考帧或第一帧的时间差：1278.276505000秒；\n\nD. Frame Number: 36838，帧编号为36838；\n\nE. Frame Length: 70 bytes (560 bits)，帧长度为70字节；\n\n     Capture Length: 70 bytes (560 bits)，捕获到的长度为70字节；\n\nF. [Frame is marked: False]，帧标记：无；\n\n     [Frame is ignored: False]，帧被忽略：无；\n\nG. [Protocols in frame: eth:ip:tcp:data]，协议帧：eth(以太网)、IP、tcp、data\n\nH. [Coloring Rule Name: TCP]，色彩规则名称：TCP；\n\n     [Coloring Rule String: tcp]，色彩规则字符串：TCP；\n\n#### Ethernet II信息分析\n![iamge](https://img-blog.csdn.net/20170114111317125)\nA. Destination: AsrockIn_b5:b9:92 (00:25:22:b5:b9:92)，目标Mac地址为00:25:22:b5:b9:92\n\nB. Source: 88:5d:90:00:00:25 (88:5d:90:00:00:25)，源Mac地址为88:5d:90:00:00:25\n\nC. Type: IP (0x0800)，类型是IP数据包\n\n#### Ipv4协议信息分析\n\n![image](https://img-blog.csdn.net/20170114112410438)\n\nA. Version: 4，IP协议版本为IPv4；\n\n     Header length: 20 bytes，头部数据长度为20字节；\n\nB. Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))，区分的服务领域：0x00 (默认的是DSCP：0x00)；\n\nC. Flags: 0x02 (Don't Fragment)，不支持分组；\n\n     Fragment offset: 0，分组偏移量为0； \n\nD. Time to live: 64，TTL，生存时间为64，TTL通常表示包在被丢弃前最多能经过的路由器个数，当数据包传输到一个路由器之后，TTL就自动减1，如果减到0了还没有传送到目标主机，那么就自动丢失。\n\nE. Header checksum: 0xcebd [correct]，头部校验和\n\nF. Source: 192.168.21.175 (192.168.21.175)，源IP地址为192.168.21.175；\n\n     Destination: 192.168.21.156 (192.168.21.156)，目标IP地址为192.168.21.156\n\n#### Trasmission Control Protocol信息分析\n\n其中，对应的TCP首部的数据信息\n![image](https://img-blog.csdn.net/20170114093029919)\n\nA. 端口号，数据传输的16位源端口号和16位目标端口号(用于寻找发端和收端应用进程)；\n\nB. 相对序列号，该数据包的相对序列号为1361(此序列号用来确定传送数据的正确位置，且序列号用来侦测丢失的包)；下一个数据包的序列号是1377；\n\nC. Acknowledgment number是32位确认序列号，值等于1表示数据包收到，确认有效；\n\nD. 手动的数据包的头字节长度是20字节；\n\nE. Flags，含6种标志；ACK：确认序号有效；SYN：同步序号用来发起一个连接；FIN：发端完成发送任务；RST：重新连接；PSH：接收方应该尽快将这个报文段交给应用层；URG：紧急指针(urgentpointer)有效；\n\nF. window，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65536字节，上面显示窗口大小为1825字节；\n\nG. Checksum，16位校验和，检验和覆盖了整个的TCP报文段，由发端计算和存储，并由收端进行验证\n\n#### Data信息分析\n![image](https://img-blog.csdn.net/20170114114030332)\n\nA.  TCP 报文段中的数据(该部分是可选的)，长度为16字节；\n\n## Http报文\n\n链路层的信息上是以帧的形式进行传输的，帧封装了应用层、传输层、网络层的数据。而Wireshark抓到的就是链路层的一帧；\n\n### 封装包详细信息\n![image](https://img-blog.csdn.net/20170114120559104)\n\nA. 第一行，帧Frame 12411 指的是要发送的数据块，其中，所抓帧的序号为12411，捕获字节数等于传送字节数：233字节；\n\nB. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；\n\nC. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为220.181.57.234；目标IP地址为192.168.21.156；\n\nD. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(80)；目标端口(53985)；序列号(1)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为179；\n\nE. 第五行，Http协议，也称超文本传输协议，是应用层\n\n#### Http请求报文分析\n\n![image](https://img-blog.csdn.net/20170114135028036)\n\n报文分析：  \n![image](https://img-blog.csdn.net/20170114135154140)\n\n在抓包分析过程中还发现了另外一些http请求报文中所特有的首部字段名，比如下面http请求报文中橙黄色首部字段名：\n\n![image](https://img-blog.csdn.net/20170114135419581)\n\n#### Http响应报文信息\n\n![image](https://img-blog.csdn.net/20170114134516128)\n\n报文分析：  \n\n![image](https://img-blog.csdn.net/20170114134622379)\n\n## DNS报文\n\n### 封包详细信息\n\n![image](https://img-blog.csdn.net/20170114140200794)\n\nA. 第一行，帧Frame 12237 指的是要发送的数据块，其中，所抓帧的序号为12237，捕获字节数等于传送字节数：133字节；\n\nB. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；\n\nC. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.211.254；目标IP地址为192.168.211.84；\n\nD. 第四行，UDP协议，是传输层；源端口domain(53)；目标端口(65219)；\n\nE. 第五行，DNS协议，是应用层。\n\n#### DNS\b查询报文\n\n![iamge](https://img-blog.csdn.net/20170114141159062)\n\n报文分析：  \n![image](https://img-blog.csdn.net/20170114141447421)\n\n\n#### DNS响应报文\n\n![iamge](https://img-blog.csdn.net/20170114141637002)\n\n报文分析：  \n\n![image](https://img-blog.csdn.net/20170114142315693)\n\n\n## Ping\n\n![image](https://img-blog.csdn.net/20170118162817190)","tags":["wireshark","数据包"],"categories":["数据包分析"]},{"title":"数据包分析基础","url":"/2019/01/07/数据包分析基础/","content":"\n## http2协议\n\nhttp2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。\n\nhttp/2源于SPDY，但仍有不同的地方，主要是以下两点：\n\n+ HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\n+ HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT\n\n\n注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。\n\n## 二进制格式\n\nHTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。\nHTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。\n帧（Frame）：HTTP/2 数据通信的最小单位。\n消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成\n流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。\n\nHTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\nFrame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f)\n\n## http2的\b影响\n\n现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。\n\nhttp2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。\n\n它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。\n\n合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。\n\n所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。\n\n但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。\n\n## 集线器、交换机、路由器\n### 集线器\n\n集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。\n\n集线器为**共享式带宽**，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。\n\n集线器**不能判断数据包的目的地和类型**，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。\n\n### 交换机\n\n交换机工作\b在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。\n\n有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。\n\n高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。\n\n### 路由器\n\n路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。\n\n在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。\n\n## 数据包回放\n### 工具\n\n|name|complete connection|stateful|selected replay|\n|-|-|-|-|-|\nTCPReplay|No Required|No|No\nTomahawk|Required|Yes|No\nMokey|No Required|Yes|No\nAvalanche|Required|Yes|No\nSocketReplay|No Required|Yes|Yes\n\n### TcpReplay\nTcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：\n+  Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件\n\n+  Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息\n\n+  Tcpreplay:以可控的速度将pcap文件回放到网络中\n\n+  Tcpreplay-edit:在tcpreplay基础上增加编辑功能\n\n+  Tcpbirdge:桥接两个不同网段\n\n+  Tcpcapinfo:pcap 文件解码器和编译器\n\n原文链接：https://www.cnblogs.com/jiayy/p/3447027.html\n\n\n","tags":["http","http2","数据包回放"],"categories":["数据包分析"]},{"title":"http2协议、数据包回放","url":"/2019/01/07/http-http2协议/","content":"\n## http2协议\n\nhttp2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。\n\nhttp/2源于SPDY，但仍有不同的地方，主要是以下两点：\n\n+ HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\n+ HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT\n\n\n注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。\n\n## 二进制格式\n\nHTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。\nHTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。\n帧（Frame）：HTTP/2 数据通信的最小单位。\n消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成\n流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。\n\nHTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\nFrame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f)\n\n## http2的\b影响\n\n现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。\n\nhttp2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。\n\n它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。\n\n合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。\n\n所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。\n\n但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。\n\n## 集线器、交换机、路由器\n### 集线器\n\n集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。\n\n集线器为**共享式带宽**，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。\n\n集线器**不能判断数据包的目的地和类型**，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。\n\n### 交换机\n\n交换机工作\b在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。\n\n有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。\n\n高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。\n\n### 路由器\n\n路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。\n\n在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。\n\n## 数据包回放\n### 工具\n\n|name|complete connection|stateful|selected replay|\n|-|-|-|-|-|\nTCPReplay|No Required|No|No\nTomahawk|Required|Yes|No\nMokey|No Required|Yes|No\nAvalanche|Required|Yes|No\nSocketReplay|No Required|Yes|Yes\n\n### TcpReplay\nTcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：\n+  Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件\n\n+  Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息\n\n+  Tcpreplay:以可控的速度将pcap文件回放到网络中\n\n+  Tcpreplay-edit:在tcpreplay基础上增加编辑功能\n\n+  Tcpbirdge:桥接两个不同网段\n\n+  Tcpcapinfo:pcap 文件解码器和编译器\n\n原文链接：https://www.cnblogs.com/jiayy/p/3447027.html\n\n\n","tags":["http","http2","数据包回放"],"categories":["数据包分析"]},{"title":"现代密码学基础六","url":"/2019/01/06/现代密码学基础六/","content":"\n## 攻击模式\n\n在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。\n\n这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类\n\n+ 唯密文攻击：攻击者仅能获得一些加密过的密文。\n+ 已知明文攻击：攻击者有一些密文对应的明文。\n+ 选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。\n+ 选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。\n+ 相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后+ 的密文或明文。但是攻击者不知道这些密钥。\n\n## 常见攻击方法\n根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有\n\n+ 暴力攻击\n+ 中间相遇攻击\n+ 线性分析\n+ 差分分析\n+ 不可能差分分析\n+ 积分分析\n+ 代数分析\n+ 相关密钥攻击\n+ 侧信道攻击\n","tags":["现代密码学","密码学攻击思路"],"categories":["密码学"]},{"title":"现代密码学基础五","url":"/2019/01/06/现代密码学基础五/","content":"\n## 数字签名\n\n在计算机世界中，我们可能会需要电子签名，因为我们大多数情况下会使用电子文件，那这时候怎么办呢？当然，我们仍然可以选择使用自己的名字。但其实还有另外一种方式，那就是采用数字签名，这种签名更加难以伪造，可信程度更高。数字签名的主要用处是确保消息确实来自于声称产生该消息的人。\n\n数字签名依赖于非对称密码，因为我们必须确保一方能够做的事情，而另一方不能够做出这样的事情。其基本原理如下\n\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/signature/figure/Digital_Signature_diagram.png)\n\n### RSA数字签名\n原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名。\n\n### DSA数字签名\n\n//TODO\n\n\n## 证书格式\n\n### DER\n使用该扩展名的证书采用**二进制编码**，当然，这些证书也可以使用 CER 或者 CRT 作为扩展名。\n\n### PEM\n使用该扩展名的证书采用 Base64 编码，文件的开始是一行 -----BEGIN。\n\n### 格式转换\n\n```\nopenssl x509 -outform der -in certificate.pem -out certificate.der\nopenssl x509 -inform der -in certificate.cer -out certificate.pem\n```\n\n","tags":["现代密码学","数字签名","证书格式"],"categories":["密码学"]},{"title":"现代密码学基础四","url":"/2019/01/06/现代密码学基础四/","content":"\n## 哈希函数\n哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。\b其一般模型如下：\n```\n任意长度(m)消息 -> hash散列函数 -> 固定长度h(m)\n```\n\n显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。\n\n散列值的目的如下\n\n+ 确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。\n+ 冗余校验\n+ 单向口令文件，比如 linux 系统的密码\n+ 入侵检测和病毒检测中的特征码检测\n\n目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。\n\n|算法类型\t|输出 Hash 值长度\n|-|-|\nMD5\t|128 bit / 256 bit\nSHA1 |\t160 bit\nSHA256\t| 256 bit\nSHA512 |\t512 bit\n\n\n\n","tags":["现代密码学","哈希函数"],"categories":["密码学"]},{"title":"现代密码学基础三","url":"/2019/01/05/现代密码学基础三/","content":"\n## 非对称加密\n\n### 简介\n在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。\n\n### RSA\nRSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n\nRSA 算法的可靠性由**极大整数因数分解**的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。\n\n#### 基本原理\n\n##### 公钥与私钥的产生\n\n+ 随机选择两个不同大质数p和q，计算N=pxq\n+ 根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)\n+ 选择一个小于r的整数e，使e和r互质。并求得e关于r的模反元素，命名为d，有ed≡1(mod r)。\n+ 将p和q的记录销毁。\n\n此时，(N,e)是公钥，(N,d)是私钥。\n\n注：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler's totient function)，它又称为Euler's totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。\n\n##### 消息加密\n\n首先需要将消息 m以一个双方约定好的格式转化为一个小于 N，且与N\n互质的整数 n。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：\n$n^e$ ≡ c (mod N)\n\n##### 消息解密\n\n利用密钥 d进行解密。\n$c^d$ ≡ n (mod N)\n\n#### 基本工具\n\n+ RSAtool\n  + 安装\n    ```\n    git clone https://github.com/ius/rsatool.git\n    cd rsatool\n    python rsatool.py -h\n    ```\n  + 生成私钥\n\n    ```\n    python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321\n    ```\n+ RSA Converter\n  + 根据给定的密钥对，生成pem文件\n  + g根据n,e,d，生成p,q\n+ openssl\n  + 查看公钥\b文件\n\n    ```\n    openssl rsa -pubin -in pubkey.pem -text -modulus\n    ```\n  + 解密\n    ```\n    rsautl -decrypt -inkey private.pem -in flag.enc -out flag\n    ```\n+ 分解整数工具\n  + 网站分解http://factordb.com/ \n  + 命令\b行分解https://github.com/ryosan-470/factordb-pycli借用 factordb 数据库。\n  + https://sourceforge.net/projects/yafu/\n\n+ python库\n  + primefac\n    整数分解库，包含了很多整数分解的算法。\n  + gmpy\n  + gmpy2\n    安装时，可能会需要自己另行安装 mfpr 与 mpc 库。\n  + pycrypto\n\n#### 侧信道攻击\n\n能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。\n\n能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。\n\n能量分析攻击分为： \n- 简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 \n- 差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。\n\n##### 攻击条件\n\n攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。\n\n### 背包加密\n\n#### 背包\b问题\n\n首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $1_1$,$a_2$,...,$a_n$\n 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题：  \n $x_1$$a_1$+$x_2$$a_2$+...+$x_n$$a_n$ = W\n\n \b其中$x_i$只能为0和1，显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。\n\n 在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$,即可得到加密结果。\n\n 但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。\n\n但是当$a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件：第 i 个数大于前面所有数的和。\n\n为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。\n\n### ECC\n\nECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有\n\n+ 以素数为模的整数域 GF(p)，通常在通用处理器上更为有效。\n+ 特征为 2 的伽罗华域 GF（2^m），可以设计专门的硬件。\n\n### 格密码\n\n格在数学上至少有两种含义\n\n+ 定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见 https://en.wikipedia.org/wiki/Lattice_(order)。\n+ 群论中的定义，是 [Math Processing Error] 中的满足某种性质的子集。当然，也可以是其它群。\n\n\n\n\n\n\n","tags":["现代密码学","非对称加密"],"categories":["密码学"]},{"title":"现代密码学基础二","url":"/2019/01/04/现代密码学基础二/","content":"\n## 块密码\n\n### 概述\n所谓块加密就是每次加密一块明文，常见的加密算法有\n\n+ IDEA 加密\n+ DES 加密\n+ AES 加密\n\n块加密也是对称加密。\n\n其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有**复杂**的加解密算法来加解密明密文。\n\n而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助\n\n+ padding，即 padding 到指定分组长度\n+ 分组加密模式，即明文分组加密的方式。\n\n### 基本策略\n\n在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。\n\n#### 混淆 \n混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下\n\n+ S 盒\n+ 乘法\n\n#### 扩散\n\n扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有\n\n+ 线性变换\n+ 置换\n+ 移位，循环移位\n\n### 常见加解密结构\n\n目前块加密中主要使用的是结构是\n\n+ 迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。\n\n#### 迭代结构\n\n##### 概述\n迭代结构基本如下，一般包括三个部分\n\n+ 密钥置换\n+ 轮加密函数\n+ 轮解密函数\n\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/figure/iterated_cipher.png)\n\n##### 轮函数\n\n目前来说，轮函数主要有主要有以下设计方法\n\n+ Feistel Network，由 Horst Feistel 发明，DES 设计者之一。\n  + DES\n+ Substitution-Permutation Network(SPN)\n  + AES\n+ 其他方案\n\n注：费思妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。因此，实现这种密码所需的代码或电路大小能几乎减半。费斯妥网络是一种迭代密码，其中的内部函数称为轮函数。\n\n注：代换-置换网络是一系列被应用于分组密码中相关的数学运算，代换（Substitution）和置换（Permutation）分别被称作S盒（替換盒，英语：S-boxes）和P盒（排列盒，英语：P-boxes）。这种加密网络使用明文和密钥作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文。\n\n##### 密钥扩展\n目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。\n\n### 常见块加密算法\n//TODO(ARX/DES/IDEA/AES/Simon and Speck)\n\n### 分组模式\n\n分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。\n\n#### 填充规则\n\n正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。\n\n常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。\n\n一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。\n\nPad with bytes all of the same value as the number of padding bytes (PKCS5 padding)\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\nPad with 0x80 followed by zero bytes (OneAndZeroes Padding)\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n这里其实就是和 md5 和 sha1 的 padding 差不多。\n\nPad with zeroes except make the last byte equal to the number of padding bytes\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\nPad with zero (null) characters\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\nPad with spaces\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n#### ECB模式\nECB 模式全称为电子密码本模式（Electronic codebook）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_decryption.png)\n\n##### 优点\n+ 实现简单。\n+ 不同明文分组的加密可以并行计算，速度很快。\n\n##### 缺点\n+ 同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_bad_linux.png)\n\n为了解决统一明文产生相同密文的问题，提出了其它的加密模式。\n\n##### 应用\n+ 用于随机数的加密保护。\n+ 用于单分组明文的加密。\n\n#### CBC模式\nCBC 全称为密码分组链接（Cipher-block chaining） 模式，这里\n\n+ IV 不要求保密\n+ IV 必须是不可预测的，而且要保证完整性。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_decryption.png)\n##### 优点 \n+ 密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。\n+ 具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。\n+ 具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。\n##### 缺点\n+ 加密不能并行，解密可以并行。\n\n##### 应用\n+ 常见的数据加密和 TLS 加密。\n+ 完整性认证和身份认证。\n\n##### 攻击\n+ 字节反转攻击\n  + IV 向量，影响第一个明文分组\n  + 第 n 个密文分组，影响第 n + 1 个明文分组\n+ Padding Oracle Attack，具体参见下面介绍\n\n#### PCBC模式\nPCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_decryption.png)\n\n##### 特点\n+ 解密过程难以并行化\n+ 互换邻接的密文块不会对后面的密文块造成影响\n\n#### CFB模式\nCFB 全称为密文反馈模式（Cipher feedback）。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_decryption.png)\n\n##### 优点\n+ 适应于不同数据格式的要求\n+ 有限错误传播\n+ 自同步\n##### 缺点\n+ 加密不能并行化，解密不能并行\n\n##### 应用\n该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。\n\n#### OFB模式\nOFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_decryption.png)\n\n##### 优点\n+ 不具有错误传播特性。\n##### 缺点\n+ IV 无需保密，但是对每个消息必须选择不同的 IV。\n+ 不具有自同步能力。\n\n##### 应用\n适用于一些明文冗余度比较大的场景，如图像加密和语音加密。\n\n#### CTR模式\nCTR 全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。\n\n##### 加密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png)\n##### 解密\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png)\n\n#### Padding Oracle Attack\n\nPadding Oracle Attack 攻击一般需要满足以下几个条件\n\n+ 加密算法\n  + 采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。\n  + 分组模式为 CBC 模式。\n+ 攻击者能力\n  + 攻击者可以拦截上述加密算法加密的消息。\n  + 攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。\n\nPadding Oracle Attack 攻击可以达到的效果如下\n+ 在不清楚 key 和 IV 的前提下解密任意给定的密文。\n\n","tags":["现代密码学","块密码"],"categories":["密码学"]},{"title":"现代密码学基础一","url":"/2019/01/04/现代密码学基础一/","content":"\n## 流密码\n流密码一般逐字节或者逐比特处理信息。一般来说：\n+ 流密码的密钥长度会与明文的长度相同。\n+ 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。\n\n需要注意的是，流加密目前来说都是对称加密。\n\n伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。\n\n流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。\n\n流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。\n\n### 伪随机数生成器\n伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。\n\n就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。\n\n#### 随机性的严格性\n+ 随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。\n+ 不可预测性：不能从过去的序列推测出下一个出现的数。\n+ 不可重现性：除非数列保存下来，否则不能重现相同的数列。\n\n这三个性质的严格性依次递增。\n\n一般来说，随机数可以分为三类\n\n|类别|随机性|不可预测性|不可重现性|\n|-|-|-|-|\n|弱伪随机数|✅|❌|❌|\n|强伪随机数|✅|✅|❌|\n|真随机数|✅|✅|✅|\n\n一般来说，密码学中使用的随机数是第二种。\n\n#### 周期\n正如我们之前所说，一旦 PRNG 所依赖的种子确定了，那么 PRNG 生成的随机数序列基本也就确定了。这里定义 PRNG 的周期如下：对于一个 PRNG 的所有可能起始状态，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的(一般性限制条件)。\n\n#### 分类\n目前通用的伪随机数生成器主要有：\n+ 线性同余生成器，LCG\n+ 线性回归发生器\n+ 线性反馈移位寄存器（Linear feedback shift register，LFSR）\n+ Mersenne Twister\n+ xorshift generators\n+ WELL family of generators\n\n#### 问题\n通常来说，伪随机数生成器可能会有以下问题：  \n+ 在某些种子的情况下，其生成的随机数序列的周期会比较小。\n+ 生成大数时，分配的不均匀。\n+ 连续值之间关联密切，知道后续值，可以知道之前的值。\n+ 输出序列的值的大小很不均匀。\n\n### 密码安全伪随机数数生成器\n密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator，CSPRNG），也称为密码学伪随机数生成器（cryptographic pseudo-random number generator，CPRNG)，是一种特殊的伪随机数生成器。它需要满足满足一些必要的特性，以便于适合于密码学应用。\n\n密码学的很多方面都需要随机数：\n+ 密钥生成\n+ 生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式\n+ nonce，用于防止重放攻击以及分组密码的 CTR 模式等、\n+ one-time pads\n+ 某些签名方案中的盐，如 ECDSA， RSASSA-PSS\n\n注：在资讯安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。\n\n#### 需求\n毫无疑问，密码学安全伪随机数生成器的要求肯定比一般的伪随机数生成器要高。一般而言，CSPRNG 的要求可以分为两类\n\n+ 通过统计随机性测试。CSPRNG 必须通过 next-bit test，也就是说，知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于 50% 的概率预测出来下一个比特位。这里特别提及一点，姚期智曾在 1982 年证明，如果一个生成器可以通过 next-bit test，那么它也可以通过所有其他的多项式时间统计测试。\n+ 必须能够抵抗足够强的攻击，比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。\n\n#### 分类\n就目前而看， CSPRNG 的设计可以分为以下三类\n+ 基于密码学算法，如密文或者哈希值。\n+ 基于数学难题\n+ 某些特殊目的的设计\n\n### 反馈移位寄存器\n一般的，一个 n 级反馈移位寄存器如下图所示\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBc234f54efe1a0af70602bf1974c14605?method=download&shareKey=415fcf56b93e427f2b1df0417a1add43)\n+ $a_0$,$a_1$,...,$a_{n-1}$为初态。\n+ F为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。\n+ $a_{i+n}$=F($a_i$,$a_{i+1}$,...,$a_{i+n-1}$)\n\n一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即\n\n($a_i$,$a_{i+1}$,...,$a_{i+n-1}$) -> ($a_{i+1}$,..,$a_{i+n-1}$,$a_{i+n}$),对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。\n\n#### 非线性反馈寄存器\n//TODO\n\n### 特殊流密码-RC4\nRSA 由 Ron Rivest 设计，最初隶属于 RSA 安全公司，是一个专利密码产品。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。\n\nRC4 主要包含三个流程：  \n+ 初始化 S 和 T 数组。\n+ 初始化置换 S。\n+ 生成密钥流。\n\n#### 初始化 S 和 T 数组 \n```\nfor i = 0 to 255 do\n    S[i] = i\n    T[i] = K[i mod keylen])\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s_t.png)\n#### 初始化置换 S\n```\nj = 0\nfor i = 0 to 255 do \n    j = (j + S[i] + T[i]) (mod 256) \n    swap (S[i], S[j])\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s.png)\n#### 生成流密钥\n```\ni = j = 0 \nfor each message byte b\n    i = (i + 1) (mod 256)\n    j = (j + S[i]) (mod 256)\n    swap(S[i], S[j])\n    t = (S[i] + S[j]) (mod 256) \n    print S[t]\n```\n![image](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_key.png)\n\n我们一般称前两部分为 KSA ，最后一部分是 PRGA。\n\n","tags":["现代密码学","流密码"],"categories":["密码学"]},{"title":"古典密码学基础三","url":"/2019/01/03/古典密码学基础三/","content":"\n### 培根密码\n培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。\n![image](https://note.youdao.com/yws/api/personal/file/WEB614471942b2a382c57f0cf2346e379a8?method=download&shareKey=3ce1ae584d6f0c4aaa50ad70471ac721)\n上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n\n下面这一段内容就是明文 steganography 使用\nTo encode a message each letter of the plaintext is replaced by a group of five of the letters 'A' or 'B'.\n加密后的内容，\b大写为A，小写为B。  \n|明文|s|t|e|g|a|n|o|g|r|a|p|h|y|\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\n|转换表|baaab|baaba|aabaa|aabba|aaaaa|abbaa|abbab|aabba|baaaa|aaaaa|abbba|aabbb|babba|\n|密文|tOENc|oDEaM|ESsAG|EEacH|LETTE|RofTH|EplAi|NTexT|iSREP|LACED|ByagR|OUpof|fIveL|\n\n可以看到，培根密码主要有以下特点：\n+ 只有两种字符（大小写，粗/正常题，斜/正常体等）\n+ 每一段的长度为5\n+ 加密内容会有特殊的字体之分，\b亦或大小写之分\n  \n工具：http://rumkin.com/tools/cipher/baconian.php\n\n### 栅栏密码\n栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子：  \n明文：THERE IS A CIPHER\n\n去掉空格后变为\n\n>THEREISACIPHER\n\n分成两栏，两个一组得到\n\n>TH ER EI SA CI PH ER\n\n先取出第一个字母，再取出第二个字母\n\n>TEESCPE  \nHRIAIHR\n\n连在一起就是\n\n>TEESCPEHRIAIHR\n\n上述明文也可以分为 2 栏。\n\n>THEREIS ACIPHER\n\n组合得到密文\n\n>TAHCEIRPEHIESR\n\n工具：http://ctf.ssleye.com/railfence.html\n\n### 曲路密码\n曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子：  \n>明文：The quick brown fox \njumps over the lazy dog\n\n填入 5 行 7 列表（事先约定填充的行列数）\n![image](https://note.youdao.com/yws/api/personal/file/WEBaab90fd8528f744a4b6e3ed6c78df86e?method=download&shareKey=cb2988f0247bbc4a64bb037340e21266)\n加密的回路线（事先约定填充的行列数）\n![image](https://note.youdao.com/yws/api/personal/file/WEB135692c80f25a4ec2cd7bf21aeecbdc9?method=download&shareKey=c983704ab96d9ddaadcfa3d7cf67ab6d)\n密文：gesfc inpho dtmwu qoury zejre hbxva lookT\n\n### 01248密码\n该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1->26 表示 A->Z。\n\n可以看出该密码有以下特点：\n+ 只有 0，1，2，4，8\n\n例如：8842101220480224404014224202480122\n\n按照0来分割：  \n|内容|数字|字符|\n|-|-|-|\n|88421|8+8+4+2+1=23|W|\n|122|1+2+2=5|E|\n|48|4+8=12|L|\n|2244|2+2+4+4=12|L|\n|4|4|D|\n|142242|1+4+2+2+4+2=15|0|\n|248|2+4+8=14|N|\n|122|1+2+2=5|E|\n明文：WELLDONE\n\n### JSFuck\nJSFuck 可以只用 6 个字符 []()!+ 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 alert(1) 代码如下：  \n>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]((![]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()\n\n其他一些基本的表达：\n```\nfalse       =>  ![]\ntrue        =>  !![]\nundefined   =>  [][[]]\nNaN         =>  +[![]]\n0           =>  +[]\n1           =>  +!+[]\n2           =>  !+[]+!+[]\n10          =>  [+!+[]]+[+[]]\nArray       =>  []\nNumber      =>  +[]\nString      =>  []+[]\nBoolean     =>  ![]\nFunction    =>  [][\"filter\"]\neval        =>  [][\"filter\"][\"constructor\"]( CODE )()\nwindow      =>  [][\"filter\"][\"constructor\"](\"return this\")()\n```\n工具：http://www.jsfuck.com\n\n### BrainFuck\nBrainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印 Hello World！，那么对应的程序如下：  \n```\n++++++++++[>+++++++>++++++++++>+++>+<<<<-]\n>++.>+.+++++++..+++.>++.<<+++++++++++++++.\n>.+++.------.--------.>+.>.\n```\n与其对应的还有 ook。\n\n工具：https://www.splitbrain.org/services/ook\n\n### 猪圈密码\n猪圈密码是一种以格子为基础的简单替代式密码，格子如下：  \n![image](https://note.youdao.com/yws/api/personal/file/WEB76a78a8b102de070a7fcdc8824660b2b?method=download&shareKey=71bed2948c5cec3dc77b6ce43c5967c0)\n例如：明文为 X marks the spot ，那么密文如下：  \n![image](https://note.youdao.com/yws/api/personal/file/WEB542ffbb69121a02be44c46268eae3bac?method=download&shareKey=188f938bab6d2ebea01940a2c755e75d)\n\n工具：http://www.simonsingh.net/The_Black_Chamber/pigpen.html\n\n### 舞动的小人密码 \n这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。\n![image](https://note.youdao.com/yws/api/personal/file/WEB0d432b9016f9d7f01d93260b1c0124d3?method=download&shareKey=dad1725328f62432fc4eb1f48d10f5bb)\n\n### 键盘密码\n所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。\n\n#### 手机键盘密码\n手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此。\n![image](https://note.youdao.com/yws/api/personal/file/WEB35c2548fd5300110899752984fa99371?method=download&shareKey=4008d4855211fc73f4597b224067d0b6)\n关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。\n#### 电脑键盘棋盘密码\n电脑键盘棋盘加密，利用了电脑的棋盘方阵。\n![iamge](https://note.youdao.com/yws/api/personal/file/WEB2e33ea38af7f4baf490ff9f39d715c9f?method=download&shareKey=3648b73f7f64573b1a572be93c70e8fb)\n\n#### 电脑键盘坐标密码\n电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBe0e36122c77aa2b4f9082895a8d6082b?method=download&shareKey=714cffcaddd3a713461ba4e51c85d471)\n\n#### 电脑键盘QWE\n电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBd5d37d656e0d67ee4d6abf87233c61d0?method=download&shareKey=5f547f51c40690833c88da1a7f3e0077)\n\n### CTF案例\n1. 0CTF 2014 classic\n>小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb\n\n发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到 0ops 字样，猜测就是 flag 了。\n\n2. 2017 年 xman 选拔赛——一二三，木头人 \n>我数 123 木头人，再不行动就要被扣分。\n>\n>23731263111628163518122316391715262121\n>\n>密码格式 xman{flag}\n题目中有很明显的提示 123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是 1-3 范围内的，也验证了我们的猜测。于是：  \n>23-x\n>\n>73-m\n>\n>12-a\n>\n>63-n\n>\n>11-q\n\n不对呀，密码格式是 xman{，第四个字符是 {，于是看了看 { 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么 111 就是 {。然后依次往后推，发现确实可行，，最后再把 121 视为 } 即可得到 flag.\n\n>xman{hintisenough}\n","tags":["古典密码学","其他类型密码"],"categories":["密码学"]},{"title":"古典密码学基础二","url":"/2019/01/03/古典密码学基础二/","content":"### 多表代换密码\n对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。\n\n#### 维吉尼亚密码\n维吉尼亚密码是广为人知的多表替换式密码，也称为多字母替换式密码。\n\n在一个凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E……而维吉尼亚密码则是由一些偏移量不同的恺撒密码组成。\n\n为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。\n\n例如：\n\n假设明文是ATTACKATDAWN，选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：LEMONLEMONLE\n\n对于明文的第一个字母A，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母L。类似地，明文第二个字母为T，在表格中使用对应的E行进行加密，得到密文第二个字母X。以此类推，可以得到：\n\n明文：ATTACKATDAWN  \n密钥：LEMONLEMONLE  \n密文：LXFOPVEFRNHR\n\n解密的过程则与加密相反。例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母L位于A列，因而明文第一个字母为A。密钥第二个字母E对应E行字母表，而密文第二个字母X位于此行T列，因而明文第二个字母为T。以此类推便可得到明文。\n\n用数字0-25代替字母A-Z，维吉尼亚密码的加密文法可以写成同余的形式：\n\n$C_i$=$P_i$+$K_i(mod\\ 26)$\n\n解密方法则能写成：\n\n$P_i$=$C_i$-$K_i(mod\\ 26)$","tags":["古典密码学","多表代换密码"],"categories":["密码学"]},{"title":"古典密码学基础一","url":"/2019/01/03/古典密码学基础/","content":"## 简介\n古典密码学是密码学中的其中一个类型，其大部分加密方式都是利用替换式密码或移项式密码，或者两者的混合。其与历史中经常使用，但现代已经很少使用，大部分已经不再使用。在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。\n。\n\n## 密码分类\n\n### 单表代换密码\n对字母做系统的替换，直到讯息被替换为难以理解的字。\n#### 凯撒密码\n凯撒密码是广为人知的单表式替换密码，它只使用一个密码字母集。\n\n为了使用凯撒密码加密讯息，每个密码字母集中字母将会被其位置的后三个字母替代。因此字母A將会被字母D替代、字母B將会被字母E替代、字母C將会被字母F替代等，最后，X、Y和Z將分別的被替代成A、B和C。例如，\"WIKIPEDIA\"將被加密成\"ZLNLSHGLD\"。凱撒把字母向后移\"3\"位，但其他数字也是类似。\n\n根据偏移量的不同，还存在若干特定的恺撒密码名称：\n+ 偏移量为 10：Avocat （A→K）\n+ 偏移量为 13：ROT13\n+ 偏移量为 -5：Cassis （K 6）\n+ 偏移量为 -6：Cassette （K 7）\n\n另一种替换式密码是使用关键字（等同于密钥），你可以选择一个字母或片段并去除所有的空格和重复字母，接着把它当做密码字母集的开头，把去除密钥后的其他字母接续排序。例如，如果关键字是cipher，则密码字母表会是下面的情况：\n\n一般密码字母集: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\n密钥密码字母集: c i p h e r s t u v w x y z a b d f g j k l m n o q\n\n还有一种基于密钥的凯撒密码，其基本原理是利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为密钥加密明文的每一位字母。例如：  \n密文：s0a6u3u1s0bv1a  \n密钥：guangtou  \n偏移：6,20,0,13,6,19,14,20  \n明文：y0u6u3h1y0uj1u  \n\n对于不带密钥的凯撒密码来说，破解方式有两种：  \n+ 遍历 26 个偏移量，适用于普遍情况。\n+ 在密文长度足够长的时候，使用词频分析https://quipqiup.com/\n\n其中，第一种方式肯定可以得到明文，而第二种方式则不一定可以得到正确的明文。\n\n而对于基于密钥的凯撒密码来说，一般来说必须知道对应的密钥。\n\n工具：  \n一般我们有如下的工具，其中 JPK 比较通用。\n+ JPK，可解带密钥与不带密钥\n+ http://planetcalc.com/1434/\n+ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php\n\n#### 简单替换密码\n简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。 比如：  \n明文字母 : abcdefghijklmnopqrstuvwxyz  \n密钥字母 : phqgiumeaylnofdxjkrcvstzwb\na 对应 p，d 对应 h，以此类推。  \n明文：the quick brown fox jumps over the lazy dog  \n密文：cei jvaql hkdtf udz yvoxr dsik cei npbw gdm  \n而解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。\n\n由于这种加密方式导致其所有的密钥个数是26!，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。\n\n工具：http://quipqiup.com/\n\n\n### 移位式密码\n与凯撒密码类似，区别在于移位密码不仅会处理字母，还会处理数字和特殊字符，常用 ASCII 码表进行移位。其破解方法也是遍历所有的可能性来得到可能的结果。\n\n#### \b纵线式移位密码\n一个移位式密码的具体例子就是纵线式移位密码。\b\b先\b选择一个关键字，把原来的讯息由左\b向右、由上到下依照关键字长度转写成长方形。接着把关键字的字母依照字母集顺序编号，例如a就是1，b就是2，c就是3等。例如：关键字是CAT，明文是THE SKY IS BLUE，则讯息应该被转换成：\n```   \n C A T  \n 3 1 20  \n T H E  \n S K Y  \n I S B  \n L U E  \n ```\n 最后把讯息以行为单位，依照编号大小调换位置，\b呈现的应该是 A为第一行，C为第二行，T为第三行。然后就可以把讯息转换成HKSUTSILEYBE\n\n#### 中国式密码\n 另外一种移位式密码是中国式密码，移位的方法是将讯息的字母加密成由右向左、上下交替的不规则的字母。例如，如果明文是THE DOG RAN FAR，则中国式密码看起来像这样：\n ```\n R  R   G   T\n A  A   O   H\n F  N   D   E   \n ```\n 密文将被\b是：RRGT AAOH FNDE\n\n#### \b艾特巴什码\n埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：  \n明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  \n密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A\n\b下面给出一个例子：  \n明文：the quick brown fox jumps over the lazy dog  \n密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt\n\n可以看出其密钥空间足够短，同时当密文足够长时，仍然可以采用词频分析的方法解决。\n\n工具：http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/\n\n### 仿射密码\n原理：  \n仿射密码的加密函数是 \nE(x)=(ax+b)(mod m)，其中：  \n+ x表示明文按照某种编码得到的数字\n+ a和m互质\n+ m是编码系统中字母的数目。\n\n解密函数是D(x)=$a^{-1}$(x-b)(mod m),其中$a^{-1}$是a在整数群的乘法逆元。例如：\n```   \n\b明文:A F F I N  E C I P H E R \nx:  0 5 5 8 13 4 2 8 15 7 4 17\ny=5x+8:8 33 33 48 73 28 18 48 83 43 28 93\ny mod 26:8 7 7 22 21 2 18 22 5 17 2 15 \n密文:I H H W V C S W F R C P\n```\n其对应的加密结果是 IHHWVCSWFRCP。\n\n对于解密过程，正常解密者具有 a 与 b，可以计算得到$a^{-1}$为 21，所以其解密函数是:D(x)=21(x-8)(mod 26)\n\n破解：  \n首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。\n\n其次，我们可以考虑如何攻击该密码。可以看出当a=1时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有 26 个字母，而不大于 26 的与 26 互素的个数一共有ϕ(26）=ϕ(2)Xϕ(13)=12,算上 b 的偏移可能，一共有可能的密钥空间大小也就是12×26=312 \n\n一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。\n\n这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。\n\n但是，假设我们已经知道采用的字母集，这里假设为 26 个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母$y_1$,$y_2$即可进行解密。那么我们还可以知道:  \n$y_1$=(a$x_1$+b)(mod 26)  \n$y_2$=(a$x_2$+b)(mod 26)  \n二者相减,可得：  \n$y_1$-$y_2$=a($x_1$-$x_2$)(mod 26)\n\n这里$y_1$,$y_2$已知，如果我们知道密文对应的两个不一样的字符$x_1$,$x_2$，那么我们就可以很容易得到 a，进而就可以得到 b了。\n\n ## 密码破译\n 经典密码通常很容易被破解。许多经典密码可单由密文而破解，所以它们容易遭受到唯密文攻击法攻击。有些经典密码（例如凯撒密码）的密钥个数有限，所以这类密码可以通过暴力破解尝试所有的密钥。替换式密码有较大的密钥数，但是很容易被频率分析，因为每个密码字母各代替了一个明文字母。多表式替换密码使用多个替换可防止简单的频率分析，但卡西斯基验、弗里德曼试验可用来破解这类密码。\n\n ### 卡西斯基试验\n 卡西斯基试验是基于类似the这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的CRYPTO可能被密钥ABCDEF加密成不同的密文：\n```\n密钥：ABCDEF AB CDEFA BCD EFABCDEFABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB\n```\n此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥ABCD）：\n```\n密钥：ABCDAB CD ABCDA BCD ABCDABCDABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASTP KV SIQUT GQU CSASTPIUAQJB\n```\n此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：  \n密文：**DYDUXRMH**TVDV**NQD**QNW**DYDUXRMH**ARTJGW**NQD**\n\n其中，两个DYDUXRMH的出现相隔了18个字母。因此，可以假定密钥的长度是18的约数，即长度为18、9、6、3或2。而两个NQD则相距20个字母，意味着密钥长度应为20、10、5、4或2。取两者的交集，则可以基本确定密钥长度为2。\n\n ### 弗里德曼试验\n它使用了重合指数（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。$k_p$指目标语言中两个任意字母相同的概率（英文中为0.067），$k_r$指字母表中这种情况出现的概率（英文中为1/26=0.0385），从而密钥长度可以估计为：  \n\n分子 = $k_p$-$k_r$\n\n分母 = $k_o$-$k_r$\n\n密钥长度 = $\\frac{分子}{分母}$\n\n此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。\n\n### 频率分析\n一旦能够确定密钥的长度，密文就能重新写成多列，列数与密钥长度对应。这样每一列其实就是一个凯撒密码，而此密码的密钥（偏移量）则对应于维吉尼亚密码密钥的相应字母。与破译凯撒密码类似的方法，就能将密文破译。\n\n柯克霍夫方法作为卡西斯基试验的改进，由奥古斯特·柯克霍夫（Auguste Kerckhoffs）提出。它将每一列的字母频率与转换后的明文频率相对应而得出每一列的密钥字母。一旦密钥中每一个字母都能确定，就能很简单地破译密文，从而得到明文。如果维吉尼亚字母表表格本身是杂乱而非按通常字母表顺序的话，那柯克霍夫方法就会无效，但卡西斯基试验和重复指数对于决定密钥长度仍旧是有效的。","tags":["古典密码学","单表代换密码"],"categories":["密码学"]},{"title":"Android编译器相关","url":"/2019/01/02/Android编译器相关/","content":"MIR -> LIR -> native code\n\nSSA：（编译器后端寄存器分配算法，static single assignment）静态单一复制法，是一种中间表示形式。\n之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。\n\n在某种程度上，可以认为MIR即为对dalvik指令进行SSA变换之后的指令形态。\n\n接着就调用cu.cg->Materialize()用来产生最终代码，其中重要的两个调用就是MethodMIR2LIR()和AssembleLIR()。\n通MethodMIR2LIR()将MIR转化为LIR，遍历每个BasicBlock，对每个基本块执行MethodBlockCodeGen，\n本质上最后是执行了CompileDalvikInstruction。CompileDalvikInstruction也就是通过解析指令，然后根据opcode进行分支判断，\n调用最终不同的指令生成函数，最后LIR之间也形成一个双向链表。最终将MIR转换为LIR。\n\nAssembleLIR()最终调用的是AssembleInstructions函数。程序中维护了一个编码指令表MipsMir2Lir::EncodingMap，\nAssembleInstructions即是通过查找这个表来进行翻译，将LIR转化为了MIPS指令，\n并将所翻译的指令存储到CodeBufferMir2Lir::code_buffer_之中。\n这样就完成了一次编译的完整流程。\n\n总结：\nMIR为对dalvik指令进行SSA变换之后的指令形态。\nLIR为对MIR形态的指令进行解析生成的另一种形态的指令。\nnative code为通过查找编码指令表将LIR形态的指令翻译为对应不同平台的汇编指令。","tags":["Android、compiler"]},{"title":"Android 逐步认识ART系列二","url":"/2018/12/28/Android-逐步认识ART系列二/","content":"\n# boot.oat\n\n- Contains libs and frameworks in boot class path\n    – To be pre-loaded in all apps（系统启动路径下的的需要预加载库和框架）\n\n任何应用程序都不是孤立存在的，几乎所有应用程序都会依赖Android Framework中提供的基础类，例如Activity，Intent，Parcel等类。所以在应用程序的代码中，自然少不了对于这些类的引用.\n\n考虑到几乎所有应用都存在这种引用关系，在运行时都会依赖于Framework中的类，因此系统如何处理这部分逻辑就是非常重要的了，因为这个处理的方法将影响到所有应用程序。\n\n在AOSP编译时，会将所有这些公共类放到专门的一个Oat文件中，这个文件就是：boot.oat。与之配合的还有一个boot.art文件。\n\nboot.oat可以在两个地方找到：\n1. /system/framework/[platform]/boot.oat\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     50767704 2014-11-20 19:07 boot.oat\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.oat\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     51003824 1970-05-29 01:45 system@framework@boot.oat\n```\n\n```\n/system/bin/dex2oat --image=/data/dalvik-cache/system@framework@boot.art --runtime-arg\n-Xms64m --runtime-arg -Xmx64m --dex-file=/system/framework/core-libart.jar --dex-file=/\nsystem/framework/conscrypt.jar --dex-file=/system/framework/okhttp.jar --dex-file=/\nsystem/framework/core-junit.jar --dex-file=/system/framework/bouncycastle.jar --dexfile=/system/framework/ext.jar --dex-file=/system/framework/framework.jar --dex-file=/\nsystem/framework/framework2.jar --dex-file=/system/framework/telephony-common.jar --\ndex-file=/system/framework/voip-common.jar --dex-file=/system/framework/mms-common.jar\n--dex-file=/system/framework/android.policy.jar --dex-file=/system/framework/\nservices.jar --dex-file=/system/framework/apache-xml.jar --dex-file=/system/framework/\nwebviewchromium.jar --oat-file=/data/dalvik-cache/system@framework@boot.oat --runtimearg -implicit-checks:none --instruction-set=arm --instruction-set-features=default --\nbase=0x70000000 --image-classes-zip=/system/framework/framework.jar\n```\n**上面命令编译进boot.oat中的jar:**   \n/system/framework/core-libart.jar  \n/system/framework/conscrypt.jar  \n/system/framework/okhQp.jar  \n/system/framework/core-junit.jar  \n/system/framework/bouncycastle.jar  \n/system/framework/ext.jar  \n/system/framework/framework.jar  \n/system/framework/framework2.jar  \n/system/framework/telephony-common.jar  \n/system/framework/voip-common.jar  \n/system/framework/mms-common.jar  \n/system/framework/android.policy.jar  \n/system/framework/services.jar  \n/system/framework/apache-xml.jar  \n/system/framework/webviewchromium.jar  \n\n# boot.art(boot image)\n- contains absolute pointers for methods in boot.oat(以绝对地址指向boot.oat中的方法)\n- boot.art和boot.oat的加载地址都是32位，在64位的系统上，高32位都是0\n\nboot.art中包含了指向boot.oat中方法代码的指针，它被称之为启动镜像（Boot Image），并且被加载的位置是固定的。boot.oat被加载的地址紧随着boot.art。\n\nboot.art可以在两个地方找到：\n1. /system/framework/[platform]/boot.art\n```\nroot@hammerhead:/system/framework/arm # ls -l\n-rw-r--r-- root     root     11829248 2014-11-20 19:07 boot.art\n```\n2. /data/dalvik-cache/[platform]/system@framework@boot.art\n```\nroot@hammerhead:/data/dalvik-cache/arm # ls -l\n-rw-r--r-- root     root     11829248 1970-05-29 01:45 system@framework@boot.art\n```\n\n# Profiling\n- By default,ART compiles methods regardless of impact on performance(ART编译方法时，不会考虑对性能的影响)\n- Profiling feature allows ART to be more selective on which methods to compile(profile能够\b控制dex2oat具体要对哪些方法进行编译优化)\n- Profiling配置默认可能是关闭的。可以通过setprop手动打开\n\n```\nsetprop dalvik.vm.profiler 1\n```\n\n\b- No AOT compilation upon app install(在App安装时不会进行AOT优化，一方面时为了减少安装时间、另一方面时节省\b存储空间)\n- Profiling data is collected while app is runing(在App运行期间，会收集profile数据)\n- Profile files are placed in /data/dalvik-cache/profiles\n- Profile file name is the package name\n- Profile data is used to determine if AOT compilation will be done\n\nexample:\n```\n42/2/352  \nandroid.database.Cursor com.android.email.provider.EmailProvider.uiAccounts(java.lang.String[])/1/128  \nvoid com.android.email.NotificationController.ensureHandlerExists()/1/37\nint com.android.email.provider.EmailProvider.getFolderTypeFromMailboxType(int)/2/56\nboolean com.android.mail.browse.ConversationCursor$ConversationProvider.onCreate()/1/49\ncom.google.common.collect.ImmutableList com.google.common.collect.ImmutableList.of()/1/3\n<snip>\n```\n\n- First line is the summary inforamtion\n  > count/Null methods count/Boot path methods count\n- Subsequent lines are the profile data\n  > Methods name/Count/Size\n\n# App Image\n\n* /data/app/xxx/oat/arm/base.art\n* /data/app/xxx/oat/rm/base.odex\n\nbase.art 就是对应的App image文件。主要记录已经编译好的类的具体信息以及函数在oat文件的位置，相当于缓存，在app运行的时候会加载到虚拟机，可以加快启动速度。\n\n**在Android7.0上，dex2oat的参数 compiler-filter被指定为profile类型的几个compiler-filter之一时，dex2oat还会生成app-image文件。**\n","tags":["ART、boot.oat、boot.art、Profile"]},{"title":"Android 逐步认识ART系列一","url":"/2018/12/27/Android-逐步认识ART系列一/","content":"\n参考资料：  \n原文：https://blog.csdn.net/hl09083253cy/article/details/78418809   \n原文：https://paul.pub/android-art-vm/#id-art-vs-dalvik  \nAndroid Source：https://source.android.com.devices/tech/dalvik/configure  \n\n# JIT\n我们知道，C/C++的效率要比 Java好，因为C/C++会被直接编译成汇编指令，CPU可以直接读取运行；而Java却是需要虚拟机一步一步的解释每一条 java bytecode。\n\n而Dalvik 中使用了一个技术，叫做JIT，会在解释执行一个java方法或者一个java代码段时，进行trace，并在不断的执行过程中找到 hotspot，\n\n然后将相应的方法或者代码片段编译为对应的汇编指令，下次再执行到该方法时，会直接执行其对应的汇编指令，依次来提升部分效率。\n\n可以理解为：运行时追踪，并对hotspot进行编译生成高效的可执行指令。\n\nJIT的运行流程\n\n1. 用户运行应用，而这随后就会触发 ART 加载 .dex 文件。\n   1. 如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 .oat 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。\n   2. 如果没有 .oat 文件，则 ART 会通过 JIT 或解释器执行 .dex 文件。如果有 .oat 文件，ART 将一律使用这类文件。否则，它将在内存中使用并解压 APK 文件，从而得到 .dex 文件，但是这会导致消耗大量内存（相当于 dex 文件的大小）。\n2. 针对任何未根据speed编译过滤器编译（见下文）的应用启用JIT（也就是说，要尽可能多地编译应用中的代码）。\n3. 将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。\n4. AOT 编译 dex2oat 守护进程通过解析该文件来推进其编译。\n\n要开启 JIT 日志记录，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.extra-opts -verbose:jit\nadb shell start\n```\n要停用 JIT，请运行以下命令：\n\n```\nadb root\nadb shell stop\nadb shell setprop dalvik.vm.usejit false\nadb shell start\n```\n\n# AOT\n\nAhead-of-time（AOT）是相对于Just-in-time（JIT）而言的。JIT是在运行时进行字节码到本地机器码的编译，这也是为什么Java普遍被认为效率比C++差的原因。无论是解释器的解释还是运行过程中即时编译，都比C++编译出的本地机器码执行多了一个耗费时间的过程。而AOT就是向C++编译过程靠拢的一项技术：当APK在安装的时候，系统会通过一个名称为dex2oat的工具将APK中的dex文件编译成包含本地机器码的oat文件存放下来。这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。\n\n# 单纯的JIT存在的问题\n1. 执行效率差\n\n# 单纯的AOT存在的问题\n1. 应用安装时间长\n2. 系统更新后，要重新编译所有应用\n3. 浪费存储空间（为所有方法执行编译）\n\n# AOT+JIT\n\n从Android 7.0（代号Nougat,简称N）开始，ART组合使用了AOT、JIT和配置文件引导型编译。所有这些编译模式的组合均可配置。例如，在Pixel设备上，相应的配置如下：\n\n1. 最初在安装应用程序的时候不执行任何AOT编译。应用程序运行的前几次都将使用解释模式，**并且经常执行的方法将被JIT编译**。\n2. **当设备处于空闲状态并正在充电时**，编译守护进程会根据第一次运行期间生成的Profile文件对**常用代码**运行AOT编译。\n3. 应用程序的**下一次重新启动将使用Profile文件引导的代码**，并**避免在运行时为已编译的方法进行JIT编译**。在**新运行期间得到JIT编译的方法将被添加到Profile文件中**，然后被编译守护进程使用。\n\nART包含一个编译器（dex2oat工具）和一个为启动zygote而加载的运行时（libart.so）。在应用程序安装时，APK文件会传递给dex2oat工具，该工具会为根据APK文件生成一个或多个编译产物，这些产物文件名和扩展名可能会在不同版本之间发生变化，但从Android 8.0版本开始，生成的文件是：\n\n- .vdex：包含APK的未压缩Dex代码，以及一些额外的元数据用来加速验证。\n- .odex：包含APK中方法的AOT编译代码。（注意，虽然Dalvik虚拟机时代也会生成odex文件，但和这里的odex文件仅仅是后缀一样，文件内容已经完全不同了）\n- .art（可选）：包含APK中列出的一些字符串和类的ART内部表示，用于加速应用程序的启动    \n\n# 编译选项\n\nART的编译选项分为以下两个类别：\n1. 系统ROM配置：编译系统映像时，会对哪些代码进行AOT编译。\n2. 运行时配置：ART如何在设备上编译和运行应用。\n\n用于配置这两个类别的一个核心ART选项就是”编译过滤器“，编译过滤器可控制ART如何编译DEX代码，是一个传递给dex2oat工具的选项。从Android 8.0开始，有四个官方支持的过滤器：\n   1. verify：只运行DEX代码验证\n   2. quicken：运行DEX代码验证，并优化一些DEX指令，以获得更好的解释器性能。\n   3. speed：运行DEX代码验证，并对所有方法进行AOT编译。\n   4. speed-profile：运行DEX代码验证，并对配置文件中列出的方法进行AOT编译\n\n ## 系统ROM配置\n 有一些编译选项可用于配置系统ROM，如何配置这些选项取决于/system的可用存储空间以及预先安装的应用数量。编译到系统AROM中的JAR/APK可以分为以下四个类别：\n    1. 启动类路径代码：默认使用speed编译过滤器进行编译 \n    2. 系统服务代码：默认使用speed编译过滤器进行编译\n    3. 产品专属的核心应用：默认使用speed编译过滤器进行编译\n    4. 所有其他应用：默认使用quicken编译过滤器进行编译\n\n\n","tags":["ART，OAT，JIT"]},{"title":"Android-逐步认识ART系列三","url":"/2018/12/26/dex2oat源码分析/","content":"dex2oat是将dex文件编译成Oat文件的工具，位于/system/bin/dex2oat\n\ndex2oat生成的oat文件位于设备上/data/dalvik-cache/目录下,同时，由于32位和64位的机器码有所区别，因此这个目录下还会通过子文件夹对oat文件进行分类。例如，手机上通常会有下面两个目录：  \n* /data/dalvik-cache/arm/  \n* /data/dalvik-cache/arm64/\n\n# dex2oat：\n* Retrieve classes.dex from APK (从apk中检索classes.dex)\n* verify each class（验证每个类）\n* verify each method（验证每个方法）\n* verify each dalvik instruction（验证每条dalvik指令）\n\n# dex2oat编译过程\n依次编译输入参数中的所有dex文件;  每个dex文件又按照单个class进行编译; 对于每个class，依次编译其除abstract函数、\\<cinit>之外的所有函数，包括 native（jni）/static/及一般函数，进行生成native code，并存放在compiler中。\n\n当编译完成后，会从compiler中把native code， dex文件，以及必要的组织信息，写入到OAT文件中；如果指定了生成app-image，还会再生成一份 app-image文件。\n\n# dex2oat的触发时机\ndex2oat进程的启动，可以分为两大类：一类是 installd进程触发的dex2oat；另一类是由 app中直接调用的dex2oat。\n\n ## installd中触发dex2oat有以下几个场景：\n    1. 应用安装，包括普通安装和通过shellCmd安装），安装一个app时，安装过程中需要编译dex文件，会通知installd来触发一个dex2oat进程。\n    2. 开机扫描，开机过程中，PMS扫描已安装app过程，判断需要优化时，则会对install发出通知。\n    3. BackgroundDexOptService，（空闲时段或者开机之后触发的Backgroud的 Job），会通知installd进行dex2oat\n    4. OTADexoptService，好象是OAT过程中的触发的，这个场景没有进行过实际的验证\n\n ## app中调用dex2oat\n一般是App的进程fork出一个子进程，子进程用来执行dex2oat，编译相关的dex，而父进程进行 waitpid 等待，等待完成后再运行其他逻辑。  \n例如：  \n 1. 微信安装后的首次启动，是有dex2oat的调用\n 2. 淘宝安装后的首次搜索，也有dex2oat的调用\n\n这个也是其首次启动或者搜索的一个耗时点。\n\n 由系统触发的dex2oat，都是通过通知installd来进行编译业务。\n\n 由应用触发的dex2oat，一般都是自行构建参数，直接调用dex2oat。\n\n\n# compiler-backend 类型\n\n* Portable\n* Quick\n* Optimizing\n\n ## Quick Backend\n\n > MIR -> LIR -> Native Code\n\n * Medium level IR(DEX ByteCode)\n * Low level IR\n * Native Code\n * some optimizations at each stage\n\n ## Optimizing Backend\n\n * Basically Quick with additional optimizations\n\n ## Portable Backend\n\n > MIR -> LLVM Bitcode -> LLVM optimizer -> LLVM Backend -> native code\n\n * Uses LLVM Bitcode as its LIR\n * Optimizations using LLVM optimizer\n * Code generation is done by LLVM backends\n\n\n# \b编译优化条件和对象（没太搞明白的地方）\n\n ## 什么情况下App需要使用dex2oat进行编译优化?\n * Number of methods comprising 90% of called methods has changed by > 10%.(被调用方法的比例若大于10%，则会触发dex2oat编译优化)\n\n ## \b若要使用dex2oat,哪些方法会被dex2oat考虑进去？\n * Methods comprising 90% of called methods.()\n\n# dex2oat命令行参数\n\nexample:\n```\n/system/bin/dex2oat --zip-fd=6 --zip-location=/system/app/\nEmail.apk --oat-fd=7 --oat-location=/data/dalvik-cache/\nsystem@app@Email.apk@classes.dex --profile-file=/data/\ndalvik-cache/profiles/com.android.email\n```\n参数说明：  \n--zip-fd=\\<file-descriptor>:包含classes.dex文件的zip文件描述符。  \n--oat-fd=\\<number>:\b通过此文件描述符指定输出的oat文件的路径。  \n--oat-location=\\<oat-name>:指定一个与--oat-fd指定的文件描述符相对应的象征性名字。  \n--profile-file：引导dex2oat编译优化的配置文件。文件位置：/data/dalvik-cache/profiles/应用包名\n\n其他重要参数说明(参考android7.0.0源码)：  \n-j\\<number>:指定进行\b编译优化时要用到的线程总数。默认根据硬件适配，例如：-j12  \n--dex-file=\\<dex-file>:指定要编译的文件，后缀可以是.dex、.jar、.apk，\b例如：--dex-file=/system/framework/core.jar  \n--dex-location=\\<dex-location>:dex文件路径,与--dex-file相对应，例如：--dex-file=/home/build//out/system/framework/core.jar;--dex-location=/system/framework/core.jar。    \n--zip-location=\\<zip-location>:zip文件路径。例如：--zip-location=/system/app/Calculator.apk   \n--oat-file=\\<file.oat>:输出的oat文件名。例如：--oat-file=/system/framework/boot.oat。  \n--oat-symbols=\\<file.oat>:指定输出完整符号的oat路径。例如：--oat-symbols=/symbols/system/framework/boo.art。  \n--instruction-set=(arm|arm64|mips|mips64|x86|x86_64):指定指令集架构类型，默认为arm。  \n--compile-backend=(Quick|Optimizing):指定编译器后端。默认为Optimizing。  \n--compiler-filter=(verify-none|verify-at-runtime|verify-profile|interpret-only|time|space-profile|space|balanced|speed-profile|speed|everything-profile|everything):指定编译器过滤模式，默认为speed。\n\n# dex2oat主要流程\n\nmain函数入口：\n```\nint main(int argc, char** argv) {\n  int result = art::dex2oat(argc, argv);\n  // Everything was done, do an explicit exit here to avoid running Runtime destructors that take\n  // time (bug 10645725) unless we're a debug build or running on valgrind. Note: The Dex2Oat class\n  // should not destruct the runtime in this case.\n  if (!art::kIsDebugBuild && (RUNNING_ON_MEMORY_TOOL == 0)) {\n    exit(result);\n  }\n  return result;\n}\n```\ndex2oat函数入口：\n```\nstatic int dex2oat(int argc, char** argv) {\n  b13564922();\n    \n  TimingLogger timings(\"compiler\", false, false);\n\n  // Allocate `dex2oat` on the heap instead of on the stack, as Clang\n  // might produce a stack frame too large for this function or for\n  // functions inlining it (such as main), that would not fit the\n  // requirements of the `-Wframe-larger-than` option.\n  std::unique_ptr<Dex2Oat> dex2oat = MakeUnique<Dex2Oat>(&timings);\n\n  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.\n  dex2oat->ParseArgs(argc, argv);\n\n  // If needed, process profile information for profile guided compilation.\n  // This operation involves I/O.\n  if (dex2oat->UseProfileGuidedCompilation()) {\n    if (!dex2oat->LoadProfile()) {\n      LOG(ERROR) << \"Failed to process profile file\";\n      return EXIT_FAILURE;\n    }\n  }\n\n  // Check early that the result of compilation can be written\n  if (!dex2oat->OpenFile()) {\n    return EXIT_FAILURE;\n  }\n\n  // Print the complete line when any of the following is true:\n  //   1) Debug build\n  //   2) Compiling an image\n  //   3) Compiling with --host\n  //   4) Compiling on the host (not a target build)\n  // Otherwise, print a stripped command line.\n  if (kIsDebugBuild || dex2oat->IsBootImage() || dex2oat->IsHost() || !kIsTargetBuild) {\n    LOG(INFO) << CommandLine();\n  } else {\n    LOG(INFO) << StrippedCommandLine();\n  }\n\n  if (!dex2oat->Setup()) {\n    dex2oat->EraseOatFiles();\n    return EXIT_FAILURE;\n  }\n\n  bool result;\n  if (dex2oat->IsImage()) {//App Image 或者Boot Image\n    result = CompileImage(*dex2oat);\n  } else {\n    result = CompileApp(*dex2oat);\n  }\n\n  dex2oat->Shutdown();\n  return result;\n}\n}\n```\n\n> 当使用profile-guide 编译app时，会先 LoadProfile(),进行解析出 class index 和 method index，放到 ProfileCompilationinfo 中;\n> 如果当前的编译要生成 image时，走CompileImage流程，否则走CompileApp流程;\n\n不论是编译image还是App都会包含以下一个工作：\n```\ndex2oat.Compile();//核心\n\ndex2oat.WriteOatFiles();//嵌入ELF\n\ndex2oat.FlushCloseOatFiles();\n\n dex2oat.DumpTiming()\n```\n\nCompileApp和CompileImage的区别是：\n\n 1. 编译image时需要 LoadClassProfileDescriptors() 产生 image_classes_ 集合，和生成 image（HandleImage()）;\n 2. 在生成的app image中将会包含 image_classes_ 集合中类的对象，不在 image_classes_集合中的app的类的对象，将不会被生成到 app-image中。\n 3. LoadClassProfileDescriptors（）在从 profile信息中获取 image_classes_集合时，将会把 app dex 中的类以外的类，都过滤掉，比如 classpath dex 对应的类将不会生成到 app-image;\n\ndex2oat工作流程总结：\n 1. 根据dex2oat接收到的参数，组织编译参数\n 2. 如果是 profile-guide 编译，则先进行 load app对应的 profile\n 3. 收集参数中包含的所有dex file，启动 Compiler 编译这些dex file（classpath中对应的dex file，即uses-library 引用的jar文件，不会被编译），编译生成的数据放在compiler-driver中\n 4. 使用 compiler-driver 中的数据，依据 oat文件设计的格式，组织成oat文件，嵌入到 ELF文件中\n 5. 如果指定需要生成 app-image，则使用 HandleImage()， 生成app-image， 即 ***.art 文件\n\n## 编译流程\b\n","tags":["Android、dex2oat"]},{"title":"Android 部分系统版本变更行为","url":"/2018/12/26/Android-部分系统版本变更行为/","content":"**主要关注安全方面**\n# Android 6.0部分变更行为：\n\n* 运行时权限\n\n此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。\n\n* 低电耗模式和应用待机模式\n\n此版本引入了针对空闲设备和应用的最新节能优化技术。\n  * 低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。\n  * 应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。\n\n\n* 取消支持 Apache HTTP 客户端\n\nAndroid 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：\n```\nandroid {\n    useLibrary 'org.apache.http.legacy'\n}\n```\n\n* Boring SSL\n\nAndroid 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。\n* 运行时\n\nART 运行时环境现在可正确实现 newInstance() 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 setAccessible() 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。\n\n此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。\n\n现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。\n\n在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。\n\n* APK验证\n\n该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。\n\n# Android 7.0部分变更行为：\n* 配置文件指导的 JIT/AOT 编译\n\n在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。\n\n配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。\n\n除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。\n\nAndroid 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。\n* 快速的应用安装路径\n\nAndroid 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤\n\n**关于JIT的回归**\n\n在Android 5.0上，系统在安装APK时会直接将dex文件中的代码编译成机器码。编译一个应用就已经很耗时，若编译所有应用，等待时间将会使人难以忍受。\n\n例如：  \n应用程序编译生成的OAT文件会引用Framework中的代码。一旦系统发生升级，Framework中的实现发生变化，就需要重新修正所有应用程序的OAT文件，使得它们的引用是正确的，这就需要重新编译所有的应用。\n\n由此可以看到单纯的AOT编译会存在以下问题：\n* 应用安装时间过长。\n* 系统每次更新都要重新编译所有应用。\n* 编译生成的Oat文件中，既包含了原先的Dex文件，又包含了编译后的机器代码。而实际上，对于用户来说，并非会用到应用程序中的所有功能，因此很多时候编译生成的机器码是一直用不到的。一份数据存在两份结果（尽管它们的格式是不一样的）显然是一种存储空间的浪费。\n  \n因此，为了解决上述问题，Android 7.0(代号Nougat,简称N)中添加了JIT编译器和配置文件引导型编译。JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。\n\nJIT编译器补充了ART当前的预先AOT编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT编译器，JIT编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 OTA 更新期间）时拖慢系统速度。\n\n尽管JIT和AOT使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 OnStackReplacement 编译成为可能，而这一切都会使其生成的代码略有不同。\n","tags":["Android，版本变化"]},{"title":"Android系统版本分布","url":"/2018/12/26/Android系统版本分布/","content":"\nAndroid 信息中心：https://developer.android.com/about/dashboards/?hl=zh-cn\n\nAndroid各个系统版本市场占有率表：\n![image](https://note.youdao.com/yws/api/personal/file/WEB9c984ab2b3606d4f688dee72ff7fb30f?method=download&shareKey=288a168344f4c3da4e4930c699d19ee2)\nAndroid各个系统版本市场占有率图：\n![image](https://note.youdao.com/yws/api/personal/file/WEB75a72b0c1a2257ce5215bc18bb38a8d4?method=download&shareKey=cc627bcace397474e82ad2ad8355057c)\n\n总结，由上表和上图可知：\n+ Android6.0、Android7.0,7.1、Android8.0,8.1占据了3/4的Android市场。\n+ 单个系统版本市场占有率最高的为Android 6.0，即API 23 \n+ 复合系统\b版本市场占有率最高的为Android 7.0系列，其中7.0为18.1%，7.1为10.1%\n+ \n","tags":["Android"]},{"title":"Java 打印堆栈信息","url":"/2018/12/26/Java-打印堆栈信息/","content":"#java打印堆栈信息\n\n+ 在函数内部打印函数调用堆栈\n```\nLog.d(TAG,Log.getStackTraceString(new Throwable()));\n```\n+ 出异常时打印当前堆栈\n```\ntry{\n\n}\ncatch(Exception e){\n    e.printStackTrace();\n}\n```\n+ 使用StackTraceElement[]打印\n```\nThrowable ex = new Throwable();\nStackTraceElement[] stackElements = ex.getStackTrace();\nif (stackElements != null) {\n    for (int i = 0; i < stackElements.length; i++) {\n        System.out.print(stackElements[i].getClassName()+\"/t\");\n        System.out.print(stackElements[i].getFileName()+\"/t\");\n        System.out.print(stackElements[i].getLineNumber()+\"/t\");\n        System.out.println(stackElements[i].getMethodName());\n        System.out.println(\"-----------------------------------\");\n    }\n}\n```\n+ 使用Thread打印\n```\nThread.currentThread().getStackTrace()\n```\n+ 使用exception打印\n```\nException e = new Exception(\"this is a log\");\ne.printStackTrace();\n```","tags":["Java，堆栈"]},{"title":"Android Oat文件分析","url":"/2018/12/26/Oat文件分析/","content":"\n.oatdata -> .rodata(oatHeader、dex文件相关信息、dex原始文件、类中方法与翻译为native code的对应关系)\n.oatexec -> .text(native code)\n\nOat文件结构概览：\n\n![avatar](https://note.youdao.com/yws/api/personal/file/WEBd91be5da5cc9c70b50ac5355d12d6e84?method=download&shareKey=cfbfd9c6f94f41b648fc4d3b4ebacadb)\n# elf文件结构(32位)：\n```\ntypedef uint16_t Elf32_Half; //2 bytes\ntypedef uint32_t Elf32_Word; //4 bytes\ntypedef uint32_t Elf32_Addr; //4 bytes\ntypedef uint32_t Elf32_Off;  //4 bytes\ntypedef int32_t  Elf32_Sword;//4 bytes\n```\n```\n// Object file magic string.\nstatic const char ElfMagic[] = { 0x7f, 'E', 'L', 'F', '\\0' }\n```\n```\n// e_ident size and indices.\nenum {\n  EI_MAG0       = 0,          // File identification index.\n  EI_MAG1       = 1,          // File identification index.\n  EI_MAG2       = 2,          // File identification index.\n  EI_MAG3       = 3,          // File identification index.\n  EI_CLASS      = 4          ,// File class.\n  EI_DATA       = 5,          // Data encoding.\n  EI_VERSION    = 6,          // File version.\n  EI_OSABI      = 7,          // OS/ABI identification.\n  EI_ABIVERSION = 8,          // ABI version.\n  EI_PAD        = 9,          // Start of padding bytes.\n  EI_NIDENT     = 16          // Number of bytes in e_ident.\n};\n```\nelf文件头结构：（16+4+20+12=52字节，1+2+5+6=14项）\n```\nstruct Elf32_Ehdr{\n    unsigned char e_ident[EI_NIDENT];//ELF文件魔数          16字节\n    Elf32_Half  e_type;              //ELF文件类型（32/64位）2字节  2*2\n    Elf32_Half  e_machine;           //该ELF文件所需要的架构  2字节\n    Elf32_Word  e_version;           //ELF文件版本（始终为1） 4字节   4*5\n    Elf32_Addr  e_entry;             //程序入口地址          4字节\n    Elf32_Off   e_phoff;             //segment表偏移地址     4字节\n    Elf32_Off   e_shoff;             //section表偏移地址     4字节\n    Elf32_Word  e_flags;             //标志                 4字节\n    Elf32_Half  e_ehsize;            //ELF文件头大小         2字节   2*6\n    Elf32_Half  e_phentsize;        //segment表项大小        2字节\n    Elf32_Half  e_phnum;            //segment表项数目        2字节\n    Elf32_Half  e_shentsize;        //section表项大小        2字节  \n    Elf32_Half  e_shnum;            //section表项数目        2字节\n    Elf32_Half  e_shstrndx;         //段表字符串表在section表中的下标 2字节\n};\n```\n```\n// File types\nenum {\n  ET_NONE   = 0,      // No file type\n  ET_REL    = 1,      // Relocatable file\n  ET_EXEC   = 2,      // Executable file\n  ET_DYN    = 3,      // Shared object file\n  ET_CORE   = 4,      // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n```\n```\n// Machine architectures\nenum {\n    EM_NONE = 0, // No machine\n    EM_ARM  = 40 // ARM\n    ...\n};\n```\n案例分析①：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n>7F 45 4C 46 01 01 01 03 00 00 00 00 00 00 00 00\n03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00\n70 50 48 00 00 00 00 05 34 00 20 00 05 00 28 00\n08 00 07 00\n\n魔数：7F 45 4C 46 //0x464c457f  \n位宽：01 //0x01代表32位；0x02代表64位    \n端序：01 //0x01代表小端；0x02代表打断    \n版本：01   \n操作系统：03 //0x03代表Linux  \n00 00 00 00 00 00 00 00   \n文件类型：03 00  //0x03:共享文件    \n芯片架构：28 00 // 0x28 ARM架构   \n文件版本：01 00 00 00 //0x01 (始终为1)    \n程序入口地址：00 00 00 00 //0x0   \nsegment表偏移：34 00 00 00 //0x34   \nsection表偏移：70 50 48 00 //0x485070   \n标志：00 00 00 05   //0x5000000   \n文件头大小：34 00   //0x34    \nsegment表项大小：20 00  //0x20    \nsegment表项数目：05 00  //0x05    \nsection表项大小：28 00  //0x28    \nsection表项数目：08 00  //0x08    \n段表字符串表在段表中下标：07 00 //0x07\n\n----\n\nsegment头结构：（8项，每项4个字节，32字节）\n```\nstruct Elf32_Phdr{\n    Elf32_Word  p_type;//segment类型\n    Elf32_Off   p_offset;//segment相对文件开始的偏移\n    Elf32_Addr  p_vaddr;//segment映射到内存中的首字节地址（即虚拟地址）\n    Elf32_Addr  p_paddr;//在物理地址定位有关的系统中，该字段是为该段的物理地址而保留的，对于可执行文件和共享的object而言是未指定内容的。\n    Elf32_Word  p_filesz;//在文件映像中该segment的字节数（可能是0）\n    Elf32_Word  p_memsz;//在内存映像中该segment的字节数（可能是0）\n    Elf32_Word  p_flags;//segment标志\n    Elf32_Word  p_align;//可载入的进程段必须有合适的p_vaddr、p_offset值，取页面大小的模。该字段给出了该段在内存和文件中排列值。0和1表示不需要排列。否则，p_align必须为正的2的幂\n};\n```\n```\n// Segment types.\nenum {\n    PT_NULL    = 0, // Unused segment.空值\n    PT_LOAD    = 1, // Loadable segment.加载到内存中\n    PT_DYNAMIC = 2, // Dynamic linking information.动态链接\n    PT_INTERP  = 3, // Interpreter pathname.动态链接的辅助信息\n    PT_NOTE    = 4, // Auxiliary information.其他信息\n    PT_SHLIB   = 5, // Reserved.RFU\n    PT_PHDR    = 6, // The program header table itself.segment表头的位置和大小\n    PT_TLS     = 7, // The thread-local storage template.\n    ...\n};\n```\n案例分析②：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n由ELF文件头知：segment表偏移为0x34;表大小为0x05;表项大小为0x20;推出segment头表大小为：0x05*0x20=0xa0 \n\n>06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00 //PT_PHDR  \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 //PT_LOAD   \n00 10 2A 00 00 10 2A 00 04 00 00 00 00 10 00 00   \n01 00 00 00 00 10 2A 00 00 10 2A 00 00 10 2A 00 //PT_LOAD   \n48 35 1E 00 48 35 1E 00 05 00 00 00 00 10 00 00   \n01 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_LOAD   \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n02 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_DYNAMIC    \n38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   \n\n第一个segment头：   \n06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00   \nA0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   \nsegment类型：06 00 00 00    //PT_PHDR(程序头表自身)   \nsegment文件偏移：34 00 00 00    \nsegment虚拟地址：34 00 00 00    \nsegment物理地址：34 00 00 00    \n文件映像中该segment字节数：A0 00 00 00    \n内存映像中该segment字节数：A0 00 00 00    \nsegment标志：04 00 00 00    \nsegment对齐：04 00 00 00\n\n其他segment头:    \n省略...\n\nsection头结构：（10项，每项4个字节，40字节）\n```\nstruct Elf32__Shdr{\n  Elf32_Word sh_name;      // Section name (index into string table), section名字，string table的索引\n  Elf32_Word sh_type;      // Section type (SHT_*),section的类型\n  Elf32_Word sh_flags;     // Section flags (SHF_*),section标记，用来描述多个属性\n  Elf32_Addr sh_addr;      // Address where section is to be loaded,若该section被加载到内存中，该字段表示其在内存中的位置\n  Elf32_Off  sh_offset;    // File offset of section data, in bytes,该section在文件中的偏移，SHT_NOBITS类型的section在文件中不占用空间，概念上的位置\n  Elf32_Word sh_size;      // Size of section, in bytes,section大小，SHT_NOBITS类型的section该值可能为非0，但是不占文件空间\n  Elf32_Word sh_link;      // Section type-specific header table index link,到section头表的链接\n  Elf32_Word sh_info;      // Section type-specific extra information,额外信息\n  Elf32_Word sh_addralign; // Section address alignment,地址对齐\n  Elf32_Word sh_entsize;   // Size of records contained within the section,一些sections保留着一张固定大小入口的表，对于此类型的section，该字段给除了每个入口的字节大小\n};\n```\n```\n// Section types.\nenum {\n    SHT_NULL          = 0,  // No associated section (inactive entry).\n    SHT_PROGBITS      = 1,  // Program-defined contents.\n    SHT_SYMTAB        = 2,  // Symbol table. 符号表\n    SHT_STRTAB        = 3,  // String table. 字符串表\n    SHT_RELA          = 4,  // Relocation entries; explicit addends.\n    SHT_HASH          = 5,  // Symbol hash table.\n    SHT_DYNAMIC       = 6,  // Information for dynamic linking.\n    SHT_NOTE          = 7,  // Information about the file.\n    SHT_NOBITS        = 8,  // Data occupies no space in the file.\n    SHT_REL           = 9,  // Relocation entries; no explicit addends.\n    SHT_SHLIB         = 10, // Reserved.\n    SHT_DYNSYM        = 11, // Symbol table.  动态符号表\n    SHT_INIT_ARRAY    = 14, // Pointers to initialization functions.\n    SHT_FINI_ARRAY    = 15, // Pointers to termination functions.\n    SHT_PREINIT_ARRAY = 16, // Pointers to pre-init functions.\n    SHT_GROUP         = 17, // Section group.\n    SHT_SYMTAB_SHNDX  = 18, // Indices for SHN_XINDEX entries\n};\n```\n案例分析③：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex    \n由ELF文件头知：section表偏移为0x485070;表项大小为0x28;表项数目为0x08;推出section头表大小为0x28*0x08=0x140\n\n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 0B 00 00 00   \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00   \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00 11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00   \n25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00 2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\n第一个section头：//No associated section (inactive entry).   \n>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   \n00 00 00 00 00 00 00 00\n\n第二个section头：(.dynsym) //Symbol table    \n>01 00 00 00 0B 00 00 00                            \n02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   \n02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   \n\nsection名称：01 00 00 00    //在字符串表中的下标    \nsection类型：0B 00 00 00    //0xb 符号表 .symbol    \n\n第三个section头：(.dynstr)\n>09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00    \n14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   \n01 00 00 00 01 00 00 00   \n\nsection名称：09 00 00 00    \nsection类型：03 00 00 00    //0x3 字符串表 .strtab    \nsection标记：02 00 00 00    \nsection虚拟地址：14 01 00 00    \nsection文件偏移：14 01 00 00 //0x0114    \nsection大小：64 00 00 00   //0x64 推出结束偏移：0x178   \nsection到section头表的链接：00 00 00 00     \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n根据section头信息，导出.dynstr内容：    \n>00 6F 61 74 64 61 74 61 00 6F 61 74 65 78 65 63   \n00 6F 61 74 6C 61 73 74 77 6F 72 64 00 64 61 74   \n61 40 61 70 70 40 63 6F 6D 2E 65 78 61 6D 70 6C   \n65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61 70 70   \n6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31 40 62   \n61 73 65 2E 61 70 6B 40 63 6C 61 73 73 65 73 2E   \n64 65 78 00\n\n对应的字符信息：    \n索引  |  值 \n---|:--:   \n0x0  |  \\00    \n0x1  | oatdata\\00\n0x9  | oatexec\\00\n0x11 | oatlastword\\00\n0x1d | data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\\00\n\n\n第四个section头：(.hash)\n>11 00 00 00 05 00 00 00   \n02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   \n01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   \n\nsection名称：11 00 00 00     \nsection类型：05 00 00 00    //0x5 符号hash表    \n\n第五个section头：(.rodata)  [原dex信息,oatdata] [oat文件头起始位置]   \n>17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   \n00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   \n00 10 00 00 00 00 00 00 \n\nsection名称：17 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：02 00 00 00    \nsection虚拟地址：00 10 00 00    \nsection文件偏移：00 10 00 00    //0x1000    \nsection大小：00 00 2A 00        //0x2A0000 推出结束偏移：0x2A1000   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头，导出.rodata内容：    \n[rodata.txt]\n\n第六个section头：(.text) [native code,oatexec]    \n>1F 00 00 00 01 00 00 00   \n06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   \n00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00  \n\nsection名称：1F 00 00 00    \nsection类型：01 00 00 00    //0x1 Program-defined contents    \nsection标记：06 00 00 00    \nsection虚拟地址：00 10 2A 00    \nsection文件偏移：00 10 2A 00    //0x2A1000    \nsection大小：48 35 1E 00        //0x1E3548 推出结束偏移：0x484548   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：00 00 00 00    \n\n依据section头信息，导出.text内容：    \n[text.txt]\n\n**.text段 与 .dynamic段之间有一段空区域**\n\n第七个section头：(.dynamic)      \n>25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   \n00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   \n00 10 00 00 08 00 00 00     \n\nsection名称：25 00 00 00    \nsection类型：06 00 00 00    //Information for dynamic linking   \nsection标记：02 00 00 00    \nsection虚拟地址：00 50 48 00    \nsection文件偏移：00 50 48 00    //0x485000    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485038   \nsection到section头表的链接：01 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：00 10 00 00    \nsection入口表大小：08 00 00 00    \n\n第八个section头：(.shstrtab)：    \n由ELF文件头知：shstrtab在section头表总的下标为0x07,在本案例中即最后一个section \n>2E 00 00 00 03 00 00 00   \n00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   \n00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00   \n\nsection名称：2E 00 00 00    \nsection类型：03 00 00 00    //字符串表（段表字符串表）    \nsection标记：00 00 00 00    \nsection虚拟地址：00 00 00 00    \nsection文件偏移：38 50 48 00    //0x485038    \nsection大小：38 00 00 00        //0x38 推出结束偏移：0x485070   \nsection到section头表的链接：00 00 00 00   \nsection额外信息：00 00 00 00    \nsection对齐：01 00 00 00    \nsection入口表大小：01 00 00 00    \n\n依据section头信息，导出.shstrtab内容：    \n>00 2E 64 79 6E 73 79 6D 00 2E 64 79 6E 73 74 72   \n00 2E 68 61 73 68 00 2E 72 6F 64 61 74 61 00 2E   \n74 65 78 74 00 2E 64 79 6E 61 6D 69 63 00 2E 73   \n68 73 74 72 74 61 62 00\n\n对应的字符信息：\n索引  |  值\n---|:--:\n0x0  |  \\00\n0x01 |  .dynsym\\00\n0x09 |  .dynstr\\00\n0x11 |  .hash\\00\n0x17 |  .rodata\\00\n0x1f |  .text\\00\n0x25 |  .dynamic\\00\n0x2e |  .shstrtab\\00\n\n----\n\noat文件头结构：/art/runtime/oat.h\n```\nclass PACKED(4) OatHeader {\n    ...\n private:\n  ...\n  uint8_t magic_[4];    //魔数‘oat\\n’\n  uint8_t version_[4];  //oat文件版本号\n  uint32_t adler32_checksum_;   //校验和\n\n  InstructionSet instruction_set_;  //本地机器指令集，表示指令的类型（枚举类型）/art/runtime/instruction_set.h\n  InstructionSetFeatures instruction_set_features_; //架构特性\n  uint32_t dex_file_count_; //oat文件包含的dex文件个数\n  uint32_t executable_offset_;  //oatexec段开始位置与oatdata段开始位置的偏移值（oatexec段开始位置+executable_offset_=oatdata段开始位置）\n\n  uint32_t interpreter_to_interpreter_bridge_offset_;   //用来从解释器调用另外一个也是通过解释器来执行的类方法的trampoline代码的偏移位置\n  uint32_t interpreter_to_compiled_code_bridge_offset_; //用来从解释器调用另外一个通过本地机器指令执行的类方法的trampoline代码的偏移位置\n  uint32_t jni_dlsym_lookup_offset_;    //类方法在执行过程中，若被调用的方法是JNI函数，那么通过存放在此位置的trampoline代码来调用\n  uint32_t portable_imt_conflict_trampoline_offset_;    //...\n  uint32_t portable_resolution_trampoline_offset_;  //用来在运行时解析还未链接的类方法的trampoline代码位置（portable类型的机器指令）\n  uint32_t portable_to_interpreter_bridge_offset_;  //用来从本地机器指令（portable类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n  uint32_t quick_generic_jni_trampoline_offset_;    //...\n  uint32_t quick_imt_conflict_trampoline_offset_;   //...\n  uint32_t quick_resolution_trampoline_offset_; //用来在运行时解析还未链接的类方法的trampoline代码位置（quick类型的机器指令）\n  uint32_t quick_to_interpreter_bridge_offset_;  //用来从本地机器指令（quick类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置\n\n  //由于每一个应用程序都会依赖于boot.art文件，上述10个变量指向的trampoline代码段只存在于boot.art文件中，即在应用程序classes.dex生成的oat文件的oatdata段头部，上述变量值均为0\n\n  // The amount that the image this oat is associated with has been patched.\n  int32_t image_patch_delta_;   //该oat文件关联的image被patch的数量\n\n  uint32_t image_file_location_oat_checksum_;   //用来创建image空间的oat文件的校验和\n  uint32_t image_file_location_oat_data_begin_; //用来创建image空间的oat文件的oatdata段在内存的位置\n\n  uint32_t key_value_store_size_;   //用来创建image空间的文件路径的大小\n  uint8_t key_value_store_[0];  // note variable width data at end\n\n  DISALLOW_COPY_AND_ASSIGN(OatHeader);\n};\n```\n```\n// InstructionSet\nenum InstructionSet {\n  kNone,\n  kArm,\n  kArm64,\n  kThumb2,\n  kX86,\n  kX86_64,\n  kMips,\n  kMips64\n};\n```\n\n案例分析④：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n开始位置：0x1000    \n由rodata.txt中的数据及oat文件头结构知：   \n魔数：6F 61 74 0A   //大端序，0x6f61740a    \n版本号：30 33 39 00 //大端序，0x30333900    \n校验和：E4 E3 11 75   \n指令类型：03 00 00 00   \n指令集特性：01 00 00 00   \n包含的dex文件个数：01 00 00 00    \noatexec段开始位置相对于oatdata段开始位置的偏移：00 00 2A 00   \n解释器执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \n解释器执行到本地机器指令执行的trampoline代码的偏移位置：00 00 00 00   \nJNI方法调用的trampoline代码的偏移位置：00 00 00 00    \nportable_imt_conflict_trampoline_offset_：00 00 00 00   \n本地机器指令（portable）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00   \n本地机器指令（portable）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00   \nquick_generic_jni_trampoline_offset_：00 00 00 00   \nquick_imt_conflict_trampoline_offset_：00 00 00 00    \n本地机器指令（quick）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00    \n本地机器指令（quick）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00    \nimage_patch_delta_：00 00 00 00   \n创建image空间的oat文件的校验和：8E 72 EE 60   \n创建image空间的oat文件的oatdata段在内存的位置：00 F0 17 71    \nkey_value_store_size_：A6 01 00 00    \nkey_value_store_：(dex2oat的参数)   \n\n依据key_value_store_size_导出key_value_store_的内容：   \n>64 65 78 32 6F 61 74 2D 63 6D 64 6C 69 6E 65 00   \n2D 2D 7A 69 70 2D 66 64 3D 36 20 2D 2D 7A 69 70   \n2D 6C 6F 63 61 74 69 6F 6E 3D 2F 64 61 74 61 2F   \n61 70 70 2F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E   \n70 61 73 73 65 72 62 79 2E 6D 79 61 70 70 6C 69   \n63 61 74 69 6F 6E 2E 61 70 70 2D 31 2F 62 61 73   \n65 2E 61 70 6B 20 2D 2D 6F 61 74 2D 66 64 3D 37   \n20 2D 2D 6F 61 74 2D 6C 6F 63 61 74 69 6F 6E 3D   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 64 61 74 61 40 61 70 70 40   \n63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 70 61 73 73   \n65 72 62 79 2E 6D 79 61 70 70 6C 69 63 61 74 69   \n6F 6E 2E 61 70 70 2D 31 40 62 61 73 65 2E 61 70   \n6B 40 63 6C 61 73 73 65 73 2E 64 65 78 20 2D 2D   \n69 6E 73 74 72 75 63 74 69 6F 6E 2D 73 65 74 3D   \n61 72 6D 20 2D 2D 69 6E 73 74 72 75 63 74 69 6F   \n6E 2D 73 65 74 2D 66 65 61 74 75 72 65 73 3D 64   \n69 76 20 2D 2D 72 75 6E 74 69 6D 65 2D 61 72 67   \n20 2D 58 6D 73 36 34 6D 20 2D 2D 72 75 6E 74 69   \n6D 65 2D 61 72 67 20 2D 58 6D 78 35 31 32 6D 00   \n64 65 78 32 6F 61 74 2D 68 6F 73 74 00 41 72 6D   \n00 69 6D 61 67 65 2D 6C 6F 63 61 74 69 6F 6E 00   \n2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   \n68 65 2F 61 72 6D 2F 73 79 73 74 65 6D 40 66 72   \n61 6D 65 77 6F 72 6B 40 62 6F 6F 74 2E 61 72 74   \n00 78 70 6F 73 65 64 2D 6F 61 74 2D 76 65 72 73   \n69 6F 6E 00 32 00\n\n对应的字符信息：\n\ndex2oat-cmdline\\00    \n--zip-fd=6    --zip-location=/data/app/com.example.passerby.myapplication.app-1/base.apk --oat-fd=7     --oat-location=/data/dalvik-cache/arm/data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex --instruction-set=arm --instruction-set-features=div --runtime-arg -Xms64m --runtime-arg -Xmx512m\\00   \ndex2oat-host\\00   \nArm\\00    \nimage-location\\00   \n/data/dalvik-cache/arm/system@framework@boot.art\\00   \nxposed-oat-version\\00   \n2\\    \n\nOatHeader后就是Dex文件相关信息(开始位置:0x11FA):      \n根据OatHeader中dex_file_count_的值可知，此处共包含1个Dex文件的内容。    \n若用DexMetaData结构表示Dex文件的内容，其包含的字段如下： \n```   \nuint32_t dex_file_location_size;     //dex文件路径的字节数(4字节)    \nchar* dex_file_location_data;        //dex文件的路径    \nuint32_t dex_file_checksum;          //dex文件的校验和(4字节)    \nuint32_t dex_file_offset;            //dex文件相对于oatdata段开始地址的偏移(4字节)   \nconst uint32_t* methods_offsets_pointer;//是一个数组，元素共有class_defs_size（dex中类的数目）个，该数组的索引与dex中类的索引是一致的，\n                                        即第0个类对应methods_offsets_pointer[0],元素的值是相对于oatdata段开始地址的偏移，\n                                        比如dex中第0个类对应的OatClass在文件中的开始地址=methods_offsets_pointer[0]+oatdata段开始地址。   \n```\n所以，整个DexMetaData的字节数=OatHeader->dex_file_count_ * (4+dex_file_location_data+4+4+4*dex->class_defs_size)\n                          = OatHeader->dex_file_count_ * (12+ dex_file_location_data + 4 * dex->class_defs_size)\n\n案例分析⑤：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex\n\n根据OatHeader的结束位置导出Dex文件信息(0x11FA)：   \n>3B 00 00 00 2F 64   \n61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78 61 6D   \n70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61   \n70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31   \n2F 62 61 73 65 2E 61 70 6B 7C 2B D8 F3 7C 18 00   \n00 4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22   \n00 9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22   \n00 4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22   \n00 CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22   \n00 44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22   \n....\n\ndex文件路径的字节数：3B 00 00 00  //0x3B = 3*16+11个字节    \ndex文件路径：   \n2F 64 61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78     \n61 6D 70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D     \n79 61 70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70     \n2D 31 2F 62 61 73 65 2E 61 70 6B    \n\n对应的字符信息：    /data/app/com.example.passerby.myapplication.app-1/base.apk   \ndex文件校验和：7C 2B D8 F3    \ndex文件相对于oatdata段开始地址的偏移：7C 18 00 00   //0x187c  相对于oat文件的偏移：0x1000 + 0x187c = 0x287c   \n\nmethods_offsets_pointer:（每项4个字节，共class_defs_size项，即1422项，结束位置：0x1241+1422*4 = 0x2879）    \n>4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22 00     \n9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22 00     \n4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22 00     \nCC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22 00     \n44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22 \n...\n00 C0 7D 23 00 C4 7E 23 00 00\n\n根据dex文件地址(0x287c-0x2A1000)导出数据：   \n64 65 78 0A 30 33 35 00 39 DD DD F3 29 80 26 28     \n9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C     \nD0 0A 22 00 70 00 00 00 78 56 34 12 00 00 00 00     \n00 00 00 00 F4 09 22 00 19 53 00 00 70 00 00 00     \n87 08 00 00 D4 4C 01 00 51 0D 00 00 F0 6E 01 00     \nB0 3A 00 00 BC 0E 02 00 DF 3E 00 00 3C E4 03 00     \n8E 05 00 00 34 DB 05 00 DC 7D 1B 00 F4 8C 06 00   \n...\n\n可以看到dex文件的文件头：   \n魔数：64 65 78 0A 30 33 35 00  //对应的字符信息dex.035    \ndex文件校验和：39 DD DD F3    \ndex文件sha1签名：29 80 26 28 9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C    \ndex文件大小：D0 0A 22 00        //0x220AD0 推出文件结束地址： 0x287c + 0x220ad0 = 0x22334c    \n文件头大小：70 00 00 00         //0x70    \n字节序：78 56 34 12            //0x12345678 小端序    \nlink_size_:00 00 00 00    \nlink_off_:00 00 00 00   \nmap_off_:F4 09 22 00    \nstring_ids_size_:19 53 00 00    \nstring_ids_off_:70 00 00 00   \ntype_ids_size_:87 08 00 00    \ntype_ids_off_:D4 4C 01 00   \nproto_ids_size_:51 0D 00 00   \nproto_ids_off_:F0 6E 01 00    \nfield_ids_size_:B0 3A 00 00   \nfields_ids_off_:BC 0E 02 00   \nmethod_ids_size_:DF 3E 00 00    \nmethods_ids_off_:3C E4 03 00    \nclass_defs_size_:8E 05 00 00    //0x058E,1422,dex文件中共包含1422个类定义    \nclass_defs_off_:34 DB 05 00     //0x05db34,相对于dex文件头的偏移位置，相对于oat文件的偏移：0x05db34+0x287c=0x0603b0   \ndata_size_:DC 7D 1B 00    \ndata_off_:F4 8C 06 00   \n\n案例分析⑥：data@app@com.example.passerby.myapplication.app-1@base.apk@classes.dex   \n\n使用dextra工具导出该oat文件中的dex或手动选中dex文件地址范围保存：（采用export的方式导出010的dex模板会识别不了，应该是导 出的格式有问题;下面所说的偏移都是相对于导出dex文件的偏移）\n在010工具的type_ids中查找MainActivity，找到对应的索引号1925，转为16进制即：85 07 00 00 ，在010中全局搜索’85 07 00 00‘，找到MainActivity类定义偏移0x68cd4。\n借助dex分析模板，找到mainActivity类定义的偏移位置：0x068cd4,由DexClassDef结构知，每个DexClassDef大小为32个字节    \n>85 07 00 00 01 00 00 00 14 05 00 00 00 00 00 00   \n3E 16 00 00 00 00 00 00 5A 9C 20 00 00 00 00 00   \n\n类类型：85 07 00 00     //0x0785，指向type_ids的索引    \n访问标志：01 00 00 00   //0x1，public   \n父类类型：14 05 00 00   //0x0514，指向type_ids的索引    \n接口偏移：00 00 00 00   //0x0，指向type_ids的索引，class不为interface,此项值为0   \n源文件名：3E 16 00 00   //0x163e，指向string_ids的索引,string_ids[5094]，MainActivity.java    \n注解偏移：00 00 00 00   //0x0，指向DexAnnotationsDirectoryItem结构，若无此项内容，该值为0   \n类数据偏移：5A 9C 20 00 //0x209c5a，指向DexClassData结构的偏移    \n类静态数据偏移：00 00 00 00 //0x0，指向DexEncodedArray结构的偏移    \n\n查看类数据：（0x209c5a）  \n>00 02 01 02 8D 67 00 01 00 9B 79 81 80 04 8C E8   \n4B 9C 79 01 A4 E8 4B 02 04 80 E9 4B 03 04 00 04   \n01 04 02 02 04 02 04 01 02 1E 04 FF 01 37 6C 21   \n01 37 6D 21 04 04 05 04 03 04 02 04 04 0C 64 27   \n00 02 7F 64 7A 00 02 7F 64 7C 00 02 7F 64 7D 00   \n02 7F 64 7E 00 02 7F 64 7F 00 02 7F 64 80 00 02   \n7F 64 81 00 02 7F 64 82 00 02 7F 64 83 00 02 7F   \n64 84 00 02 7F 64     \n...\nclassDataHeader:\n静态字段个数：0\n实例字段个数：2\n非虚方法：1\n虚方法：2\n\n字段：...\n\n非虚方法：...\n\n虚方法：...\n\n由该MainActivity类定义的偏移位置和class_defs_off偏移位置知：    \n(0x68cd4-0x5db34)/32=1421,即MainActivity是dex文件中第1422个类定义，在类定义列表中的下标为1421 \n对应methods_offsets_pointer[1421]\n\nmethods_offsets_pointer[1421]:C4 7E 23 00   //0X237EC4,该类对应的OatClass相对于oatdata的偏移    \n推出MainActivity对应的OatClass在文件中的偏移：0x237ec4+0x1000 = 0x238ec4   \n\nMainActivity对应的OatClass:(一个direct方法，一个virtual方法)   \n>08 00 00 00 B9 31 48 00 E0 7E 23 00 11 32 48 00    \nEF 5A 27 00 61 33 48 00 23 5B 27 00 09 00 03 00   \n28 01 3A 00 08 01 09 00 05 00 36 07 2C 07 48 00   \n08 06 24 06 09 00 06 00 62 00 34 06 08 06 24 06   \n3E 06 5A 06 09 00 03 00 5A 00 2C 07 08 07 09 00   \n0A 00 82 7A 9E 7A BC 00 C4 00 D6 00 CE 62 94 7A   \n72 6A 08 60 78 7A 00 00 00 00 09 00   \n...\n\n//TODO\nstatus:08 00  //kStatusVerified\ntype:00 00    //kOatClassAllCompiled(没有bitmap结构)\nOatMethodOffSets[0]:B9 31 48 00 E0 7E 23 00\nOatMethodOffSets[1]:11 32 48 00 EF 5A 27 00\n...\n\nOatClass结构分析：  \n```\n//art/runtime/oat_file.h\nclass OatClass {\n    ...\n    private:\n    OatClass(\n        const OatFile* oat_file,\n        mirror::Class::Status status,\n        OatClassType type,\n        uint32_t bitmap_size,\n        const uint32_t* bitmap_pointer,\n        const OatMethodOffsets* methods_pointer\n    );\n    const OatFile*  oat_file_;\n    mirror::Class:Status status_;    //2 bytes\n    OatClassType type_;  //2 byes\n    const uint32_t* bitmap_;\n    const OatMethodOffsets* methods_pointer_;//方法的偏移数组，指向相应的native code，4bytes，OatMethodOffset的个数是该类被编译为native code的个数\n    friend class OatDexFile;\n}\n```\n```\n// art/runtime/mirror/class.h\n enum Status {\n    kStatusRetired = -2,\n    kStatusError = -1,\n    kStatusNotReady = 0,\n    kStatusIdx = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.\n    kStatusLoaded = 2,  // DEX idx values resolved.\n    kStatusResolving = 3,  // Just cloned from temporary class object.\n    kStatusResolved = 4,  // Part of linking.\n    kStatusVerifying = 5,  // In the process of being verified.\n    kStatusRetryVerificationAtRuntime = 6,  // Compile time verification failed, retry at runtime.\n    kStatusVerifyingAtRuntime = 7,  // Retrying verification at runtime.\n    kStatusVerified = 8,  // Logically part of linking; done pre-init.\n    kStatusInitializing = 9,  // Class init in progress.\n    kStatusInitialized = 10,  // Ready to go.\n    kStatusMax = 11,\n};\n```\n```\n// art/runtime/oat.h （OatClass类型不一样，methods_pointer_数组中的偏移位置的计算方式不一样）\nenum OatClassType {\n  kOatClassAllCompiled = 0,   // OatClass is followed by an OatMethodOffsets for each method.\n  kOatClassSomeCompiled = 1,  // A bitmap of which OatMethodOffsets are present follows the OatClass.\n  kOatClassNoneCompiled = 2,  // All methods are interpretted so no OatMethodOffsets are necessary.\n  kOatClassMax = 3,\n};\n```\n```\n// art/runtime/oat.h\nclass PACKED(4) OatMethodOffsets {\n public:\n  OatMethodOffsets();\n\n  OatMethodOffsets(uint32_t code_offset,\n                   uint32_t gc_map_offset);\n\n  ~OatMethodOffsets();\n\n  uint32_t code_offset_;//native code相对于oatdata段的偏移\n  uint32_t gc_map_offset_;\n};\n```\n// OatMethodOffsets 计算方法    \n//函数参数method_idx是方法在dex表示的类中的偏移，比如类的第0个方法method_index为0，第一个方法为method_index为1，依次类推。    \n由于在OatClass中没有保存类中方法的数目，因而没有检查method_index的边界。    \n```\nconst OatMethodOffsets* OatFile::OatClass::GetOatMethodOffsets(uint32_t method_index) const {\n  // NOTE: We don't keep the number of methods and cannot do a bounds check for method_index.\n  if (methods_pointer_ == nullptr) {//没有编译成native code\n    CHECK_EQ(kOatClassNoneCompiled, type_);\n    return nullptr;\n  }\n  size_t methods_pointer_index;\n  if (bitmap_ == nullptr) {//该类所有方法被编译成native code\n    CHECK_EQ(kOatClassAllCompiled, type_);\n    methods_pointer_index = method_index;\n  } else {\n    CHECK_EQ(kOatClassSomeCompiled, type_);\n    if (!BitVector::IsBitSet(bitmap_, method_index)) {//该方法没有对应的native code\n      return nullptr;\n    }\n    size_t num_set_bits = BitVector::NumSetBits(bitmap_, method_index);//使用bitmap记录哪些方法被编译成了native code\n    methods_pointer_index = num_set_bits;//找到相应的索引\n  }\n  const OatMethodOffsets& oat_method_offsets = methods_pointer_[methods_pointer_index];\n  return &oat_method_offsets;\n}\n```\n```\n//art/runtime/base/bit_vector.cc\nuint32_t BitVector::NumSetBits(const uint32_t* storage, uint32_t end) {\n  uint32_t word_end = end >> 5; // end/32\n  uint32_t partial_word_bits = end & 0x1f;// end%32\n\n  uint32_t count = 0u;// 为1的位的数目\n  for (uint32_t word = 0u; word < word_end; word++) {//先算前word_end个字中为1的位的数目，再算不满一个字的前partial_word_bits位中为1的位的数目\n    count += POPCOUNT(storage[word]);\n  }\n  if (partial_word_bits != 0u) {\n    count += POPCOUNT(storage[word_end] & ~(0xffffffffu << partial_word_bits));\n  }\n  return count;\n}\n```\nBitmap的作用：\n* Bitmaps are used to represent which methods are compiled.\n* Each bit represents every method in the class ,starting with direct methods,then virtual methods.\n* If bit it is set,the method is compiled.\n\n从OatClass中获取指定方法的native code时，返回的是OatMethod对象，源码如下：    \n/art/runtime/oat_file.cc\n```\n//method_index描述的是目标方法在类中的编号\nconst OatFile::OatMethod OatFile::OatClass::GetOatMethod(uint32_t method_index) const {\n  const OatMethodOffsets* oat_method_offsets = GetOatMethodOffsets(method_index);//获取方法偏移\n  if (oat_method_offsets == nullptr) {\n    return OatMethod(nullptr, 0, 0);\n  }\n  if (oat_file_->IsExecutable() ||\n      Runtime::Current() == nullptr ||        // This case applies for oatdump.\n      Runtime::Current()->IsCompiler()) {\n    return OatMethod(\n        oat_file_->Begin(),\n        oat_method_offsets->code_offset_,\n        oat_method_offsets->gc_map_offset_);\n  } else {\n    // We aren't allowed to use the compiled code. We just force it down the interpreted version.\n    return OatMethod(oat_file_->Begin(), 0, 0);\n  }\n}\n```\n```\n/art/runtime/oat_file.h\nclass OatMethod{\n    public:\n    ...\n    OatMethod(\n        const byte* base,\n        const uint32_t code_offset,\n        const uint32_t gc_map_offset\n    );\n    OatMethod(){}\n    private:\n    ...\n    const byte* begin_; //oatdata段开始位置\n    uint32_t code_offset_;  //OatMethodOffsets->code_offset_\n    uint32_t native_gc_map_offset_;\n    friend class OatClass;\n};\n```\n然后就可以通过OatMethod来定位到方法的native code了（begin_+code_offset_）。\n\n总结：  \n* Oat文件其实就是类型为shared object 的Elf文件，首先有一个Elf Header，Elf Header中e_phoff字段指向了program header talbe，e_shoff字段指向了section header table；\n* section header table中有一个名字为.dynsym的section head，该section head描述的section是符号表；\n* Oat文件导出了3个符号：oatdata，oatexec，oatlastword；\n* oatdata指向oatdata段，该区域存的是只读数据，包括 OatHeader，dex相关信息，dex类中方法与native code的映射关系（由 OatClass表示），通过OatClass可以找到对应方法的native code；\n* oatexec指向oatexec段，该区域存的是方法的native code，是可执行的；\n* oatlastword指向oatexec段的最后一个字的开始地址。即oatexec段的结束地址=oatlastword->st_value+3。\n","tags":["Android Oat"]},{"title":"Hello World","url":"/2018/12/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]