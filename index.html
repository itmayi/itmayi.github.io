<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="榆木的博客">
<meta name="keywords" content="随笔">
<meta property="og:type" content="website">
<meta property="og:title" content="Heinz Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Heinz Blog">
<meta property="og:description" content="榆木的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heinz Blog">
<meta name="twitter:description" content="榆木的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Heinz Blog - 记录每一段岁月的美好！</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heinz Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">记录每一段岁月的美好！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/TLS-SSL协议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/TLS-SSL协议/" itemprop="url">TLS/SSL协议</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-08T10:27:24+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/08/TLS-SSL协议/" class="leancloud_visitors" data-flag-title="TLS/SSL协议">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是SSL、TLS、HTTPS"><a href="#什么是SSL、TLS、HTTPS" class="headerlink" title="什么是SSL、TLS、HTTPS"></a>什么是SSL、TLS、HTTPS</h1><p>SSL:Secure Sockets Layer（安全套接层）最初由Netscape开发，早在1995年以SSL2.0的方式发布（SSL1.0从未对公众发布）。在一些漏洞被发现后，版本2.0在1996年被版本3.0取代。</p>
<p>TLS:Transport Layer Security（安全传输层）以SSL3.0为基础在1999年作为SSL的新版本推出。同时SSL3.0在2015年被IEFT组织废弃。TLS1.0通常被标识为SSL3.1，TLS1.1为SSL3.2，TLS 1.2为SSL3.3。</p>
<p>HTTPS：HTTP OVER TLS（建立在TLS之上的HTTP协议）。</p>
<h1 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h1><p>HTTP连接方式简单，无状态，使用80端口，HTTPS由SSL+HTTP构建的可实现身份认证和安全传输的网络协议，使用443端口。</p>
<p>HTTPS能够提供：</p>
<ul>
<li><p>数据完整性：内容传输经过完整性校验</p>
</li>
<li><p>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</p>
</li>
<li><p>身份认证：第三方无法伪造服务端(客户端)身份</p>
</li>
</ul>
<p>其中，数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。</p>
<p>完整的HTTPS连接建立大概需要以下几步：  </p>
<ol>
<li>DNS查询，获取IP地址</li>
<li>TCP握手，建立连接</li>
<li>TLS握手，确定加密方式和密钥</li>
<li>建立HTTP连接，交换数据</li>
</ol>
<h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>证书包含的信息：</p>
<ol>
<li>证书信息：序列号，过期日期</li>
<li>所有者信息：姓名等</li>
<li>所有者公钥</li>
</ol>
<p>为什么需要服务端发送证书给客户端？</p>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<p>客户端为什么需要验证接收到的证书？</p>
<p>为了防止中间人攻击。攻击者拦截服务端响应，将伪造证书发送给客户端，客户端若未验证地使用证书中的公钥加密传输数据，就会被攻击者通过私钥解密得到明文数据。</p>
<p>客户端如何验证接收到的证书？  </p>
<p>通过数字签名(将一段数据通过哈希和私钥加密后生成数字签名)。消息发送方通过将一段文本和数字签名一起发送给消息接收方，接收方接收到数据后，将文本通过哈希得到散列值，同时使用公钥解密数字签名得到原散列值，通过比对计算得到的散列值和原散列值判断接收到的文本是否为对应的消息发送方发出的。</p>
<p>该验证的前提是，消息接收方知道消息发送方的公钥。公钥和消息本身一样，不能直接通过不安全的网络发送给消息接收方。</p>
<p>此时就需要证书颁发机构（Certifate Authority，简称CA），客户端内置了所有受信任CA的证书，CA对服务端的公钥(和其他信息)数字签名后生成证书。</p>
<p>服务端将证书发送给客户端后，客户端使用证书公钥验证证书签名。</p>
<p>客户端信任CA，CA信任服务端，客户端信任服务端，从而形成信任链（chain of trust）。</p>
<p>事实上，客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链(Certificate Chain)给客户端。</p>
<h1 id="HTTPS基本原理"><a href="#HTTPS基本原理" class="headerlink" title="HTTPS基本原理"></a>HTTPS基本原理</h1><p><img src="https://www.wosign.com/info/info_images/20170606135810.png" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/数据传输协议框架/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/数据传输协议框架/" itemprop="url">数据传输协议框架</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T22:11:39+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/数据传输协议框架/" class="leancloud_visitors" data-flag-title="数据传输协议框架">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h1><p>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。支持python、Java、c++等语言。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="定义-proto文件"><a href="#定义-proto文件" class="headerlink" title="定义.proto文件"></a>定义.proto文件</h3><p>.proto文件中定义着一系列协议中的实体结构：</p>
<ul>
<li><p>message关键字表示一个实体结构，由多个字段组成</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">option java_package = &quot;com.example.tutorial&quot;;</span><br><span class="line">option java_outer_classname = &quot;AddressBookProtos&quot;;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    required string name = 1;</span><br><span class="line">    required int32 id = 2;</span><br><span class="line">    optional string email = 3;</span><br><span class="line"></span><br><span class="line">    enum PhoneType &#123;</span><br><span class="line">        MOBILE = 0;</span><br><span class="line">        HOME = 1;</span><br><span class="line">        WORK = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        required string number = 1;</span><br><span class="line">        optional PhoneType type = 2 [default = HOME];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeated PhoneNumber phones = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">    repeated Person people = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段包含修饰符、数据类型、唯一标识、初始值。</p>
<p>  三种修饰符：required、optional、repeated</p>
<p>  支持的数据类型：<br>  <img src="https://note.youdao.com/yws/api/personal/file/WEBd038acafb6eb2ec0003778c5413c963b?method=download&amp;shareKey=d4cdfcbeba2aaf600b311182eb01e5fb" alt="image"></p>
</li>
</ul>
<h3 id="编译-proto"><a href="#编译-proto" class="headerlink" title="编译.proto"></a>编译.proto</h3><p>使用protocol buffer的编译器将.proto文件编译为目标语言。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/xxx.proto</span><br></pre></td></tr></table></figure></p>
<p>-I 指定源路径，–java_out 选项指定生成java文件，编译完成会在目标路径下生成.java文件。</p>
<h3 id="Protocol-Buffer-API"><a href="#Protocol-Buffer-API" class="headerlink" title="Protocol Buffer API"></a>Protocol Buffer API</h3><p>.java 文件部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// required string name = 1;</span><br><span class="line">public boolean hasName();</span><br><span class="line">public String getName();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// optional string email = 3;</span><br><span class="line">public boolean hasEmail();</span><br><span class="line">public String getEmail();</span><br></pre></td></tr></table></figure></p>
<p>Person.Builder类中也为每个字段生成getter和setter方法,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// required string name = 1;</span><br><span class="line">public boolean hasName();</span><br><span class="line">public java.lang.String getName();</span><br><span class="line">public Builder setName(String value);</span><br><span class="line">public Builder clearName();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>创建Person实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person john =</span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setName(&quot;John Doe&quot;)</span><br><span class="line">    .setAge(15)</span><br><span class="line">    .setEmail(&quot;jdoe@example.com&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p>
<p>message类和Builder类中内建的其他方法：</p>
<ul>
<li>isInitialized(): checks if all the required fields have been set.</li>
<li>toString(): returns a human-readable representation of the message, particularly useful for debugging</li>
<li>mergeFrom(Message other): (builder only) merges the contents of other into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.</li>
<li>clear(): (builder only) clears all the fields back to the empty state.</li>
</ul>
<h3 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h3><ul>
<li>byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes</li>
<li>static Person parseFrom(byte[] data);: parses a message from the given byte array</li>
<li>void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream</li>
<li>static Person parseFrom(InputStream input);: reads and parses a message from an InputStream</li>
</ul>
<h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h2><h3 id="write-a-message"><a href="#write-a-message" class="headerlink" title="write a message"></a>write a message</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line">import com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">class AddPerson &#123;</span><br><span class="line">  // This function fills in a Person message based on user input.</span><br><span class="line">  static Person PromptForAddress(BufferedReader stdin,</span><br><span class="line">                                 PrintStream stdout) throws IOException &#123;</span><br><span class="line">    Person.Builder person = Person.newBuilder();</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter person ID: &quot;);</span><br><span class="line">    person.setId(Integer.valueOf(stdin.readLine()));</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter name: &quot;);</span><br><span class="line">    person.setName(stdin.readLine());</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter email address (blank for none): &quot;);</span><br><span class="line">    String email = stdin.readLine();</span><br><span class="line">    if (email.length() &gt; 0) &#123;</span><br><span class="line">      person.setEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      stdout.print(&quot;Enter a phone number (or leave blank to finish): &quot;);</span><br><span class="line">      String number = stdin.readLine();</span><br><span class="line">      if (number.length() == 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Person.PhoneNumber.Builder phoneNumber =</span><br><span class="line">        Person.PhoneNumber.newBuilder().setNumber(number);</span><br><span class="line"></span><br><span class="line">      stdout.print(&quot;Is this a mobile, home, or work phone? &quot;);</span><br><span class="line">      String type = stdin.readLine();</span><br><span class="line">      if (type.equals(&quot;mobile&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.MOBILE);</span><br><span class="line">      &#125; else if (type.equals(&quot;home&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.HOME);</span><br><span class="line">      &#125; else if (type.equals(&quot;work&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.WORK);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        stdout.println(&quot;Unknown phone type.  Using default.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      person.addPhones(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return person.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Main function:  Reads the entire address book from a file,</span><br><span class="line">  //   adds one person based on user input, then writes it back out to the same</span><br><span class="line">  //   file.</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    if (args.length != 1) &#123;</span><br><span class="line">      System.err.println(&quot;Usage:  AddPerson ADDRESS_BOOK_FILE&quot;);</span><br><span class="line">      System.exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddressBook.Builder addressBook = AddressBook.newBuilder();</span><br><span class="line"></span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    try &#123;</span><br><span class="line">      addressBook.mergeFrom(new FileInputStream(args[0]));</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(args[0] + &quot;: File not found.  Creating a new file.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Add an address.</span><br><span class="line">    addressBook.addPeople(</span><br><span class="line">      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),</span><br><span class="line">                       System.out));</span><br><span class="line"></span><br><span class="line">    // Write the new address book back to disk.</span><br><span class="line">    FileOutputStream output = new FileOutputStream(args[0]);</span><br><span class="line">    addressBook.build().writeTo(output);</span><br><span class="line">    output.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="read-a-message"><a href="#read-a-message" class="headerlink" title="read a message"></a>read a message</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line">import com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">class ListPeople &#123;</span><br><span class="line">  // Iterates though all people in the AddressBook and prints info about them.</span><br><span class="line">  static void Print(AddressBook addressBook) &#123;</span><br><span class="line">    for (Person person: addressBook.getPeopleList()) &#123;</span><br><span class="line">      System.out.println(&quot;Person ID: &quot; + person.getId());</span><br><span class="line">      System.out.println(&quot;  Name: &quot; + person.getName());</span><br><span class="line">      if (person.hasEmail()) &#123;</span><br><span class="line">        System.out.println(&quot;  E-mail address: &quot; + person.getEmail());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">        switch (phoneNumber.getType()) &#123;</span><br><span class="line">          case MOBILE:</span><br><span class="line">            System.out.print(&quot;  Mobile phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HOME:</span><br><span class="line">            System.out.print(&quot;  Home phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">          case WORK:</span><br><span class="line">            System.out.print(&quot;  Work phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(phoneNumber.getNumber());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Main function:  Reads the entire address book from a file and prints all</span><br><span class="line">  //   the information inside.</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    if (args.length != 1) &#123;</span><br><span class="line">      System.err.println(&quot;Usage:  ListPeople ADDRESS_BOOK_FILE&quot;);</span><br><span class="line">      System.exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    AddressBook addressBook =</span><br><span class="line">      AddressBook.parseFrom(new FileInputStream(args[0]));</span><br><span class="line"></span><br><span class="line">    Print(addressBook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Flat-Buffer"><a href="#Flat-Buffer" class="headerlink" title="Flat Buffer"></a>Flat Buffer</h1><p>FlatBuffers是一个跨平台的序列化库，旨在实现最高的内存效率。实现了与 Protocol Buffers，Thrift，Apache Avro，SBE 和 Cap’n Proto 类似的序列化格式。它允许我们直接访问序列化数据，而无需先解析/解压缩，同时仍具有良好的向前/向后兼容性。其最初为 Android 游戏和注重性能的应用而开发了FlatBuffers。</p>
<p>FlatBuffers 的主要目标是避免反序列化。这是通过定义二进制数据协议来实现的，一种将定义好的将数据转换为二进制数据的方法。由该协议创建的二进制结构可以 wire 发送，并且无需进一步处理即可读取。相比较而言，在传输 JSON 时，我们需要将数据转换为字符串，通过 wire 发送，解析字符串，并将其转换为本地对象。Flatbuffers 不需要这些操作。你用二进制装入数据，发送相同的二进制文件，并直接从二进制文件读取。</p>
<p>尽管 FlatBuffers 有自己的接口定义语言来定义要与之序列化的数据，但它也支持 Protocol Buffers 中的 .proto格式。</p>
<p>在 schema 中定义对象类型，然后可以将它们编译为 C++ 或 Java 等各种主流语言，以实现零开销读写。FlatBuffers 还支持将 JSON 数据动态地分析到 buffer 中。</p>
<p>除了解析效率以外，二进制格式还带来了另一个优势，数据的二进制表示通常更具有效率。我们可以使用 4 字节的 UInt 而不是 10 个字符来存储 10 位数字的整数。</p>
<p>FlatBuffers 与 Protocol Buffers 确实比较相似，主要的区别在于 FlatBuffers 在访问数据之前不需要解析/解包。两者代码也是一个数量级的。但是 Protocol Buffers 既没有可选的文本导入/导出功能，也没有 union 这个语言特性，这两点 FlatBuffers 都有。</p>
<p>FlatBuffers 专注于移动硬件（内存大小和内存带宽比桌面端硬件更受限制），以及具有最高性能需求的应用程序：游戏。</p>
<h2 id="支持设备"><a href="#支持设备" class="headerlink" title="支持设备"></a>支持设备</h2><p>Windows、mmacOS、Linux、Android等</p>
<h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>Python、Java、c++等</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="编写想要序列化的数据结构的schema（IDL-接口定义）文件"><a href="#编写想要序列化的数据结构的schema（IDL-接口定义）文件" class="headerlink" title="编写想要序列化的数据结构的schema（IDL,接口定义）文件"></a>编写想要序列化的数据结构的schema（IDL,接口定义）文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// example IDL file</span><br><span class="line"></span><br><span class="line">namespace MyGame;</span><br><span class="line"></span><br><span class="line">attribute &quot;priority&quot;;</span><br><span class="line"></span><br><span class="line">enum Color : byte &#123; Red = 1, Green, Blue &#125;</span><br><span class="line"></span><br><span class="line">union Any &#123; Monster, Weapon, Pickup &#125;</span><br><span class="line"></span><br><span class="line">struct Vec3 &#123;</span><br><span class="line">  x:float;</span><br><span class="line">  y:float;</span><br><span class="line">  z:float;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:short = 150;</span><br><span class="line">  hp:short = 100;</span><br><span class="line">  name:string;</span><br><span class="line">  friendly:bool = false (deprecated, priority: 1);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  test:Any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure>
<p>在上述的schema文件中有两个重要的概念，struct和table。</p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>Table 是在 FlatBuffers 中定义对象的主要方式，由一个名称（这里是 Monster）和一个字段列表组成。每个字段都有一个名称，一个类型和一个可选的默认值（如果省略，它默认为 0 / NULL）。</p>
<p>Table 中每个字段都是可选 optional 的：它不必出现在 wire 表示中，并且可以选择省略每个单独对象的字段。这种设计也是 FlatBuffer 的前向和后向兼容机制。</p>
<p>假设当前schema是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int; b:int; &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><p>只能在表定义的末尾添加新的字段。旧数据仍会正确读取，并在读取时为您提供默认值。旧代码将简单地忽略新字段。如果希望灵活地使用 schema 中字段的任何顺序，您可以手动分配ids。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int; b:int; c:int; &#125;</span><br><span class="line">或者</span><br><span class="line">table &#123; c:int (id: 2); a:int (id: 0); b:int (id: 1); &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><p>不能从 schema 中删除不再使用的字段，但可以简单地停止将它们写入数据中。此外，可以将它们标记为 deprecated，如上例所示，被标记的字段不会再生成 C ++ 的访问器，从而强制该字段不再被使用。</p>
<h5 id="更改字段"><a href="#更改字段" class="headerlink" title="更改字段"></a>更改字段</h5><p>可以更改字段名称和 table 名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:uint; b:uint; &#125;</span><br></pre></td></tr></table></figure></p>
<p>直接修改字段的类型，这样做可能可行，也有情况不行。只有在类型改变是相同大小的情况下，是可行的。如果旧数据不包含任何负数，这将是安全的，如果包含了负数，这样改变会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int = 1; b:int = 2; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样修改不可行。任何写入数值为 0 的旧数据都不会再写入 buffer，并依赖于重新创建的默认值。现在这些值将显示为1和2。有些情况下可能不会出错，但必须小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; aa:int; bb:int; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种修改方法，修改原来的变量名以后，可能会出现问题。由于已经重命名了字段，这将破坏所有使用此版本 schema 的代码（和 JSON 文件），这与实际的二进制缓冲区不兼容。</p>
<p>table 是 FlatBuffers 的基石，因为对于大多数需要序列化应用来说，数据结构改变是必不可少的。通常情况下，处理数据结构的变更在大多数序列化解决方案的解析过程中可以透明地完成的。但是一个 FlatBuffer 在被访问之前不会被分析。</p>
<p>为了解决数据结构变更的问题，table 通过 vtable 间接访问字段。每个 table 都带有一个 vtable（可以在具有相同布局的多个 table 之间共享），并且包含存储此特定类型 vtable 实例的字段的信息。vtable 还可能表明该字段不存在（因为此 FlatBuffer 是使用旧版本的软件编写的，仅仅因为信息对于此实例不是必需的，或者被视为已弃用），在这种情况下会返回默认值。</p>
<p>table 的内存开销很小（因为 vtables 很小并且共享）访问成本也很小（间接访问），但是提供了很大的灵活性。table 甚至可能比等价的 struct 花费更少的内存，因为字段在等于默认值时不需要存储在 buffer 中。</p>
<h4 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h4><p>tructs 和 table 非常相似，只是 structs 没有任何字段是可选的（所以也没有默认值），字段可能不会被添加或被弃用。结构可能只包含标量或其他结构。如果确定以后不会进行任何更改。structs 使用的内存少于 table，并且访问速度更快（它们总是以串联方式存储在其父对象中，并且不使用虚拟表）。  </p>
<p>structs 不提供前向/后向兼容性，但占用内存更小。对于不太可能改变的非常小的对象（例如坐标对或RGBA颜色）存成 struct 是非常有用的。</p>
<h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>FlatBuffers 支持的 标量 类型有以下几种：</p>
<ul>
<li>8 bit: byte (int8), ubyte (uint8), bool</li>
<li>16 bit: short (int16), ushort (uint16)</li>
<li>32 bit: int (int32), uint (uint32), float (float32)</li>
<li>64 bit: long (int64), ulong (uint64), double (float64)</li>
</ul>
<p>括号里面的名字对应的是类型的别名。</p>
<p>FlatBuffers 支持的 非标量 类型有以下几种：</p>
<ul>
<li>任何类型的数组。不过不支持嵌套数组，可以用 table 内定义数组的方式来取代嵌套数组。</li>
<li>UTF-8 和 7-bit ASCII 的字符串。其他格式的编码字符串或者二进制数据，需要用 [byte] 或者 [ubyte] 来替代。</li>
<li>table、structs、enums、unions</li>
</ul>
<p>标量类型的字段有默认值，非标量的字段(string/vector/table)如果没有值的话，默认值为 NULL。</p>
<p>一旦一个类型声明了，尽量不要改变它的类型，一旦改变了，很可能就会出现错误。上面也提到过了，如果把 int 改成 uint，数据如果有负数，那么就会出错。</p>
<h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p>定义一系列命名常量，每个命名常量可以分别给一个定值，也可以默认的从前一个值增加一。默认的第一个值是 0。正如在上面例子中看到的枚举声明，使用:(上面例子中是 byte 字节）指定枚举的基本整型，然后确定用这个枚举类型声明的每个字段的类型。</p>
<p>通常，只应添加枚举值，不要去删除枚举值（对枚举不存在弃用一说）。这需要开发者代码通过处理未知的枚举值来自行处理向前兼容性的问题</p>
<h4 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h4><p>这个是 Protocol buffers 中还不支持的类型。</p>
<p>union 是 C 语言中的概念，一个 union 中可以放置多种类型，共同使用一个内存区域。</p>
<p>但是在 FlatBuffers 中，Unions 可以像 Enums 一样共享许多属性，但不是常量的新名称，而是使用 table 的名称。可以声明一个 Unions 字段，该字段可以包含对这些类型中的任何一个的引用，即这块内存区域只能由其中一种类型使用。另外还会生成一个带有后缀 _type 的隐藏字段，该字段包含相应的枚举值，从而可以在运行时知道要将哪些类型转换为类型。</p>
<p>union 跟 enum 比较类似，但是 union 包含的是 table，enum 包含的是 scalar或者 struct。</p>
<p>Unions 是一种能够在一个 FlatBuffer 中发送多种消息类型的好方法。请注意，因为union 字段实际上是两个字段(有一个隐藏字段)，所以它必须始终是表的一部分，它本身不能作为 FlatBuffer 的 root。</p>
<h3 id="使用flatc编译"><a href="#使用flatc编译" class="headerlink" title="使用flatc编译"></a>使用flatc编译</h3><p>使用FlatBuffer编译器flatc生成数据结构源代码（C++头文件或者Java类）</p>
<h3 id="使用相关接口读取或写入flat-buffer"><a href="#使用相关接口读取或写入flat-buffer" class="headerlink" title="使用相关接口读取或写入flat buffer"></a>使用相关接口读取或写入flat buffer</h3><p><a href="https://github.com/google/flatbuffers/blob/master/tests/JavaTest.java" target="_blank" rel="noopener">https://github.com/google/flatbuffers/blob/master/tests/JavaTest.java</a></p>
<h1 id="Protocol-Buffer-与-Flat-Buffer"><a href="#Protocol-Buffer-与-Flat-Buffer" class="headerlink" title="Protocol Buffer 与 Flat Buffer"></a>Protocol Buffer 与 Flat Buffer</h1><ul>
<li>弃用的字段，不用手动分配字段的 ID。在 .proto 中扩展一个对象，需要在数字中寻找一个空闲的空位（因为 protocol buffers 有更紧凑的表示方式，所以必须选择更小的数字）。除了这点不方便之外，它还使得删除字段成为问题：如果保留它们，从语意表达上不是很明显的表达出这个字段不能读写了，保留它们，还会生成访问器。如果删除它们，就会有出现严重 bug 的风险，因为当有人重用了这些 ID，会导致读取到旧的数据，这样数据会发生错乱。</li>
<li>FlatBuffers 区分 table 和 struct。所有 table 字段都是可选的，并且所有 struct 字段都是必需的。</li>
<li>FlatBuffers 具有原生数组类型而不是 repeated。这给你一个长度，而不必收集所有项目，并且在标量的情况下提供更紧凑的表示，并且确保相邻性。</li>
<li>FlatBuffers 具有 union 类型，这个也是 protocol buffers 没有的。一个 union 可以替代很多个 optional 字段，这样也可以节约每个字段都要一一检查的时间。</li>
<li>FlatBuffers 能够为所有标量定义默认值，而不必在每次访问时处理它们的 optional，并且默认值不存在 buffer 中，也不用担心空间的问题。</li>
<li>可以统一处理模式和数据定义（并且和 JSON 兼容）的解析器。protocol buffers 不兼容 JSON。FlatBuffers 的 flatc 编译器可带的参数也更加强大，具体可带参数列表见此文档</li>
<li>schema 扩展了一些 protocol buffers 没有的 Attributes</li>
</ul>
<p>除去功能上的不同，再就是一些 schema 语法上的细微不同：</p>
<ul>
<li>定义对象，protocol buffers 是 message，FlatBuffers 是 table</li>
<li>ID，protocol buffers 默认是从 1 开始标号，FlatBuffers 默认从 0 开始</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/wireshark数据包分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/wireshark数据包分析/" itemprop="url">wireshark数据包分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T10:19:43+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/wireshark数据包分析/" class="leancloud_visitors" data-flag-title="wireshark数据包分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP：（TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP 是面向连接的所以只能用于点对点的通讯）源IP地址：发送包的IP地址；目的IP地址：接收包的IP地址；源端口：源系统上的连接的端口；目的端口：目的系统上的连接的端口。  TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN，ACK。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。第一次握手：建立连接时，客户端发送SYN包(SEQ=x)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN(ACK=x+1),同时自己也送一个SYN包(SEQ=y),即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=y+1),此包发送完毕，客户端和服务器进入Established状态，完成三次握手</p>
<h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114092218164" alt="image"><br>A. 第一行，帧Frame 36838 指的是要发送的数据块，其中，所抓帧的序号为36838，捕获字节数等于传送字节数：70字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为88:5d:90:00:00:25；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.21.175；目标IP地址为192.168.21.156；</p>
<p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(10086)；目标端口(50132)；序列号(1361)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为16；</p>
<p>E. 第五行，数据共有16字节</p>
<h4 id="Frame信息分析"><a href="#Frame信息分析" class="headerlink" title="Frame信息分析"></a>Frame信息分析</h4><p><img src="https://img-blog.csdn.net/20170114104835215" alt="image"><br>A. Arrival Time：到达时间，值为Jan 14, 2017 08:52:56.239204000</p>
<p>B. EPoch Time：信息出现时间，值为1484355176.239204000秒</p>
<p>C. [ Time delta from previous captured frame: 0.001472000 seconds] ：与之前捕获的数据帧时间差：0.001472000秒；</p>
<pre><code>[Time delta from previous displayed frame: 0.001472000 seconds]：与之前显示的帧时间差： 0.001472000秒；

[Time since reference or first frame: 1278.276505000 seconds]：距参考帧或第一帧的时间差：1278.276505000秒；
</code></pre><p>D. Frame Number: 36838，帧编号为36838；</p>
<p>E. Frame Length: 70 bytes (560 bits)，帧长度为70字节；</p>
<pre><code>Capture Length: 70 bytes (560 bits)，捕获到的长度为70字节；
</code></pre><p>F. [Frame is marked: False]，帧标记：无；</p>
<pre><code>[Frame is ignored: False]，帧被忽略：无；
</code></pre><p>G. [Protocols in frame: eth:ip:tcp:data]，协议帧：eth(以太网)、IP、tcp、data</p>
<p>H. [Coloring Rule Name: TCP]，色彩规则名称：TCP；</p>
<pre><code>[Coloring Rule String: tcp]，色彩规则字符串：TCP；
</code></pre><h4 id="Ethernet-II信息分析"><a href="#Ethernet-II信息分析" class="headerlink" title="Ethernet II信息分析"></a>Ethernet II信息分析</h4><p><img src="https://img-blog.csdn.net/20170114111317125" alt="iamge"><br>A. Destination: AsrockIn_b5:b9:92 (00:25:22:b5:b9:92)，目标Mac地址为00:25:22:b5:b9:92</p>
<p>B. Source: 88:5d:90:00:00:25 (88:5d:90:00:00:25)，源Mac地址为88:5d:90:00:00:25</p>
<p>C. Type: IP (0x0800)，类型是IP数据包</p>
<h4 id="Ipv4协议信息分析"><a href="#Ipv4协议信息分析" class="headerlink" title="Ipv4协议信息分析"></a>Ipv4协议信息分析</h4><p><img src="https://img-blog.csdn.net/20170114112410438" alt="image"></p>
<p>A. Version: 4，IP协议版本为IPv4；</p>
<pre><code>Header length: 20 bytes，头部数据长度为20字节；
</code></pre><p>B. Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))，区分的服务领域：0x00 (默认的是DSCP：0x00)；</p>
<p>C. Flags: 0x02 (Don’t Fragment)，不支持分组；</p>
<pre><code>Fragment offset: 0，分组偏移量为0； 
</code></pre><p>D. Time to live: 64，TTL，生存时间为64，TTL通常表示包在被丢弃前最多能经过的路由器个数，当数据包传输到一个路由器之后，TTL就自动减1，如果减到0了还没有传送到目标主机，那么就自动丢失。</p>
<p>E. Header checksum: 0xcebd [correct]，头部校验和</p>
<p>F. Source: 192.168.21.175 (192.168.21.175)，源IP地址为192.168.21.175；</p>
<pre><code>Destination: 192.168.21.156 (192.168.21.156)，目标IP地址为192.168.21.156
</code></pre><h4 id="Trasmission-Control-Protocol信息分析"><a href="#Trasmission-Control-Protocol信息分析" class="headerlink" title="Trasmission Control Protocol信息分析"></a>Trasmission Control Protocol信息分析</h4><p>其中，对应的TCP首部的数据信息<br><img src="https://img-blog.csdn.net/20170114093029919" alt="image"></p>
<p>A. 端口号，数据传输的16位源端口号和16位目标端口号(用于寻找发端和收端应用进程)；</p>
<p>B. 相对序列号，该数据包的相对序列号为1361(此序列号用来确定传送数据的正确位置，且序列号用来侦测丢失的包)；下一个数据包的序列号是1377；</p>
<p>C. Acknowledgment number是32位确认序列号，值等于1表示数据包收到，确认有效；</p>
<p>D. 手动的数据包的头字节长度是20字节；</p>
<p>E. Flags，含6种标志；ACK：确认序号有效；SYN：同步序号用来发起一个连接；FIN：发端完成发送任务；RST：重新连接；PSH：接收方应该尽快将这个报文段交给应用层；URG：紧急指针(urgentpointer)有效；</p>
<p>F. window，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65536字节，上面显示窗口大小为1825字节；</p>
<p>G. Checksum，16位校验和，检验和覆盖了整个的TCP报文段，由发端计算和存储，并由收端进行验证</p>
<h4 id="Data信息分析"><a href="#Data信息分析" class="headerlink" title="Data信息分析"></a>Data信息分析</h4><p><img src="https://img-blog.csdn.net/20170114114030332" alt="image"></p>
<p>A.  TCP 报文段中的数据(该部分是可选的)，长度为16字节；</p>
<h2 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h2><p>链路层的信息上是以帧的形式进行传输的，帧封装了应用层、传输层、网络层的数据。而Wireshark抓到的就是链路层的一帧；</p>
<h3 id="封装包详细信息"><a href="#封装包详细信息" class="headerlink" title="封装包详细信息"></a>封装包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114120559104" alt="image"></p>
<p>A. 第一行，帧Frame 12411 指的是要发送的数据块，其中，所抓帧的序号为12411，捕获字节数等于传送字节数：233字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为220.181.57.234；目标IP地址为192.168.21.156；</p>
<p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(80)；目标端口(53985)；序列号(1)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为179；</p>
<p>E. 第五行，Http协议，也称超文本传输协议，是应用层</p>
<h4 id="Http请求报文分析"><a href="#Http请求报文分析" class="headerlink" title="Http请求报文分析"></a>Http请求报文分析</h4><p><img src="https://img-blog.csdn.net/20170114135028036" alt="image"></p>
<p>报文分析：<br><img src="https://img-blog.csdn.net/20170114135154140" alt="image"></p>
<p>在抓包分析过程中还发现了另外一些http请求报文中所特有的首部字段名，比如下面http请求报文中橙黄色首部字段名：</p>
<p><img src="https://img-blog.csdn.net/20170114135419581" alt="image"></p>
<h4 id="Http响应报文信息"><a href="#Http响应报文信息" class="headerlink" title="Http响应报文信息"></a>Http响应报文信息</h4><p><img src="https://img-blog.csdn.net/20170114134516128" alt="image"></p>
<p>报文分析：  </p>
<p><img src="https://img-blog.csdn.net/20170114134622379" alt="image"></p>
<h2 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h2><h3 id="封包详细信息-1"><a href="#封包详细信息-1" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114140200794" alt="image"></p>
<p>A. 第一行，帧Frame 12237 指的是要发送的数据块，其中，所抓帧的序号为12237，捕获字节数等于传送字节数：133字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.211.254；目标IP地址为192.168.211.84；</p>
<p>D. 第四行，UDP协议，是传输层；源端口domain(53)；目标端口(65219)；</p>
<p>E. 第五行，DNS协议，是应用层。</p>
<h4 id="DNS查询报文"><a href="#DNS查询报文" class="headerlink" title="DNS查询报文"></a>DNS查询报文</h4><p><img src="https://img-blog.csdn.net/20170114141159062" alt="iamge"></p>
<p>报文分析：<br><img src="https://img-blog.csdn.net/20170114141447421" alt="image"></p>
<h4 id="DNS响应报文"><a href="#DNS响应报文" class="headerlink" title="DNS响应报文"></a>DNS响应报文</h4><p><img src="https://img-blog.csdn.net/20170114141637002" alt="iamge"></p>
<p>报文分析：  </p>
<p><img src="https://img-blog.csdn.net/20170114142315693" alt="image"></p>
<h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p><img src="https://img-blog.csdn.net/20170118162817190" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/数据包分析基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/数据包分析基础/" itemprop="url">数据包分析基础</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T09:21:38+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/数据包分析基础/" class="leancloud_visitors" data-flag-title="数据包分析基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p>
<p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li>
</ul>
<p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p>
<h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p>
<p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p>
<p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p>
<h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p>
<p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p>
<p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p>
<p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>
<p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p>
<p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p>
<h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p>
<p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p>
<p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p>
<p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p>
<p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p>
<p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p>
<h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table>
<thead>
<tr>
<th>name</th>
<th>complete connection</th>
<th>stateful</th>
<th>selected replay</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p>
<h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p>
<ul>
<li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p>
</li>
<li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p>
</li>
<li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p>
</li>
<li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p>
</li>
<li><p>Tcpbirdge:桥接两个不同网段</p>
</li>
<li><p>Tcpcapinfo:pcap 文件解码器和编译器</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/http-http2协议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/http-http2协议/" itemprop="url">http2协议、数据包回放</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T09:21:38+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/http-http2协议/" class="leancloud_visitors" data-flag-title="http2协议、数据包回放">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p>
<p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li>
</ul>
<p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p>
<h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p>
<p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p>
<p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p>
<h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p>
<p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p>
<p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p>
<p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>
<p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p>
<p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p>
<h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p>
<p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p>
<p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p>
<p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p>
<p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p>
<p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p>
<h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table>
<thead>
<tr>
<th>name</th>
<th>complete connection</th>
<th>stateful</th>
<th>selected replay</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p>
<h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p>
<ul>
<li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p>
</li>
<li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p>
</li>
<li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p>
</li>
<li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p>
</li>
<li><p>Tcpbirdge:桥接两个不同网段</p>
</li>
<li><p>Tcpcapinfo:pcap 文件解码器和编译器</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础六/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础六/" itemprop="url">现代密码学基础六</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:54:24+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础六/" class="leancloud_visitors" data-flag-title="现代密码学基础六">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="攻击模式"><a href="#攻击模式" class="headerlink" title="攻击模式"></a>攻击模式</h2><p>在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。</p>
<p>这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类</p>
<ul>
<li>唯密文攻击：攻击者仅能获得一些加密过的密文。</li>
<li>已知明文攻击：攻击者有一些密文对应的明文。</li>
<li>选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。</li>
<li>选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。</li>
<li>相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后+ 的密文或明文。但是攻击者不知道这些密钥。</li>
</ul>
<h2 id="常见攻击方法"><a href="#常见攻击方法" class="headerlink" title="常见攻击方法"></a>常见攻击方法</h2><p>根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有</p>
<ul>
<li>暴力攻击</li>
<li>中间相遇攻击</li>
<li>线性分析</li>
<li>差分分析</li>
<li>不可能差分分析</li>
<li>积分分析</li>
<li>代数分析</li>
<li>相关密钥攻击</li>
<li>侧信道攻击</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础五/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础五/" itemprop="url">现代密码学基础五</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:47:48+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础五/" class="leancloud_visitors" data-flag-title="现代密码学基础五">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>在计算机世界中，我们可能会需要电子签名，因为我们大多数情况下会使用电子文件，那这时候怎么办呢？当然，我们仍然可以选择使用自己的名字。但其实还有另外一种方式，那就是采用数字签名，这种签名更加难以伪造，可信程度更高。数字签名的主要用处是确保消息确实来自于声称产生该消息的人。</p>
<p>数字签名依赖于非对称密码，因为我们必须确保一方能够做的事情，而另一方不能够做出这样的事情。其基本原理如下</p>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/signature/figure/Digital_Signature_diagram.png" alt="image"></p>
<h3 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h3><p>原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名。</p>
<h3 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h3><p>//TODO</p>
<h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><h3 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h3><p>使用该扩展名的证书采用<strong>二进制编码</strong>，当然，这些证书也可以使用 CER 或者 CRT 作为扩展名。</p>
<h3 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h3><p>使用该扩展名的证书采用 Base64 编码，文件的开始是一行 —–BEGIN。</p>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -outform der -in certificate.pem -out certificate.der</span><br><span class="line">openssl x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础四/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础四/" itemprop="url">现代密码学基础四</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:39:30+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础四/" class="leancloud_visitors" data-flag-title="现代密码学基础四">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。其一般模型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意长度(m)消息 -&gt; hash散列函数 -&gt; 固定长度h(m)</span><br></pre></td></tr></table></figure></p>
<p>显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。</p>
<p>散列值的目的如下</p>
<ul>
<li>确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。</li>
<li>冗余校验</li>
<li>单向口令文件，比如 linux 系统的密码</li>
<li>入侵检测和病毒检测中的特征码检测</li>
</ul>
<p>目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。</p>
<table>
<thead>
<tr>
<th>算法类型</th>
<th>输出 Hash 值长度</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>MD5    |128 bit / 256 bit<br>SHA1 |    160 bit<br>SHA256    | 256 bit<br>SHA512 |    512 bit</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/现代密码学基础三/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/现代密码学基础三/" itemprop="url">现代密码学基础三</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T13:20:51+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/05/现代密码学基础三/" class="leancloud_visitors" data-flag-title="现代密码学基础三">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。</p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p>
<p>RSA 算法的可靠性由<strong>极大整数因数分解</strong>的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="公钥与私钥的产生"><a href="#公钥与私钥的产生" class="headerlink" title="公钥与私钥的产生"></a>公钥与私钥的产生</h5><ul>
<li>随机选择两个不同大质数p和q，计算N=pxq</li>
<li>根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)</li>
<li>选择一个小于r的整数e，使e和r互质。并求得e关于r的模反元素，命名为d，有ed≡1(mod r)。</li>
<li>将p和q的记录销毁。</li>
</ul>
<p>此时，(N,e)是公钥，(N,d)是私钥。</p>
<p>注：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。</p>
<h5 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h5><p>首先需要将消息 m以一个双方约定好的格式转化为一个小于 N，且与N<br>互质的整数 n。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：<br>$n^e$ ≡ c (mod N)</p>
<h5 id="消息解密"><a href="#消息解密" class="headerlink" title="消息解密"></a>消息解密</h5><p>利用密钥 d进行解密。<br>$c^d$ ≡ n (mod N)</p>
<h4 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h4><ul>
<li><p>RSAtool</p>
<ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ius/rsatool.git</span><br><span class="line">cd rsatool</span><br><span class="line">python rsatool.py -h</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>RSA Converter</p>
<ul>
<li>根据给定的密钥对，生成pem文件</li>
<li>g根据n,e,d，生成p,q</li>
</ul>
</li>
<li><p>openssl</p>
<ul>
<li><p>查看公钥文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -in pubkey.pem -text -modulus</span><br></pre></td></tr></table></figure>
</li>
<li><p>解密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsautl -decrypt -inkey private.pem -in flag.enc -out flag</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分解整数工具</p>
<ul>
<li>网站分解<a href="http://factordb.com/" target="_blank" rel="noopener">http://factordb.com/</a> </li>
<li>命令行分解<a href="https://github.com/ryosan-470/factordb-pycli借用" target="_blank" rel="noopener">https://github.com/ryosan-470/factordb-pycli借用</a> factordb 数据库。</li>
<li><a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">https://sourceforge.net/projects/yafu/</a></li>
</ul>
</li>
<li><p>python库</p>
<ul>
<li>primefac<br>整数分解库，包含了很多整数分解的算法。</li>
<li>gmpy</li>
<li>gmpy2<br>安装时，可能会需要自己另行安装 mfpr 与 mpc 库。</li>
<li>pycrypto</li>
</ul>
</li>
</ul>
<h4 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h4><p>能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。</p>
<p>能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。</p>
<p>能量分析攻击分为： </p>
<ul>
<li>简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 </li>
<li>差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。</li>
</ul>
<h5 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h5><p>攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。</p>
<h3 id="背包加密"><a href="#背包加密" class="headerlink" title="背包加密"></a>背包加密</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $1_1$,$a_2$,…,$a_n$<br> 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题：<br> $x_1$$a_1$+$x_2$$a_2$+…+$x_n$$a_n$ = W</p>
<p> 其中$x_i$只能为0和1，显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。</p>
<p> 在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$,即可得到加密结果。</p>
<p> 但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。</p>
<p>但是当$a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件：第 i 个数大于前面所有数的和。</p>
<p>为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。</p>
<h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p>ECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有</p>
<ul>
<li>以素数为模的整数域 GF(p)，通常在通用处理器上更为有效。</li>
<li>特征为 2 的伽罗华域 GF（2^m），可以设计专门的硬件。</li>
</ul>
<h3 id="格密码"><a href="#格密码" class="headerlink" title="格密码"></a>格密码</h3><p>格在数学上至少有两种含义</p>
<ul>
<li>定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见 <a href="https://en.wikipedia.org/wiki/Lattice_(order)。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lattice_(order)。</a></li>
<li>群论中的定义，是 [Math Processing Error] 中的满足某种性质的子集。当然，也可以是其它群。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/现代密码学基础二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/现代密码学基础二/" itemprop="url">现代密码学基础二</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T11:50:21+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/04/现代密码学基础二/" class="leancloud_visitors" data-flag-title="现代密码学基础二">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所谓块加密就是每次加密一块明文，常见的加密算法有</p>
<ul>
<li>IDEA 加密</li>
<li>DES 加密</li>
<li>AES 加密</li>
</ul>
<p>块加密也是对称加密。</p>
<p>其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有<strong>复杂</strong>的加解密算法来加解密明密文。</p>
<p>而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助</p>
<ul>
<li>padding，即 padding 到指定分组长度</li>
<li>分组加密模式，即明文分组加密的方式。</li>
</ul>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。</p>
<h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下</p>
<ul>
<li>S 盒</li>
<li>乘法</li>
</ul>
<h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有</p>
<ul>
<li>线性变换</li>
<li>置换</li>
<li>移位，循环移位</li>
</ul>
<h3 id="常见加解密结构"><a href="#常见加解密结构" class="headerlink" title="常见加解密结构"></a>常见加解密结构</h3><p>目前块加密中主要使用的是结构是</p>
<ul>
<li>迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。</li>
</ul>
<h4 id="迭代结构"><a href="#迭代结构" class="headerlink" title="迭代结构"></a>迭代结构</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>迭代结构基本如下，一般包括三个部分</p>
<ul>
<li>密钥置换</li>
<li>轮加密函数</li>
<li>轮解密函数</li>
</ul>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/figure/iterated_cipher.png" alt="image"></p>
<h5 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h5><p>目前来说，轮函数主要有主要有以下设计方法</p>
<ul>
<li>Feistel Network，由 Horst Feistel 发明，DES 设计者之一。<ul>
<li>DES</li>
</ul>
</li>
<li>Substitution-Permutation Network(SPN)<ul>
<li>AES</li>
</ul>
</li>
<li>其他方案</li>
</ul>
<p>注：费思妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。因此，实现这种密码所需的代码或电路大小能几乎减半。费斯妥网络是一种迭代密码，其中的内部函数称为轮函数。</p>
<p>注：代换-置换网络是一系列被应用于分组密码中相关的数学运算，代换（Substitution）和置换（Permutation）分别被称作S盒（替換盒，英语：S-boxes）和P盒（排列盒，英语：P-boxes）。这种加密网络使用明文和密钥作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文。</p>
<h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><p>目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。</p>
<h3 id="常见块加密算法"><a href="#常见块加密算法" class="headerlink" title="常见块加密算法"></a>常见块加密算法</h3><p>//TODO(ARX/DES/IDEA/AES/Simon and Speck)</p>
<h3 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h3><p>分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。</p>
<h4 id="填充规则"><a href="#填充规则" class="headerlink" title="填充规则"></a>填充规则</h4><p>正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。</p>
<p>常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。</p>
<p>一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。</p>
<p>Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>
<p>Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure></p>
<p>这里其实就是和 md5 和 sha1 的 padding 差不多。</p>
<p>Pad with zeroes except make the last byte equal to the number of padding bytes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure></p>
<p>Pad with zero (null) characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure></p>
<p>Pad with spaces<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure></p>
<h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB 模式全称为电子密码本模式（Electronic codebook）。</p>
<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_encryption.png" alt="image"></p>
<h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_decryption.png" alt="image"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>实现简单。</li>
<li>不同明文分组的加密可以并行计算，速度很快。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示<br><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_bad_linux.png" alt="image"></li>
</ul>
<p>为了解决统一明文产生相同密文的问题，提出了其它的加密模式。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>用于随机数的加密保护。</li>
<li>用于单分组明文的加密。</li>
</ul>
<h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC 全称为密码分组链接（Cipher-block chaining） 模式，这里</p>
<ul>
<li>IV 不要求保密</li>
<li>IV 必须是不可预测的，而且要保证完整性。</li>
</ul>
<h5 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_encryption.png" alt="image"></p>
<h5 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_decryption.png" alt="image"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。</li>
<li>具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。</li>
<li>具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>加密不能并行，解密可以并行。</li>
</ul>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul>
<li>常见的数据加密和 TLS 加密。</li>
<li>完整性认证和身份认证。</li>
</ul>
<h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><ul>
<li>字节反转攻击<ul>
<li>IV 向量，影响第一个明文分组</li>
<li>第 n 个密文分组，影响第 n + 1 个明文分组</li>
</ul>
</li>
<li>Padding Oracle Attack，具体参见下面介绍</li>
</ul>
<h4 id="PCBC模式"><a href="#PCBC模式" class="headerlink" title="PCBC模式"></a>PCBC模式</h4><p>PCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。</p>
<h5 id="加密-2"><a href="#加密-2" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_encryption.png" alt="image"></p>
<h5 id="解密-2"><a href="#解密-2" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_decryption.png" alt="image"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>解密过程难以并行化</li>
<li>互换邻接的密文块不会对后面的密文块造成影响</li>
</ul>
<h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>CFB 全称为密文反馈模式（Cipher feedback）。</p>
<h5 id="加密-3"><a href="#加密-3" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_encryption.png" alt="image"></p>
<h5 id="解密-3"><a href="#解密-3" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_decryption.png" alt="image"></p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>适应于不同数据格式的要求</li>
<li>有限错误传播</li>
<li>自同步<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>加密不能并行化，解密不能并行</li>
</ul>
<h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。</p>
<h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>OFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。</p>
<h5 id="加密-4"><a href="#加密-4" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_encryption.png" alt="image"></p>
<h5 id="解密-4"><a href="#解密-4" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_decryption.png" alt="image"></p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul>
<li>不具有错误传播特性。<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>IV 无需保密，但是对每个消息必须选择不同的 IV。</li>
<li>不具有自同步能力。</li>
</ul>
<h5 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h5><p>适用于一些明文冗余度比较大的场景，如图像加密和语音加密。</p>
<h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>CTR 全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。</p>
<h5 id="加密-5"><a href="#加密-5" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p>
<h5 id="解密-5"><a href="#解密-5" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p>
<h4 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h4><p>Padding Oracle Attack 攻击一般需要满足以下几个条件</p>
<ul>
<li>加密算法<ul>
<li>采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。</li>
<li>分组模式为 CBC 模式。</li>
</ul>
</li>
<li>攻击者能力<ul>
<li>攻击者可以拦截上述加密算法加密的消息。</li>
<li>攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。</li>
</ul>
</li>
</ul>
<p>Padding Oracle Attack 攻击可以达到的效果如下</p>
<ul>
<li>在不清楚 key 和 IV 的前提下解密任意给定的密文。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Heinz">
            
              <p class="site-author-name" itemprop="name">Heinz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/itmayi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:799902881@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heinz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jypPJXy89LBDsg88boqicDg9-gzGzoHsz", "7z1xPLru7WIRw9p0A6SE779N");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
