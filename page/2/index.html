<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="榆木的博客">
<meta name="keywords" content="随笔">
<meta property="og:type" content="website">
<meta property="og:title" content="Heinz Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Heinz Blog">
<meta property="og:description" content="榆木的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heinz Blog">
<meta name="twitter:description" content="榆木的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Heinz Blog - 千里之行，始于足下！</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heinz Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">千里之行，始于足下！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/wireshark数据包分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/wireshark数据包分析/" itemprop="url">wireshark数据包分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T10:19:43+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/wireshark数据包分析/" class="leancloud_visitors" data-flag-title="wireshark数据包分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP：（TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP 是面向连接的所以只能用于点对点的通讯）源IP地址：发送包的IP地址；目的IP地址：接收包的IP地址；源端口：源系统上的连接的端口；目的端口：目的系统上的连接的端口。  TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN，ACK。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。第一次握手：建立连接时，客户端发送SYN包(SEQ=x)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN(ACK=x+1),同时自己也送一个SYN包(SEQ=y),即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=y+1),此包发送完毕，客户端和服务器进入Established状态，完成三次握手</p>
<h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114092218164" alt="image"><br>A. 第一行，帧Frame 36838 指的是要发送的数据块，其中，所抓帧的序号为36838，捕获字节数等于传送字节数：70字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为88:5d:90:00:00:25；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.21.175；目标IP地址为192.168.21.156；</p>
<p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(10086)；目标端口(50132)；序列号(1361)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为16；</p>
<p>E. 第五行，数据共有16字节</p>
<h4 id="Frame信息分析"><a href="#Frame信息分析" class="headerlink" title="Frame信息分析"></a>Frame信息分析</h4><p><img src="https://img-blog.csdn.net/20170114104835215" alt="image"><br>A. Arrival Time：到达时间，值为Jan 14, 2017 08:52:56.239204000</p>
<p>B. EPoch Time：信息出现时间，值为1484355176.239204000秒</p>
<p>C. [ Time delta from previous captured frame: 0.001472000 seconds] ：与之前捕获的数据帧时间差：0.001472000秒；</p>
<pre><code>[Time delta from previous displayed frame: 0.001472000 seconds]：与之前显示的帧时间差： 0.001472000秒；

[Time since reference or first frame: 1278.276505000 seconds]：距参考帧或第一帧的时间差：1278.276505000秒；
</code></pre><p>D. Frame Number: 36838，帧编号为36838；</p>
<p>E. Frame Length: 70 bytes (560 bits)，帧长度为70字节；</p>
<pre><code>Capture Length: 70 bytes (560 bits)，捕获到的长度为70字节；
</code></pre><p>F. [Frame is marked: False]，帧标记：无；</p>
<pre><code>[Frame is ignored: False]，帧被忽略：无；
</code></pre><p>G. [Protocols in frame: eth:ip:tcp:data]，协议帧：eth(以太网)、IP、tcp、data</p>
<p>H. [Coloring Rule Name: TCP]，色彩规则名称：TCP；</p>
<pre><code>[Coloring Rule String: tcp]，色彩规则字符串：TCP；
</code></pre><h4 id="Ethernet-II信息分析"><a href="#Ethernet-II信息分析" class="headerlink" title="Ethernet II信息分析"></a>Ethernet II信息分析</h4><p><img src="https://img-blog.csdn.net/20170114111317125" alt="iamge"><br>A. Destination: AsrockIn_b5:b9:92 (00:25:22:b5:b9:92)，目标Mac地址为00:25:22:b5:b9:92</p>
<p>B. Source: 88:5d:90:00:00:25 (88:5d:90:00:00:25)，源Mac地址为88:5d:90:00:00:25</p>
<p>C. Type: IP (0x0800)，类型是IP数据包</p>
<h4 id="Ipv4协议信息分析"><a href="#Ipv4协议信息分析" class="headerlink" title="Ipv4协议信息分析"></a>Ipv4协议信息分析</h4><p><img src="https://img-blog.csdn.net/20170114112410438" alt="image"></p>
<p>A. Version: 4，IP协议版本为IPv4；</p>
<pre><code>Header length: 20 bytes，头部数据长度为20字节；
</code></pre><p>B. Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))，区分的服务领域：0x00 (默认的是DSCP：0x00)；</p>
<p>C. Flags: 0x02 (Don’t Fragment)，不支持分组；</p>
<pre><code>Fragment offset: 0，分组偏移量为0； 
</code></pre><p>D. Time to live: 64，TTL，生存时间为64，TTL通常表示包在被丢弃前最多能经过的路由器个数，当数据包传输到一个路由器之后，TTL就自动减1，如果减到0了还没有传送到目标主机，那么就自动丢失。</p>
<p>E. Header checksum: 0xcebd [correct]，头部校验和</p>
<p>F. Source: 192.168.21.175 (192.168.21.175)，源IP地址为192.168.21.175；</p>
<pre><code>Destination: 192.168.21.156 (192.168.21.156)，目标IP地址为192.168.21.156
</code></pre><h4 id="Trasmission-Control-Protocol信息分析"><a href="#Trasmission-Control-Protocol信息分析" class="headerlink" title="Trasmission Control Protocol信息分析"></a>Trasmission Control Protocol信息分析</h4><p>其中，对应的TCP首部的数据信息<br><img src="https://img-blog.csdn.net/20170114093029919" alt="image"></p>
<p>A. 端口号，数据传输的16位源端口号和16位目标端口号(用于寻找发端和收端应用进程)；</p>
<p>B. 相对序列号，该数据包的相对序列号为1361(此序列号用来确定传送数据的正确位置，且序列号用来侦测丢失的包)；下一个数据包的序列号是1377；</p>
<p>C. Acknowledgment number是32位确认序列号，值等于1表示数据包收到，确认有效；</p>
<p>D. 手动的数据包的头字节长度是20字节；</p>
<p>E. Flags，含6种标志；ACK：确认序号有效；SYN：同步序号用来发起一个连接；FIN：发端完成发送任务；RST：重新连接；PSH：接收方应该尽快将这个报文段交给应用层；URG：紧急指针(urgentpointer)有效；</p>
<p>F. window，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65536字节，上面显示窗口大小为1825字节；</p>
<p>G. Checksum，16位校验和，检验和覆盖了整个的TCP报文段，由发端计算和存储，并由收端进行验证</p>
<h4 id="Data信息分析"><a href="#Data信息分析" class="headerlink" title="Data信息分析"></a>Data信息分析</h4><p><img src="https://img-blog.csdn.net/20170114114030332" alt="image"></p>
<p>A.  TCP 报文段中的数据(该部分是可选的)，长度为16字节；</p>
<h2 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h2><p>链路层的信息上是以帧的形式进行传输的，帧封装了应用层、传输层、网络层的数据。而Wireshark抓到的就是链路层的一帧；</p>
<h3 id="封装包详细信息"><a href="#封装包详细信息" class="headerlink" title="封装包详细信息"></a>封装包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114120559104" alt="image"></p>
<p>A. 第一行，帧Frame 12411 指的是要发送的数据块，其中，所抓帧的序号为12411，捕获字节数等于传送字节数：233字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为220.181.57.234；目标IP地址为192.168.21.156；</p>
<p>D. 第四行，TCP协议，也称传输控制协议，是传输层；源端口(80)；目标端口(53985)；序列号(1)；ACK是TCP数据包首部中的确认标志，对已接收到的TCP报文进行确认，值为1表示确认号有效；长度为179；</p>
<p>E. 第五行，Http协议，也称超文本传输协议，是应用层</p>
<h4 id="Http请求报文分析"><a href="#Http请求报文分析" class="headerlink" title="Http请求报文分析"></a>Http请求报文分析</h4><p><img src="https://img-blog.csdn.net/20170114135028036" alt="image"></p>
<p>报文分析：<br><img src="https://img-blog.csdn.net/20170114135154140" alt="image"></p>
<p>在抓包分析过程中还发现了另外一些http请求报文中所特有的首部字段名，比如下面http请求报文中橙黄色首部字段名：</p>
<p><img src="https://img-blog.csdn.net/20170114135419581" alt="image"></p>
<h4 id="Http响应报文信息"><a href="#Http响应报文信息" class="headerlink" title="Http响应报文信息"></a>Http响应报文信息</h4><p><img src="https://img-blog.csdn.net/20170114134516128" alt="image"></p>
<p>报文分析：  </p>
<p><img src="https://img-blog.csdn.net/20170114134622379" alt="image"></p>
<h2 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h2><h3 id="封包详细信息-1"><a href="#封包详细信息-1" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><p><img src="https://img-blog.csdn.net/20170114140200794" alt="image"></p>
<p>A. 第一行，帧Frame 12237 指的是要发送的数据块，其中，所抓帧的序号为12237，捕获字节数等于传送字节数：133字节；</p>
<p>B. 第二行，以太网，有线局域网技术，是数据链路层。源Mac地址为24:69:68:6b:78:96；目标Mac地址为00:25:22:b5:b9:92；</p>
<p>C. 第三行，IPV4协议，也称网际协议，是网络层；源IP地址为192.168.211.254；目标IP地址为192.168.211.84；</p>
<p>D. 第四行，UDP协议，是传输层；源端口domain(53)；目标端口(65219)；</p>
<p>E. 第五行，DNS协议，是应用层。</p>
<h4 id="DNS查询报文"><a href="#DNS查询报文" class="headerlink" title="DNS查询报文"></a>DNS查询报文</h4><p><img src="https://img-blog.csdn.net/20170114141159062" alt="iamge"></p>
<p>报文分析：<br><img src="https://img-blog.csdn.net/20170114141447421" alt="image"></p>
<h4 id="DNS响应报文"><a href="#DNS响应报文" class="headerlink" title="DNS响应报文"></a>DNS响应报文</h4><p><img src="https://img-blog.csdn.net/20170114141637002" alt="iamge"></p>
<p>报文分析：  </p>
<p><img src="https://img-blog.csdn.net/20170114142315693" alt="image"></p>
<h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p><img src="https://img-blog.csdn.net/20170118162817190" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/数据包分析基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/数据包分析基础/" itemprop="url">数据包分析基础</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T09:21:38+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/数据包分析基础/" class="leancloud_visitors" data-flag-title="数据包分析基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p>
<p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li>
</ul>
<p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p>
<h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p>
<p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p>
<p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p>
<h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p>
<p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p>
<p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p>
<p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>
<p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p>
<p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p>
<h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p>
<p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p>
<p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p>
<p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p>
<p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p>
<p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p>
<h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table>
<thead>
<tr>
<th>name</th>
<th>complete connection</th>
<th>stateful</th>
<th>selected replay</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p>
<h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p>
<ul>
<li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p>
</li>
<li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p>
</li>
<li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p>
</li>
<li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p>
</li>
<li><p>Tcpbirdge:桥接两个不同网段</p>
</li>
<li><p>Tcpcapinfo:pcap 文件解码器和编译器</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/http-http2协议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/http-http2协议/" itemprop="url">http2协议、数据包回放</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T09:21:38+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据包分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据包分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/07/http-http2协议/" class="leancloud_visitors" data-flag-title="http2协议、数据包回放">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="http2协议"><a href="#http2协议" class="headerlink" title="http2协议"></a>http2协议</h2><p>http2协议是一个二进制协议。采用二进制格式协议传输数据，而不是http/1.x的文本格式。</p>
<p>http/2源于SPDY，但仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li>
</ul>
<p>注：spdy是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。互联网工程任务组（IETF）对谷歌提出的SPDY协议进行了标准化，于2015年5推出了类似于SPDY协议的 HTTP 2.0 协议标准（简称HTTP/2）。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。此外，著名的开源HTTP服务器软件 Nginx 也于2015年9月移除了对SPDY的支持，转而支持HTTP/2。</p>
<h2 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h2><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<br>HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。<br>帧（Frame）：HTTP/2 数据通信的最小单位。<br>消息（Message）：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成<br>流（Stream）：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p>
<p>HTTP/2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p>
<p>Frame 是 HTTP/2 二进制格式的基础，Frame 的基本格式如下</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB838ae8fda562512d2d95b9d69dd73b1a?method=download&amp;shareKey=19abcf09a1c0f9e2d3f35b8ab0fc884f" alt="image"></p>
<h2 id="http2的影响"><a href="#http2的影响" class="headerlink" title="http2的影响"></a>http2的影响</h2><p>现在http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概估计。</p>
<p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking的困扰。</p>
<p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p>
<p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p>
<p>所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的web体验。</p>
<p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没法看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。</p>
<h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器(Hub)工作在最底层(物理层)，没有相匹配的软件系统，是纯硬件设备,集线器主要用来连接计算机等网络终端。</p>
<p>集线器为<strong>共享式带宽</strong>，连接在集线器上的任何一个设备发送数据时，其他所有设备必须等待，此设备享有全部带宽，通讯完毕，再由其他设备使用带宽。正因此，集线器连接了一个冲突域的网络。所有设备相互交替使用，就好象大家一起过一根独木桥一样。</p>
<p>集线器<strong>不能判断数据包的目的地和类型</strong>，所以如果是广播数据包也依然转发，而且所有设备发出数据以广播方式发送到每个接口，这样集线器也连接了一个广播域的网络。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在数据链接层(第二层)，和集线器一样主要用于连接计算机等网络终端设备。允许连接在交换机上的设备并行通讯，好比高速公路上的汽车并行行使一般，设备间通讯不会再发生冲突，因此交换机打破了冲突域，交换机每个接口是一个冲突域，不会与其他接口发生通讯冲突。</p>
<p>有系统的交换机可以记录MAC地址表，发送的数据不会再以广播方式发送到每个接口，而是直接到达目的接口，节省了接口带宽。但是交换机和集线器一样不能判断广播数据包，会把广播发送到全部接口，所以交换机和集线器一样连接了一个广播域网络。</p>
<p>高端一点的交换机不仅可以记录MAC地址表，还可以划分VLAN（虚拟局域网）来隔离广播，但是VLAN间也同样不能通讯。要使VLAN间能够通讯，必须有三层设备介入。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在网络层(第三层)，主要用来进行网络与网络的连接，所有路由器都有自己的操作系统。路由器把数据从一个网络发送到另一个网络，这个过程就叫路由。路由器不仅能像交换机一样隔离冲突域，而且还能检测广播数据包，并丢弃广播包来隔离广播域，有效的扩大了网络的规模。</p>
<p>在路由器中记录着路由表，路由器以此来转发数据，以实现网络间的通讯。路由器的介入可以使交换机划分的VLAN实现互相通讯。</p>
<h2 id="数据包回放"><a href="#数据包回放" class="headerlink" title="数据包回放"></a>数据包回放</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><table>
<thead>
<tr>
<th>name</th>
<th>complete connection</th>
<th>stateful</th>
<th>selected replay</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>TCPReplay|No Required|No|No<br>Tomahawk|Required|Yes|No<br>Mokey|No Required|Yes|No<br>Avalanche|Required|Yes|No<br>SocketReplay|No Required|Yes|Yes</p>
<h3 id="TcpReplay"><a href="#TcpReplay" class="headerlink" title="TcpReplay"></a>TcpReplay</h3><p>Tcpreplay是一个工具套件，用来测试各种网络设备，包括：交换机、路由器、防火墙、NIDS和IPS等。它使用嗅探工具抓取的数据包，允许你拆分客户端和服务端流量，重写2、3、4层头信息，最终将流量回放到网络中。3.4 版本包括以下部分：</p>
<ul>
<li><p>Tcpprep:将流量拆分为客户端和服务端两个方向，并存放为缓存文件</p>
</li>
<li><p>Tcprewrite:重写pcap文件的TCP/IP层和数据链路层的头信息</p>
</li>
<li><p>Tcpreplay:以可控的速度将pcap文件回放到网络中</p>
</li>
<li><p>Tcpreplay-edit:在tcpreplay基础上增加编辑功能</p>
</li>
<li><p>Tcpbirdge:桥接两个不同网段</p>
</li>
<li><p>Tcpcapinfo:pcap 文件解码器和编译器</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jiayy/p/3447027.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayy/p/3447027.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础六/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础六/" itemprop="url">现代密码学基础六</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:54:24+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础六/" class="leancloud_visitors" data-flag-title="现代密码学基础六">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="攻击模式"><a href="#攻击模式" class="headerlink" title="攻击模式"></a>攻击模式</h2><p>在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。</p>
<p>这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类</p>
<ul>
<li>唯密文攻击：攻击者仅能获得一些加密过的密文。</li>
<li>已知明文攻击：攻击者有一些密文对应的明文。</li>
<li>选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。</li>
<li>选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。</li>
<li>相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后+ 的密文或明文。但是攻击者不知道这些密钥。</li>
</ul>
<h2 id="常见攻击方法"><a href="#常见攻击方法" class="headerlink" title="常见攻击方法"></a>常见攻击方法</h2><p>根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有</p>
<ul>
<li>暴力攻击</li>
<li>中间相遇攻击</li>
<li>线性分析</li>
<li>差分分析</li>
<li>不可能差分分析</li>
<li>积分分析</li>
<li>代数分析</li>
<li>相关密钥攻击</li>
<li>侧信道攻击</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础五/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础五/" itemprop="url">现代密码学基础五</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:47:48+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础五/" class="leancloud_visitors" data-flag-title="现代密码学基础五">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>在计算机世界中，我们可能会需要电子签名，因为我们大多数情况下会使用电子文件，那这时候怎么办呢？当然，我们仍然可以选择使用自己的名字。但其实还有另外一种方式，那就是采用数字签名，这种签名更加难以伪造，可信程度更高。数字签名的主要用处是确保消息确实来自于声称产生该消息的人。</p>
<p>数字签名依赖于非对称密码，因为我们必须确保一方能够做的事情，而另一方不能够做出这样的事情。其基本原理如下</p>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/signature/figure/Digital_Signature_diagram.png" alt="image"></p>
<h3 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h3><p>原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名。</p>
<h3 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h3><p>//TODO</p>
<h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><h3 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h3><p>使用该扩展名的证书采用<strong>二进制编码</strong>，当然，这些证书也可以使用 CER 或者 CRT 作为扩展名。</p>
<h3 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h3><p>使用该扩展名的证书采用 Base64 编码，文件的开始是一行 —–BEGIN。</p>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -outform der -in certificate.pem -out certificate.der</span><br><span class="line">openssl x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/现代密码学基础四/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/现代密码学基础四/" itemprop="url">现代密码学基础四</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:39:30+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/06/现代密码学基础四/" class="leancloud_visitors" data-flag-title="现代密码学基础四">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。其一般模型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意长度(m)消息 -&gt; hash散列函数 -&gt; 固定长度h(m)</span><br></pre></td></tr></table></figure></p>
<p>显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。</p>
<p>散列值的目的如下</p>
<ul>
<li>确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。</li>
<li>冗余校验</li>
<li>单向口令文件，比如 linux 系统的密码</li>
<li>入侵检测和病毒检测中的特征码检测</li>
</ul>
<p>目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。</p>
<table>
<thead>
<tr>
<th>算法类型</th>
<th>输出 Hash 值长度</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>MD5    |128 bit / 256 bit<br>SHA1 |    160 bit<br>SHA256    | 256 bit<br>SHA512 |    512 bit</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/现代密码学基础三/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/现代密码学基础三/" itemprop="url">现代密码学基础三</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T13:20:51+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/05/现代密码学基础三/" class="leancloud_visitors" data-flag-title="现代密码学基础三">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。</p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p>
<p>RSA 算法的可靠性由<strong>极大整数因数分解</strong>的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="公钥与私钥的产生"><a href="#公钥与私钥的产生" class="headerlink" title="公钥与私钥的产生"></a>公钥与私钥的产生</h5><ul>
<li>随机选择两个不同大质数p和q，计算N=pxq</li>
<li>根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)</li>
<li>选择一个小于r的整数e，使e和r互质。并求得e关于r的模反元素，命名为d，有ed≡1(mod r)。</li>
<li>将p和q的记录销毁。</li>
</ul>
<p>此时，(N,e)是公钥，(N,d)是私钥。</p>
<p>注：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。</p>
<h5 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h5><p>首先需要将消息 m以一个双方约定好的格式转化为一个小于 N，且与N<br>互质的整数 n。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：<br>$n^e$ ≡ c (mod N)</p>
<h5 id="消息解密"><a href="#消息解密" class="headerlink" title="消息解密"></a>消息解密</h5><p>利用密钥 d进行解密。<br>$c^d$ ≡ n (mod N)</p>
<h4 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h4><ul>
<li><p>RSAtool</p>
<ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ius/rsatool.git</span><br><span class="line">cd rsatool</span><br><span class="line">python rsatool.py -h</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>RSA Converter</p>
<ul>
<li>根据给定的密钥对，生成pem文件</li>
<li>g根据n,e,d，生成p,q</li>
</ul>
</li>
<li><p>openssl</p>
<ul>
<li><p>查看公钥文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -in pubkey.pem -text -modulus</span><br></pre></td></tr></table></figure>
</li>
<li><p>解密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsautl -decrypt -inkey private.pem -in flag.enc -out flag</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分解整数工具</p>
<ul>
<li>网站分解<a href="http://factordb.com/" target="_blank" rel="noopener">http://factordb.com/</a> </li>
<li>命令行分解<a href="https://github.com/ryosan-470/factordb-pycli借用" target="_blank" rel="noopener">https://github.com/ryosan-470/factordb-pycli借用</a> factordb 数据库。</li>
<li><a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">https://sourceforge.net/projects/yafu/</a></li>
</ul>
</li>
<li><p>python库</p>
<ul>
<li>primefac<br>整数分解库，包含了很多整数分解的算法。</li>
<li>gmpy</li>
<li>gmpy2<br>安装时，可能会需要自己另行安装 mfpr 与 mpc 库。</li>
<li>pycrypto</li>
</ul>
</li>
</ul>
<h4 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h4><p>能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。</p>
<p>能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。</p>
<p>能量分析攻击分为： </p>
<ul>
<li>简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 </li>
<li>差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。</li>
</ul>
<h5 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h5><p>攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。</p>
<h3 id="背包加密"><a href="#背包加密" class="headerlink" title="背包加密"></a>背包加密</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $1_1$,$a_2$,…,$a_n$<br> 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题：<br> $x_1$$a_1$+$x_2$$a_2$+…+$x_n$$a_n$ = W</p>
<p> 其中$x_i$只能为0和1，显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。</p>
<p> 在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$,即可得到加密结果。</p>
<p> 但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。</p>
<p>但是当$a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件：第 i 个数大于前面所有数的和。</p>
<p>为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。</p>
<h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p>ECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有</p>
<ul>
<li>以素数为模的整数域 GF(p)，通常在通用处理器上更为有效。</li>
<li>特征为 2 的伽罗华域 GF（2^m），可以设计专门的硬件。</li>
</ul>
<h3 id="格密码"><a href="#格密码" class="headerlink" title="格密码"></a>格密码</h3><p>格在数学上至少有两种含义</p>
<ul>
<li>定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见 <a href="https://en.wikipedia.org/wiki/Lattice_(order)。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lattice_(order)。</a></li>
<li>群论中的定义，是 [Math Processing Error] 中的满足某种性质的子集。当然，也可以是其它群。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/现代密码学基础二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/现代密码学基础二/" itemprop="url">现代密码学基础二</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T11:50:21+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/04/现代密码学基础二/" class="leancloud_visitors" data-flag-title="现代密码学基础二">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所谓块加密就是每次加密一块明文，常见的加密算法有</p>
<ul>
<li>IDEA 加密</li>
<li>DES 加密</li>
<li>AES 加密</li>
</ul>
<p>块加密也是对称加密。</p>
<p>其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有<strong>复杂</strong>的加解密算法来加解密明密文。</p>
<p>而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助</p>
<ul>
<li>padding，即 padding 到指定分组长度</li>
<li>分组加密模式，即明文分组加密的方式。</li>
</ul>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。</p>
<h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下</p>
<ul>
<li>S 盒</li>
<li>乘法</li>
</ul>
<h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有</p>
<ul>
<li>线性变换</li>
<li>置换</li>
<li>移位，循环移位</li>
</ul>
<h3 id="常见加解密结构"><a href="#常见加解密结构" class="headerlink" title="常见加解密结构"></a>常见加解密结构</h3><p>目前块加密中主要使用的是结构是</p>
<ul>
<li>迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。</li>
</ul>
<h4 id="迭代结构"><a href="#迭代结构" class="headerlink" title="迭代结构"></a>迭代结构</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>迭代结构基本如下，一般包括三个部分</p>
<ul>
<li>密钥置换</li>
<li>轮加密函数</li>
<li>轮解密函数</li>
</ul>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/figure/iterated_cipher.png" alt="image"></p>
<h5 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h5><p>目前来说，轮函数主要有主要有以下设计方法</p>
<ul>
<li>Feistel Network，由 Horst Feistel 发明，DES 设计者之一。<ul>
<li>DES</li>
</ul>
</li>
<li>Substitution-Permutation Network(SPN)<ul>
<li>AES</li>
</ul>
</li>
<li>其他方案</li>
</ul>
<p>注：费思妥密码（英语：Feistel cipher）是用于构造分组密码的对称结构，以德国出生的物理学家和密码学家霍斯特·费斯妥（Horst Feistel）命名，他在美国IBM工作期间完成了此项开拓性研究。通常也称为费斯妥网络（Feistel network）。大部分分组密码使用该方案，包括数据加密标准（DES）。费斯妥结构的优点在于加密和解密操作非常相似，在某些情况下甚至是相同的，只需要逆转密钥编排。因此，实现这种密码所需的代码或电路大小能几乎减半。费斯妥网络是一种迭代密码，其中的内部函数称为轮函数。</p>
<p>注：代换-置换网络是一系列被应用于分组密码中相关的数学运算，代换（Substitution）和置换（Permutation）分别被称作S盒（替換盒，英语：S-boxes）和P盒（排列盒，英语：P-boxes）。这种加密网络使用明文和密钥作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文。</p>
<h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><p>目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。</p>
<h3 id="常见块加密算法"><a href="#常见块加密算法" class="headerlink" title="常见块加密算法"></a>常见块加密算法</h3><p>//TODO(ARX/DES/IDEA/AES/Simon and Speck)</p>
<h3 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h3><p>分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。</p>
<h4 id="填充规则"><a href="#填充规则" class="headerlink" title="填充规则"></a>填充规则</h4><p>正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。</p>
<p>常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。</p>
<p>一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。</p>
<p>Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>
<p>Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure></p>
<p>这里其实就是和 md5 和 sha1 的 padding 差不多。</p>
<p>Pad with zeroes except make the last byte equal to the number of padding bytes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure></p>
<p>Pad with zero (null) characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure></p>
<p>Pad with spaces<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES INPUT BLOCK  = f  o  r  _  _  _  _  _</span><br><span class="line">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class="line">KEY              = 01 23 45 67 89 AB CD EF</span><br><span class="line">DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure></p>
<h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB 模式全称为电子密码本模式（Electronic codebook）。</p>
<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_encryption.png" alt="image"></p>
<h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_decryption.png" alt="image"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>实现简单。</li>
<li>不同明文分组的加密可以并行计算，速度很快。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示<br><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ecb_bad_linux.png" alt="image"></li>
</ul>
<p>为了解决统一明文产生相同密文的问题，提出了其它的加密模式。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>用于随机数的加密保护。</li>
<li>用于单分组明文的加密。</li>
</ul>
<h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC 全称为密码分组链接（Cipher-block chaining） 模式，这里</p>
<ul>
<li>IV 不要求保密</li>
<li>IV 必须是不可预测的，而且要保证完整性。</li>
</ul>
<h5 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_encryption.png" alt="image"></p>
<h5 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cbc_decryption.png" alt="image"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。</li>
<li>具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。</li>
<li>具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>加密不能并行，解密可以并行。</li>
</ul>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul>
<li>常见的数据加密和 TLS 加密。</li>
<li>完整性认证和身份认证。</li>
</ul>
<h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><ul>
<li>字节反转攻击<ul>
<li>IV 向量，影响第一个明文分组</li>
<li>第 n 个密文分组，影响第 n + 1 个明文分组</li>
</ul>
</li>
<li>Padding Oracle Attack，具体参见下面介绍</li>
</ul>
<h4 id="PCBC模式"><a href="#PCBC模式" class="headerlink" title="PCBC模式"></a>PCBC模式</h4><p>PCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。</p>
<h5 id="加密-2"><a href="#加密-2" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_encryption.png" alt="image"></p>
<h5 id="解密-2"><a href="#解密-2" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/pcbc_decryption.png" alt="image"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>解密过程难以并行化</li>
<li>互换邻接的密文块不会对后面的密文块造成影响</li>
</ul>
<h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>CFB 全称为密文反馈模式（Cipher feedback）。</p>
<h5 id="加密-3"><a href="#加密-3" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_encryption.png" alt="image"></p>
<h5 id="解密-3"><a href="#解密-3" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/cfb_decryption.png" alt="image"></p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>适应于不同数据格式的要求</li>
<li>有限错误传播</li>
<li>自同步<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>加密不能并行化，解密不能并行</li>
</ul>
<h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。</p>
<h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>OFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。</p>
<h5 id="加密-4"><a href="#加密-4" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_encryption.png" alt="image"></p>
<h5 id="解密-4"><a href="#解密-4" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ofb_decryption.png" alt="image"></p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul>
<li>不具有错误传播特性。<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>IV 无需保密，但是对每个消息必须选择不同的 IV。</li>
<li>不具有自同步能力。</li>
</ul>
<h5 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h5><p>适用于一些明文冗余度比较大的场景，如图像加密和语音加密。</p>
<h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>CTR 全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。</p>
<h5 id="加密-5"><a href="#加密-5" class="headerlink" title="加密"></a>加密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p>
<h5 id="解密-5"><a href="#解密-5" class="headerlink" title="解密"></a>解密</h5><p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/figure/ctr_encryption.png" alt="image"></p>
<h4 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h4><p>Padding Oracle Attack 攻击一般需要满足以下几个条件</p>
<ul>
<li>加密算法<ul>
<li>采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。</li>
<li>分组模式为 CBC 模式。</li>
</ul>
</li>
<li>攻击者能力<ul>
<li>攻击者可以拦截上述加密算法加密的消息。</li>
<li>攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。</li>
</ul>
</li>
</ul>
<p>Padding Oracle Attack 攻击可以达到的效果如下</p>
<ul>
<li>在不清楚 key 和 IV 的前提下解密任意给定的密文。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/现代密码学基础一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/现代密码学基础一/" itemprop="url">现代密码学基础一</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:30:20+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/现代密码学/" itemprop="url" rel="index">
                    <span itemprop="name">现代密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/04/现代密码学基础一/" class="leancloud_visitors" data-flag-title="现代密码学基础一">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码一般逐字节或者逐比特处理信息。一般来说：</p>
<ul>
<li>流密码的密钥长度会与明文的长度相同。</li>
<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>
</ul>
<p>需要注意的是，流加密目前来说都是对称加密。</p>
<p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p>
<p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>
<p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。</p>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3><p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>
<p>就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。</p>
<h4 id="随机性的严格性"><a href="#随机性的严格性" class="headerlink" title="随机性的严格性"></a>随机性的严格性</h4><ul>
<li>随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。</li>
<li>不可预测性：不能从过去的序列推测出下一个出现的数。</li>
<li>不可重现性：除非数列保存下来，否则不能重现相同的数列。</li>
</ul>
<p>这三个性质的严格性依次递增。</p>
<p>一般来说，随机数可以分为三类</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>随机性</th>
<th>不可预测性</th>
<th>不可重现性</th>
</tr>
</thead>
<tbody>
<tr>
<td>弱伪随机数</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>强伪随机数</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>真随机数</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>一般来说，密码学中使用的随机数是第二种。</p>
<h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>正如我们之前所说，一旦 PRNG 所依赖的种子确定了，那么 PRNG 生成的随机数序列基本也就确定了。这里定义 PRNG 的周期如下：对于一个 PRNG 的所有可能起始状态，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的(一般性限制条件)。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>目前通用的伪随机数生成器主要有：</p>
<ul>
<li>线性同余生成器，LCG</li>
<li>线性回归发生器</li>
<li>线性反馈移位寄存器（Linear feedback shift register，LFSR）</li>
<li>Mersenne Twister</li>
<li>xorshift generators</li>
<li>WELL family of generators</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>通常来说，伪随机数生成器可能会有以下问题：  </p>
<ul>
<li>在某些种子的情况下，其生成的随机数序列的周期会比较小。</li>
<li>生成大数时，分配的不均匀。</li>
<li>连续值之间关联密切，知道后续值，可以知道之前的值。</li>
<li>输出序列的值的大小很不均匀。</li>
</ul>
<h3 id="密码安全伪随机数数生成器"><a href="#密码安全伪随机数数生成器" class="headerlink" title="密码安全伪随机数数生成器"></a>密码安全伪随机数数生成器</h3><p>密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator，CSPRNG），也称为密码学伪随机数生成器（cryptographic pseudo-random number generator，CPRNG)，是一种特殊的伪随机数生成器。它需要满足满足一些必要的特性，以便于适合于密码学应用。</p>
<p>密码学的很多方面都需要随机数：</p>
<ul>
<li>密钥生成</li>
<li>生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式</li>
<li>nonce，用于防止重放攻击以及分组密码的 CTR 模式等、</li>
<li>one-time pads</li>
<li>某些签名方案中的盐，如 ECDSA， RSASSA-PSS</li>
</ul>
<p>注：在资讯安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>毫无疑问，密码学安全伪随机数生成器的要求肯定比一般的伪随机数生成器要高。一般而言，CSPRNG 的要求可以分为两类</p>
<ul>
<li>通过统计随机性测试。CSPRNG 必须通过 next-bit test，也就是说，知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于 50% 的概率预测出来下一个比特位。这里特别提及一点，姚期智曾在 1982 年证明，如果一个生成器可以通过 next-bit test，那么它也可以通过所有其他的多项式时间统计测试。</li>
<li>必须能够抵抗足够强的攻击，比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>就目前而看， CSPRNG 的设计可以分为以下三类</p>
<ul>
<li>基于密码学算法，如密文或者哈希值。</li>
<li>基于数学难题</li>
<li>某些特殊目的的设计</li>
</ul>
<h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><p>一般的，一个 n 级反馈移位寄存器如下图所示</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc234f54efe1a0af70602bf1974c14605?method=download&amp;shareKey=415fcf56b93e427f2b1df0417a1add43" alt="image"></p>
<ul>
<li>$a_0$,$a_1$,…,$a_{n-1}$为初态。</li>
<li>F为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。</li>
<li>$a_{i+n}$=F($a_i$,$a_{i+1}$,…,$a_{i+n-1}$)</li>
</ul>
<p>一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即</p>
<p>($a_i$,$a_{i+1}$,…,$a_{i+n-1}$) -&gt; ($a_{i+1}$,..,$a_{i+n-1}$,$a_{i+n}$),对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。</p>
<h4 id="非线性反馈寄存器"><a href="#非线性反馈寄存器" class="headerlink" title="非线性反馈寄存器"></a>非线性反馈寄存器</h4><p>//TODO</p>
<h3 id="特殊流密码-RC4"><a href="#特殊流密码-RC4" class="headerlink" title="特殊流密码-RC4"></a>特殊流密码-RC4</h3><p>RSA 由 Ron Rivest 设计，最初隶属于 RSA 安全公司，是一个专利密码产品。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。</p>
<p>RC4 主要包含三个流程：  </p>
<ul>
<li>初始化 S 和 T 数组。</li>
<li>初始化置换 S。</li>
<li>生成密钥流。</li>
</ul>
<h4 id="初始化-S-和-T-数组"><a href="#初始化-S-和-T-数组" class="headerlink" title="初始化 S 和 T 数组"></a>初始化 S 和 T 数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to 255 do</span><br><span class="line">    S[i] = i</span><br><span class="line">    T[i] = K[i mod keylen])</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s_t.png" alt="image"></p>
<h4 id="初始化置换-S"><a href="#初始化置换-S" class="headerlink" title="初始化置换 S"></a>初始化置换 S</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = 0</span><br><span class="line">for i = 0 to 255 do </span><br><span class="line">    j = (j + S[i] + T[i]) (mod 256) </span><br><span class="line">    swap (S[i], S[j])</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s.png" alt="image"></p>
<h4 id="生成流密钥"><a href="#生成流密钥" class="headerlink" title="生成流密钥"></a>生成流密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = j = 0 </span><br><span class="line">for each message byte b</span><br><span class="line">    i = (i + 1) (mod 256)</span><br><span class="line">    j = (j + S[i]) (mod 256)</span><br><span class="line">    swap(S[i], S[j])</span><br><span class="line">    t = (S[i] + S[j]) (mod 256) </span><br><span class="line">    print S[t]</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_key.png" alt="image"></p>
<p>我们一般称前两部分为 KSA ，最后一部分是 PRGA。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/古典密码学基础三/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/古典密码学基础三/" itemprop="url">古典密码学基础三</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T15:59:21+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/古典密码学/" itemprop="url" rel="index">
                    <span itemprop="name">古典密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/03/古典密码学基础三/" class="leancloud_visitors" data-flag-title="古典密码学基础三">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB614471942b2a382c57f0cf2346e379a8?method=download&amp;shareKey=3ce1ae584d6f0c4aaa50ad70471ac721" alt="image"><br>上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。</p>
<p>下面这一段内容就是明文 steganography 使用<br>To encode a message each letter of the plaintext is replaced by a group of five of the letters ‘A’ or ‘B’.<br>加密后的内容，大写为A，小写为B。<br>|明文|s|t|e|g|a|n|o|g|r|a|p|h|y|<br>|-|-|-|-|-|-|-|-|-|-|-|-|-|-|<br>|转换表|baaab|baaba|aabaa|aabba|aaaaa|abbaa|abbab|aabba|baaaa|aaaaa|abbba|aabbb|babba|<br>|密文|tOENc|oDEaM|ESsAG|EEacH|LETTE|RofTH|EplAi|NTexT|iSREP|LACED|ByagR|OUpof|fIveL|</p>
<p>可以看到，培根密码主要有以下特点：</p>
<ul>
<li>只有两种字符（大小写，粗/正常题，斜/正常体等）</li>
<li>每一段的长度为5</li>
<li>加密内容会有特殊的字体之分，亦或大小写之分</li>
</ul>
<p>工具：<a href="http://rumkin.com/tools/cipher/baconian.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/baconian.php</a></p>
<h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子：<br>明文：THERE IS A CIPHER</p>
<p>去掉空格后变为</p>
<blockquote>
<p>THEREISACIPHER</p>
</blockquote>
<p>分成两栏，两个一组得到</p>
<blockquote>
<p>TH ER EI SA CI PH ER</p>
</blockquote>
<p>先取出第一个字母，再取出第二个字母</p>
<blockquote>
<p>TEESCPE<br>HRIAIHR</p>
</blockquote>
<p>连在一起就是</p>
<blockquote>
<p>TEESCPEHRIAIHR</p>
</blockquote>
<p>上述明文也可以分为 2 栏。</p>
<blockquote>
<p>THEREIS ACIPHER</p>
</blockquote>
<p>组合得到密文</p>
<blockquote>
<p>TAHCEIRPEHIESR</p>
</blockquote>
<p>工具：<a href="http://ctf.ssleye.com/railfence.html" target="_blank" rel="noopener">http://ctf.ssleye.com/railfence.html</a></p>
<h3 id="曲路密码"><a href="#曲路密码" class="headerlink" title="曲路密码"></a>曲路密码</h3><p>曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子：  </p>
<blockquote>
<p>明文：The quick brown fox<br>jumps over the lazy dog</p>
</blockquote>
<p>填入 5 行 7 列表（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEBaab90fd8528f744a4b6e3ed6c78df86e?method=download&amp;shareKey=cb2988f0247bbc4a64bb037340e21266" alt="image"><br>加密的回路线（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEB135692c80f25a4ec2cd7bf21aeecbdc9?method=download&amp;shareKey=c983704ab96d9ddaadcfa3d7cf67ab6d" alt="image"><br>密文：gesfc inpho dtmwu qoury zejre hbxva lookT</p>
<h3 id="01248密码"><a href="#01248密码" class="headerlink" title="01248密码"></a>01248密码</h3><p>该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1-&gt;26 表示 A-&gt;Z。</p>
<p>可以看出该密码有以下特点：</p>
<ul>
<li>只有 0，1，2，4，8</li>
</ul>
<p>例如：8842101220480224404014224202480122</p>
<p>按照0来分割：<br>|内容|数字|字符|<br>|-|-|-|<br>|88421|8+8+4+2+1=23|W|<br>|122|1+2+2=5|E|<br>|48|4+8=12|L|<br>|2244|2+2+4+4=12|L|<br>|4|4|D|<br>|142242|1+4+2+2+4+2=15|0|<br>|248|2+4+8=14|N|<br>|122|1+2+2=5|E|<br>明文：WELLDONE</p>
<h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p>JSFuck 可以只用 6 个字符 <a href=""></a>!+ 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 alert(1) 代码如下：  </p>
<blockquote>
<p>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[<a href="(![]+[]">+!+[]]]]</a>[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()</p>
</blockquote>
<p>其他一些基本的表达：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">false       =&gt;  ![]</span><br><span class="line">true        =&gt;  !![]</span><br><span class="line">undefined   =&gt;  [][[]]</span><br><span class="line">NaN         =&gt;  +[![]]</span><br><span class="line">0           =&gt;  +[]</span><br><span class="line">1           =&gt;  +!+[]</span><br><span class="line">2           =&gt;  !+[]+!+[]</span><br><span class="line">10          =&gt;  [+!+[]]+[+[]]</span><br><span class="line">Array       =&gt;  []</span><br><span class="line">Number      =&gt;  +[]</span><br><span class="line">String      =&gt;  []+[]</span><br><span class="line">Boolean     =&gt;  ![]</span><br><span class="line">Function    =&gt;  [][&quot;filter&quot;]</span><br><span class="line">eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()</span><br><span class="line">window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()</span><br></pre></td></tr></table></figure></p>
<p>工具：<a href="http://www.jsfuck.com" target="_blank" rel="noopener">http://www.jsfuck.com</a></p>
<h3 id="BrainFuck"><a href="#BrainFuck" class="headerlink" title="BrainFuck"></a>BrainFuck</h3><p>Brainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印 Hello World！，那么对应的程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure></p>
<p>与其对应的还有 ook。</p>
<p>工具：<a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p>
<h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码是一种以格子为基础的简单替代式密码，格子如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB76a78a8b102de070a7fcdc8824660b2b?method=download&amp;shareKey=71bed2948c5cec3dc77b6ce43c5967c0" alt="image"><br>例如：明文为 X marks the spot ，那么密文如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB542ffbb69121a02be44c46268eae3bac?method=download&amp;shareKey=188f938bab6d2ebea01940a2c755e75d" alt="image"></p>
<p>工具：<a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html" target="_blank" rel="noopener">http://www.simonsingh.net/The_Black_Chamber/pigpen.html</a></p>
<h3 id="舞动的小人密码"><a href="#舞动的小人密码" class="headerlink" title="舞动的小人密码"></a>舞动的小人密码</h3><p>这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB0d432b9016f9d7f01d93260b1c0124d3?method=download&amp;shareKey=dad1725328f62432fc4eb1f48d10f5bb" alt="image"></p>
<h3 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h3><p>所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。</p>
<h4 id="手机键盘密码"><a href="#手机键盘密码" class="headerlink" title="手机键盘密码"></a>手机键盘密码</h4><p>手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB35c2548fd5300110899752984fa99371?method=download&amp;shareKey=4008d4855211fc73f4597b224067d0b6" alt="image"><br>关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。</p>
<h4 id="电脑键盘棋盘密码"><a href="#电脑键盘棋盘密码" class="headerlink" title="电脑键盘棋盘密码"></a>电脑键盘棋盘密码</h4><p>电脑键盘棋盘加密，利用了电脑的棋盘方阵。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB2e33ea38af7f4baf490ff9f39d715c9f?method=download&amp;shareKey=3648b73f7f64573b1a572be93c70e8fb" alt="iamge"></p>
<h4 id="电脑键盘坐标密码"><a href="#电脑键盘坐标密码" class="headerlink" title="电脑键盘坐标密码"></a>电脑键盘坐标密码</h4><p>电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe0e36122c77aa2b4f9082895a8d6082b?method=download&amp;shareKey=714cffcaddd3a713461ba4e51c85d471" alt="image"></p>
<h4 id="电脑键盘QWE"><a href="#电脑键盘QWE" class="headerlink" title="电脑键盘QWE"></a>电脑键盘QWE</h4><p>电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd5d37d656e0d67ee4d6abf87233c61d0?method=download&amp;shareKey=5f547f51c40690833c88da1a7f3e0077" alt="image"></p>
<h3 id="CTF案例"><a href="#CTF案例" class="headerlink" title="CTF案例"></a>CTF案例</h3><ol>
<li>0CTF 2014 classic<blockquote>
<p>小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb</p>
</blockquote>
</li>
</ol>
<p>发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到 0ops 字样，猜测就是 flag 了。</p>
<ol start="2">
<li>2017 年 xman 选拔赛——一二三，木头人 <blockquote>
<p>我数 123 木头人，再不行动就要被扣分。</p>
<p>23731263111628163518122316391715262121</p>
<p>密码格式 xman{flag}<br>题目中有很明显的提示 123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是 1-3 范围内的，也验证了我们的猜测。于是：<br>23-x</p>
<p>73-m</p>
<p>12-a</p>
<p>63-n</p>
<p>11-q</p>
</blockquote>
</li>
</ol>
<p>不对呀，密码格式是 xman{，第四个字符是 {，于是看了看 { 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么 111 就是 {。然后依次往后推，发现确实可行，，最后再把 121 视为 } 即可得到 flag.</p>
<blockquote>
<p>xman{hintisenough}</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Heinz">
            
              <p class="site-author-name" itemprop="name">Heinz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/itmayi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:799902881@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heinz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jypPJXy89LBDsg88boqicDg9-gzGzoHsz", "7z1xPLru7WIRw9p0A6SE779N");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
