<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="榆木的博客">
<meta name="keywords" content="随笔">
<meta property="og:type" content="website">
<meta property="og:title" content="Heinz Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Heinz Blog">
<meta property="og:description" content="榆木的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heinz Blog">
<meta name="twitter:description" content="榆木的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Heinz Blog - 记录每一段岁月的美好！</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heinz Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">记录每一段岁月的美好！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/现代密码学基础一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/现代密码学基础一/" itemprop="url">现代密码学基础一</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:30:20+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/04/现代密码学基础一/" class="leancloud_visitors" data-flag-title="现代密码学基础一">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码一般逐字节或者逐比特处理信息。一般来说：</p>
<ul>
<li>流密码的密钥长度会与明文的长度相同。</li>
<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>
</ul>
<p>需要注意的是，流加密目前来说都是对称加密。</p>
<p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p>
<p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>
<p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。</p>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3><p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>
<p>就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。</p>
<h4 id="随机性的严格性"><a href="#随机性的严格性" class="headerlink" title="随机性的严格性"></a>随机性的严格性</h4><ul>
<li>随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。</li>
<li>不可预测性：不能从过去的序列推测出下一个出现的数。</li>
<li>不可重现性：除非数列保存下来，否则不能重现相同的数列。</li>
</ul>
<p>这三个性质的严格性依次递增。</p>
<p>一般来说，随机数可以分为三类</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>随机性</th>
<th>不可预测性</th>
<th>不可重现性</th>
</tr>
</thead>
<tbody>
<tr>
<td>弱伪随机数</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>强伪随机数</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>真随机数</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>一般来说，密码学中使用的随机数是第二种。</p>
<h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>正如我们之前所说，一旦 PRNG 所依赖的种子确定了，那么 PRNG 生成的随机数序列基本也就确定了。这里定义 PRNG 的周期如下：对于一个 PRNG 的所有可能起始状态，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的(一般性限制条件)。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>目前通用的伪随机数生成器主要有：</p>
<ul>
<li>线性同余生成器，LCG</li>
<li>线性回归发生器</li>
<li>线性反馈移位寄存器（Linear feedback shift register，LFSR）</li>
<li>Mersenne Twister</li>
<li>xorshift generators</li>
<li>WELL family of generators</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>通常来说，伪随机数生成器可能会有以下问题：  </p>
<ul>
<li>在某些种子的情况下，其生成的随机数序列的周期会比较小。</li>
<li>生成大数时，分配的不均匀。</li>
<li>连续值之间关联密切，知道后续值，可以知道之前的值。</li>
<li>输出序列的值的大小很不均匀。</li>
</ul>
<h3 id="密码安全伪随机数数生成器"><a href="#密码安全伪随机数数生成器" class="headerlink" title="密码安全伪随机数数生成器"></a>密码安全伪随机数数生成器</h3><p>密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator，CSPRNG），也称为密码学伪随机数生成器（cryptographic pseudo-random number generator，CPRNG)，是一种特殊的伪随机数生成器。它需要满足满足一些必要的特性，以便于适合于密码学应用。</p>
<p>密码学的很多方面都需要随机数：</p>
<ul>
<li>密钥生成</li>
<li>生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式</li>
<li>nonce，用于防止重放攻击以及分组密码的 CTR 模式等、</li>
<li>one-time pads</li>
<li>某些签名方案中的盐，如 ECDSA， RSASSA-PSS</li>
</ul>
<p>注：在资讯安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>毫无疑问，密码学安全伪随机数生成器的要求肯定比一般的伪随机数生成器要高。一般而言，CSPRNG 的要求可以分为两类</p>
<ul>
<li>通过统计随机性测试。CSPRNG 必须通过 next-bit test，也就是说，知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于 50% 的概率预测出来下一个比特位。这里特别提及一点，姚期智曾在 1982 年证明，如果一个生成器可以通过 next-bit test，那么它也可以通过所有其他的多项式时间统计测试。</li>
<li>必须能够抵抗足够强的攻击，比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄漏状态之前的生成的随机数。</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>就目前而看， CSPRNG 的设计可以分为以下三类</p>
<ul>
<li>基于密码学算法，如密文或者哈希值。</li>
<li>基于数学难题</li>
<li>某些特殊目的的设计</li>
</ul>
<h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><p>一般的，一个 n 级反馈移位寄存器如下图所示</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc234f54efe1a0af70602bf1974c14605?method=download&amp;shareKey=415fcf56b93e427f2b1df0417a1add43" alt="image"></p>
<ul>
<li>$a_0$,$a_1$,…,$a_{n-1}$为初态。</li>
<li>F为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。</li>
<li>$a_{i+n}$=F($a_i$,$a_{i+1}$,…,$a_{i+n-1}$)</li>
</ul>
<p>一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即</p>
<p>($a_i$,$a_{i+1}$,…,$a_{i+n-1}$) -&gt; ($a_{i+1}$,..,$a_{i+n-1}$,$a_{i+n}$),对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。</p>
<h4 id="非线性反馈寄存器"><a href="#非线性反馈寄存器" class="headerlink" title="非线性反馈寄存器"></a>非线性反馈寄存器</h4><p>//TODO</p>
<h3 id="特殊流密码-RC4"><a href="#特殊流密码-RC4" class="headerlink" title="特殊流密码-RC4"></a>特殊流密码-RC4</h3><p>RSA 由 Ron Rivest 设计，最初隶属于 RSA 安全公司，是一个专利密码产品。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。</p>
<p>RC4 主要包含三个流程：  </p>
<ul>
<li>初始化 S 和 T 数组。</li>
<li>初始化置换 S。</li>
<li>生成密钥流。</li>
</ul>
<h4 id="初始化-S-和-T-数组"><a href="#初始化-S-和-T-数组" class="headerlink" title="初始化 S 和 T 数组"></a>初始化 S 和 T 数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to 255 do</span><br><span class="line">    S[i] = i</span><br><span class="line">    T[i] = K[i mod keylen])</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s_t.png" alt="image"></p>
<h4 id="初始化置换-S"><a href="#初始化置换-S" class="headerlink" title="初始化置换 S"></a>初始化置换 S</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = 0</span><br><span class="line">for i = 0 to 255 do </span><br><span class="line">    j = (j + S[i] + T[i]) (mod 256) </span><br><span class="line">    swap (S[i], S[j])</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_s.png" alt="image"></p>
<h4 id="生成流密钥"><a href="#生成流密钥" class="headerlink" title="生成流密钥"></a>生成流密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = j = 0 </span><br><span class="line">for each message byte b</span><br><span class="line">    i = (i + 1) (mod 256)</span><br><span class="line">    j = (j + S[i]) (mod 256)</span><br><span class="line">    swap(S[i], S[j])</span><br><span class="line">    t = (S[i] + S[j]) (mod 256) </span><br><span class="line">    print S[t]</span><br></pre></td></tr></table></figure>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/figure/rc4_key.png" alt="image"></p>
<p>我们一般称前两部分为 KSA ，最后一部分是 PRGA。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/古典密码学基础三/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/古典密码学基础三/" itemprop="url">古典密码学基础三</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T15:59:21+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/03/古典密码学基础三/" class="leancloud_visitors" data-flag-title="古典密码学基础三">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB614471942b2a382c57f0cf2346e379a8?method=download&amp;shareKey=3ce1ae584d6f0c4aaa50ad70471ac721" alt="image"><br>上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。</p>
<p>下面这一段内容就是明文 steganography 使用<br>To encode a message each letter of the plaintext is replaced by a group of five of the letters ‘A’ or ‘B’.<br>加密后的内容，大写为A，小写为B。<br>|明文|s|t|e|g|a|n|o|g|r|a|p|h|y|<br>|-|-|-|-|-|-|-|-|-|-|-|-|-|-|<br>|转换表|baaab|baaba|aabaa|aabba|aaaaa|abbaa|abbab|aabba|baaaa|aaaaa|abbba|aabbb|babba|<br>|密文|tOENc|oDEaM|ESsAG|EEacH|LETTE|RofTH|EplAi|NTexT|iSREP|LACED|ByagR|OUpof|fIveL|</p>
<p>可以看到，培根密码主要有以下特点：</p>
<ul>
<li>只有两种字符（大小写，粗/正常题，斜/正常体等）</li>
<li>每一段的长度为5</li>
<li>加密内容会有特殊的字体之分，亦或大小写之分</li>
</ul>
<p>工具：<a href="http://rumkin.com/tools/cipher/baconian.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/baconian.php</a></p>
<h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子：<br>明文：THERE IS A CIPHER</p>
<p>去掉空格后变为</p>
<blockquote>
<p>THEREISACIPHER</p>
</blockquote>
<p>分成两栏，两个一组得到</p>
<blockquote>
<p>TH ER EI SA CI PH ER</p>
</blockquote>
<p>先取出第一个字母，再取出第二个字母</p>
<blockquote>
<p>TEESCPE<br>HRIAIHR</p>
</blockquote>
<p>连在一起就是</p>
<blockquote>
<p>TEESCPEHRIAIHR</p>
</blockquote>
<p>上述明文也可以分为 2 栏。</p>
<blockquote>
<p>THEREIS ACIPHER</p>
</blockquote>
<p>组合得到密文</p>
<blockquote>
<p>TAHCEIRPEHIESR</p>
</blockquote>
<p>工具：<a href="http://ctf.ssleye.com/railfence.html" target="_blank" rel="noopener">http://ctf.ssleye.com/railfence.html</a></p>
<h3 id="曲路密码"><a href="#曲路密码" class="headerlink" title="曲路密码"></a>曲路密码</h3><p>曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子：  </p>
<blockquote>
<p>明文：The quick brown fox<br>jumps over the lazy dog</p>
</blockquote>
<p>填入 5 行 7 列表（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEBaab90fd8528f744a4b6e3ed6c78df86e?method=download&amp;shareKey=cb2988f0247bbc4a64bb037340e21266" alt="image"><br>加密的回路线（事先约定填充的行列数）<br><img src="https://note.youdao.com/yws/api/personal/file/WEB135692c80f25a4ec2cd7bf21aeecbdc9?method=download&amp;shareKey=c983704ab96d9ddaadcfa3d7cf67ab6d" alt="image"><br>密文：gesfc inpho dtmwu qoury zejre hbxva lookT</p>
<h3 id="01248密码"><a href="#01248密码" class="headerlink" title="01248密码"></a>01248密码</h3><p>该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1-&gt;26 表示 A-&gt;Z。</p>
<p>可以看出该密码有以下特点：</p>
<ul>
<li>只有 0，1，2，4，8</li>
</ul>
<p>例如：8842101220480224404014224202480122</p>
<p>按照0来分割：<br>|内容|数字|字符|<br>|-|-|-|<br>|88421|8+8+4+2+1=23|W|<br>|122|1+2+2=5|E|<br>|48|4+8=12|L|<br>|2244|2+2+4+4=12|L|<br>|4|4|D|<br>|142242|1+4+2+2+4+2=15|0|<br>|248|2+4+8=14|N|<br>|122|1+2+2=5|E|<br>明文：WELLDONE</p>
<h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p>JSFuck 可以只用 6 个字符 <a href=""></a>!+ 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 alert(1) 代码如下：  </p>
<blockquote>
<p>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[<a href="(![]+[]">+!+[]]]]</a>[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()</p>
</blockquote>
<p>其他一些基本的表达：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">false       =&gt;  ![]</span><br><span class="line">true        =&gt;  !![]</span><br><span class="line">undefined   =&gt;  [][[]]</span><br><span class="line">NaN         =&gt;  +[![]]</span><br><span class="line">0           =&gt;  +[]</span><br><span class="line">1           =&gt;  +!+[]</span><br><span class="line">2           =&gt;  !+[]+!+[]</span><br><span class="line">10          =&gt;  [+!+[]]+[+[]]</span><br><span class="line">Array       =&gt;  []</span><br><span class="line">Number      =&gt;  +[]</span><br><span class="line">String      =&gt;  []+[]</span><br><span class="line">Boolean     =&gt;  ![]</span><br><span class="line">Function    =&gt;  [][&quot;filter&quot;]</span><br><span class="line">eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()</span><br><span class="line">window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()</span><br></pre></td></tr></table></figure></p>
<p>工具：<a href="http://www.jsfuck.com" target="_blank" rel="noopener">http://www.jsfuck.com</a></p>
<h3 id="BrainFuck"><a href="#BrainFuck" class="headerlink" title="BrainFuck"></a>BrainFuck</h3><p>Brainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印 Hello World！，那么对应的程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure></p>
<p>与其对应的还有 ook。</p>
<p>工具：<a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p>
<h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码是一种以格子为基础的简单替代式密码，格子如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB76a78a8b102de070a7fcdc8824660b2b?method=download&amp;shareKey=71bed2948c5cec3dc77b6ce43c5967c0" alt="image"><br>例如：明文为 X marks the spot ，那么密文如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB542ffbb69121a02be44c46268eae3bac?method=download&amp;shareKey=188f938bab6d2ebea01940a2c755e75d" alt="image"></p>
<p>工具：<a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html" target="_blank" rel="noopener">http://www.simonsingh.net/The_Black_Chamber/pigpen.html</a></p>
<h3 id="舞动的小人密码"><a href="#舞动的小人密码" class="headerlink" title="舞动的小人密码"></a>舞动的小人密码</h3><p>这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB0d432b9016f9d7f01d93260b1c0124d3?method=download&amp;shareKey=dad1725328f62432fc4eb1f48d10f5bb" alt="image"></p>
<h3 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h3><p>所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。</p>
<h4 id="手机键盘密码"><a href="#手机键盘密码" class="headerlink" title="手机键盘密码"></a>手机键盘密码</h4><p>手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB35c2548fd5300110899752984fa99371?method=download&amp;shareKey=4008d4855211fc73f4597b224067d0b6" alt="image"><br>关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。</p>
<h4 id="电脑键盘棋盘密码"><a href="#电脑键盘棋盘密码" class="headerlink" title="电脑键盘棋盘密码"></a>电脑键盘棋盘密码</h4><p>电脑键盘棋盘加密，利用了电脑的棋盘方阵。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB2e33ea38af7f4baf490ff9f39d715c9f?method=download&amp;shareKey=3648b73f7f64573b1a572be93c70e8fb" alt="iamge"></p>
<h4 id="电脑键盘坐标密码"><a href="#电脑键盘坐标密码" class="headerlink" title="电脑键盘坐标密码"></a>电脑键盘坐标密码</h4><p>电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe0e36122c77aa2b4f9082895a8d6082b?method=download&amp;shareKey=714cffcaddd3a713461ba4e51c85d471" alt="image"></p>
<h4 id="电脑键盘QWE"><a href="#电脑键盘QWE" class="headerlink" title="电脑键盘QWE"></a>电脑键盘QWE</h4><p>电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd5d37d656e0d67ee4d6abf87233c61d0?method=download&amp;shareKey=5f547f51c40690833c88da1a7f3e0077" alt="image"></p>
<h3 id="CTF案例"><a href="#CTF案例" class="headerlink" title="CTF案例"></a>CTF案例</h3><ol>
<li>0CTF 2014 classic<blockquote>
<p>小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb</p>
</blockquote>
</li>
</ol>
<p>发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到 0ops 字样，猜测就是 flag 了。</p>
<ol start="2">
<li>2017 年 xman 选拔赛——一二三，木头人 <blockquote>
<p>我数 123 木头人，再不行动就要被扣分。</p>
<p>23731263111628163518122316391715262121</p>
<p>密码格式 xman{flag}<br>题目中有很明显的提示 123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是 1-3 范围内的，也验证了我们的猜测。于是：<br>23-x</p>
<p>73-m</p>
<p>12-a</p>
<p>63-n</p>
<p>11-q</p>
</blockquote>
</li>
</ol>
<p>不对呀，密码格式是 xman{，第四个字符是 {，于是看了看 { 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么 111 就是 {。然后依次往后推，发现确实可行，，最后再把 121 视为 } 即可得到 flag.</p>
<blockquote>
<p>xman{hintisenough}</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/古典密码学基础二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/古典密码学基础二/" itemprop="url">古典密码学基础二</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T15:56:14+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/03/古典密码学基础二/" class="leancloud_visitors" data-flag-title="古典密码学基础二">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="多表代换密码"><a href="#多表代换密码" class="headerlink" title="多表代换密码"></a>多表代换密码</h3><p>对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。</p>
<h4 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h4><p>维吉尼亚密码是广为人知的多表替换式密码，也称为多字母替换式密码。</p>
<p>在一个凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E……而维吉尼亚密码则是由一些偏移量不同的恺撒密码组成。</p>
<p>为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。</p>
<p>例如：</p>
<p>假设明文是ATTACKATDAWN，选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：LEMONLEMONLE</p>
<p>对于明文的第一个字母A，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母L。类似地，明文第二个字母为T，在表格中使用对应的E行进行加密，得到密文第二个字母X。以此类推，可以得到：</p>
<p>明文：ATTACKATDAWN<br>密钥：LEMONLEMONLE<br>密文：LXFOPVEFRNHR</p>
<p>解密的过程则与加密相反。例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母L位于A列，因而明文第一个字母为A。密钥第二个字母E对应E行字母表，而密文第二个字母X位于此行T列，因而明文第二个字母为T。以此类推便可得到明文。</p>
<p>用数字0-25代替字母A-Z，维吉尼亚密码的加密文法可以写成同余的形式：</p>
<p>$C_i$=$P_i$+$K_i(mod\ 26)$</p>
<p>解密方法则能写成：</p>
<p>$P_i$=$C_i$-$K_i(mod\ 26)$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/古典密码学基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/古典密码学基础/" itemprop="url">古典密码学基础一</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T09:28:25+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/密码学/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/03/古典密码学基础/" class="leancloud_visitors" data-flag-title="古典密码学基础一">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>古典密码学是密码学中的其中一个类型，其大部分加密方式都是利用替换式密码或移项式密码，或者两者的混合。其与历史中经常使用，但现代已经很少使用，大部分已经不再使用。在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。<br>。</p>
<h2 id="密码分类"><a href="#密码分类" class="headerlink" title="密码分类"></a>密码分类</h2><h3 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h3><p>对字母做系统的替换，直到讯息被替换为难以理解的字。</p>
<h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><p>凯撒密码是广为人知的单表式替换密码，它只使用一个密码字母集。</p>
<p>为了使用凯撒密码加密讯息，每个密码字母集中字母将会被其位置的后三个字母替代。因此字母A將会被字母D替代、字母B將会被字母E替代、字母C將会被字母F替代等，最后，X、Y和Z將分別的被替代成A、B和C。例如，”WIKIPEDIA”將被加密成”ZLNLSHGLD”。凱撒把字母向后移”3”位，但其他数字也是类似。</p>
<p>根据偏移量的不同，还存在若干特定的恺撒密码名称：</p>
<ul>
<li>偏移量为 10：Avocat （A→K）</li>
<li>偏移量为 13：ROT13</li>
<li>偏移量为 -5：Cassis （K 6）</li>
<li>偏移量为 -6：Cassette （K 7）</li>
</ul>
<p>另一种替换式密码是使用关键字（等同于密钥），你可以选择一个字母或片段并去除所有的空格和重复字母，接着把它当做密码字母集的开头，把去除密钥后的其他字母接续排序。例如，如果关键字是cipher，则密码字母表会是下面的情况：</p>
<p>一般密码字母集: a b c d e f g h i j k l m n o p q r s t u v w x y z</p>
<p>密钥密码字母集: c i p h e r s t u v w x y z a b d f g j k l m n o q</p>
<p>还有一种基于密钥的凯撒密码，其基本原理是利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为密钥加密明文的每一位字母。例如：<br>密文：s0a6u3u1s0bv1a<br>密钥：guangtou<br>偏移：6,20,0,13,6,19,14,20<br>明文：y0u6u3h1y0uj1u  </p>
<p>对于不带密钥的凯撒密码来说，破解方式有两种：  </p>
<ul>
<li>遍历 26 个偏移量，适用于普遍情况。</li>
<li>在密文长度足够长的时候，使用词频分析<a href="https://quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></li>
</ul>
<p>其中，第一种方式肯定可以得到明文，而第二种方式则不一定可以得到正确的明文。</p>
<p>而对于基于密钥的凯撒密码来说，一般来说必须知道对应的密钥。</p>
<p>工具：<br>一般我们有如下的工具，其中 JPK 比较通用。</p>
<ul>
<li>JPK，可解带密钥与不带密钥</li>
<li><a href="http://planetcalc.com/1434/" target="_blank" rel="noopener">http://planetcalc.com/1434/</a></li>
<li><a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php</a></li>
</ul>
<h4 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h4><p>简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。 比如：<br>明文字母 : abcdefghijklmnopqrstuvwxyz<br>密钥字母 : phqgiumeaylnofdxjkrcvstzwb<br>a 对应 p，d 对应 h，以此类推。<br>明文：the quick brown fox jumps over the lazy dog<br>密文：cei jvaql hkdtf udz yvoxr dsik cei npbw gdm<br>而解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。</p>
<p>由于这种加密方式导致其所有的密钥个数是26!，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。</p>
<p>工具：<a href="http://quipqiup.com/" target="_blank" rel="noopener">http://quipqiup.com/</a></p>
<h3 id="移位式密码"><a href="#移位式密码" class="headerlink" title="移位式密码"></a>移位式密码</h3><p>与凯撒密码类似，区别在于移位密码不仅会处理字母，还会处理数字和特殊字符，常用 ASCII 码表进行移位。其破解方法也是遍历所有的可能性来得到可能的结果。</p>
<h4 id="纵线式移位密码"><a href="#纵线式移位密码" class="headerlink" title="纵线式移位密码"></a>纵线式移位密码</h4><p>一个移位式密码的具体例子就是纵线式移位密码。先选择一个关键字，把原来的讯息由左向右、由上到下依照关键字长度转写成长方形。接着把关键字的字母依照字母集顺序编号，例如a就是1，b就是2，c就是3等。例如：关键字是CAT，明文是THE SKY IS BLUE，则讯息应该被转换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C A T  </span><br><span class="line">3 1 20  </span><br><span class="line">T H E  </span><br><span class="line">S K Y  </span><br><span class="line">I S B  </span><br><span class="line">L U E</span><br></pre></td></tr></table></figure></p>
<p> 最后把讯息以行为单位，依照编号大小调换位置，呈现的应该是 A为第一行，C为第二行，T为第三行。然后就可以把讯息转换成HKSUTSILEYBE</p>
<h4 id="中国式密码"><a href="#中国式密码" class="headerlink" title="中国式密码"></a>中国式密码</h4><p> 另外一种移位式密码是中国式密码，移位的方法是将讯息的字母加密成由右向左、上下交替的不规则的字母。例如，如果明文是THE DOG RAN FAR，则中国式密码看起来像这样：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R  R   G   T</span><br><span class="line">A  A   O   H</span><br><span class="line">F  N   D   E</span><br></pre></td></tr></table></figure></p>
<p> 密文将被是：RRGT AAOH FNDE</p>
<h4 id="艾特巴什码"><a href="#艾特巴什码" class="headerlink" title="艾特巴什码"></a>艾特巴什码</h4><p>埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：<br>明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A<br>下面给出一个例子：<br>明文：the quick brown fox jumps over the lazy dog<br>密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt</p>
<p>可以看出其密钥空间足够短，同时当密文足够长时，仍然可以采用词频分析的方法解决。</p>
<p>工具：<a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/" target="_blank" rel="noopener">http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/</a></p>
<h3 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h3><p>原理：<br>仿射密码的加密函数是<br>E(x)=(ax+b)(mod m)，其中：  </p>
<ul>
<li>x表示明文按照某种编码得到的数字</li>
<li>a和m互质</li>
<li>m是编码系统中字母的数目。</li>
</ul>
<p>解密函数是D(x)=$a^{-1}$(x-b)(mod m),其中$a^{-1}$是a在整数群的乘法逆元。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">明文:A F F I N  E C I P H E R </span><br><span class="line">x:  0 5 5 8 13 4 2 8 15 7 4 17</span><br><span class="line">y=5x+8:8 33 33 48 73 28 18 48 83 43 28 93</span><br><span class="line">y mod 26:8 7 7 22 21 2 18 22 5 17 2 15 </span><br><span class="line">密文:I H H W V C S W F R C P</span><br></pre></td></tr></table></figure></p>
<p>其对应的加密结果是 IHHWVCSWFRCP。</p>
<p>对于解密过程，正常解密者具有 a 与 b，可以计算得到$a^{-1}$为 21，所以其解密函数是:D(x)=21(x-8)(mod 26)</p>
<p>破解：<br>首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。</p>
<p>其次，我们可以考虑如何攻击该密码。可以看出当a=1时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有 26 个字母，而不大于 26 的与 26 互素的个数一共有ϕ(26）=ϕ(2)Xϕ(13)=12,算上 b 的偏移可能，一共有可能的密钥空间大小也就是12×26=312 </p>
<p>一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。</p>
<p>这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。</p>
<p>但是，假设我们已经知道采用的字母集，这里假设为 26 个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母$y_1$,$y_2$即可进行解密。那么我们还可以知道:<br>$y_1$=(a$x_1$+b)(mod 26)<br>$y_2$=(a$x_2$+b)(mod 26)<br>二者相减,可得：<br>$y_1$-$y_2$=a($x_1$-$x_2$)(mod 26)</p>
<p>这里$y_1$,$y_2$已知，如果我们知道密文对应的两个不一样的字符$x_1$,$x_2$，那么我们就可以很容易得到 a，进而就可以得到 b了。</p>
<h2 id="密码破译"><a href="#密码破译" class="headerlink" title="密码破译"></a>密码破译</h2><p> 经典密码通常很容易被破解。许多经典密码可单由密文而破解，所以它们容易遭受到唯密文攻击法攻击。有些经典密码（例如凯撒密码）的密钥个数有限，所以这类密码可以通过暴力破解尝试所有的密钥。替换式密码有较大的密钥数，但是很容易被频率分析，因为每个密码字母各代替了一个明文字母。多表式替换密码使用多个替换可防止简单的频率分析，但卡西斯基验、弗里德曼试验可用来破解这类密码。</p>
<h3 id="卡西斯基试验"><a href="#卡西斯基试验" class="headerlink" title="卡西斯基试验"></a>卡西斯基试验</h3><p> 卡西斯基试验是基于类似the这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的CRYPTO可能被密钥ABCDEF加密成不同的密文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥：ABCDEF AB CDEFA BCD EFABCDEFABCD</span><br><span class="line">明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB</span><br></pre></td></tr></table></figure></p>
<p>此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥ABCD）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥：ABCDAB CD ABCDA BCD ABCDABCDABCD</span><br><span class="line">明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASTP KV SIQUT GQU CSASTPIUAQJB</span><br></pre></td></tr></table></figure></p>
<p>此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：<br>密文：<strong>DYDUXRMH</strong>TVDV<strong>NQD</strong>QNW<strong>DYDUXRMH</strong>ARTJGW<strong>NQD</strong></p>
<p>其中，两个DYDUXRMH的出现相隔了18个字母。因此，可以假定密钥的长度是18的约数，即长度为18、9、6、3或2。而两个NQD则相距20个字母，意味着密钥长度应为20、10、5、4或2。取两者的交集，则可以基本确定密钥长度为2。</p>
<h3 id="弗里德曼试验"><a href="#弗里德曼试验" class="headerlink" title="弗里德曼试验"></a>弗里德曼试验</h3><p>它使用了重合指数（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。$k_p$指目标语言中两个任意字母相同的概率（英文中为0.067），$k_r$指字母表中这种情况出现的概率（英文中为1/26=0.0385），从而密钥长度可以估计为：  </p>
<p>分子 = $k_p$-$k_r$</p>
<p>分母 = $k_o$-$k_r$</p>
<p>密钥长度 = $\frac{分子}{分母}$</p>
<p>此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。</p>
<h3 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h3><p>一旦能够确定密钥的长度，密文就能重新写成多列，列数与密钥长度对应。这样每一列其实就是一个凯撒密码，而此密码的密钥（偏移量）则对应于维吉尼亚密码密钥的相应字母。与破译凯撒密码类似的方法，就能将密文破译。</p>
<p>柯克霍夫方法作为卡西斯基试验的改进，由奥古斯特·柯克霍夫（Auguste Kerckhoffs）提出。它将每一列的字母频率与转换后的明文频率相对应而得出每一列的密钥字母。一旦密钥中每一个字母都能确定，就能很简单地破译密文，从而得到明文。如果维吉尼亚字母表表格本身是杂乱而非按通常字母表顺序的话，那柯克霍夫方法就会无效，但卡西斯基试验和重复指数对于决定密钥长度仍旧是有效的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/Android编译器相关/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/Android编译器相关/" itemprop="url">Android编译器相关</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T10:17:43+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/02/Android编译器相关/" class="leancloud_visitors" data-flag-title="Android编译器相关">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MIR -&gt; LIR -&gt; native code</p>
<p>SSA：（编译器后端寄存器分配算法，static single assignment）静态单一复制法，是一种中间表示形式。<br>之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。</p>
<p>在某种程度上，可以认为MIR即为对dalvik指令进行SSA变换之后的指令形态。</p>
<p>接着就调用cu.cg-&gt;Materialize()用来产生最终代码，其中重要的两个调用就是MethodMIR2LIR()和AssembleLIR()。<br>通MethodMIR2LIR()将MIR转化为LIR，遍历每个BasicBlock，对每个基本块执行MethodBlockCodeGen，<br>本质上最后是执行了CompileDalvikInstruction。CompileDalvikInstruction也就是通过解析指令，然后根据opcode进行分支判断，<br>调用最终不同的指令生成函数，最后LIR之间也形成一个双向链表。最终将MIR转换为LIR。</p>
<p>AssembleLIR()最终调用的是AssembleInstructions函数。程序中维护了一个编码指令表MipsMir2Lir::EncodingMap，<br>AssembleInstructions即是通过查找这个表来进行翻译，将LIR转化为了MIPS指令，<br>并将所翻译的指令存储到CodeBufferMir2Lir::code_buffer_之中。<br>这样就完成了一次编译的完整流程。</p>
<p>总结：<br>MIR为对dalvik指令进行SSA变换之后的指令形态。<br>LIR为对MIR形态的指令进行解析生成的另一种形态的指令。<br>native code为通过查找编码指令表将LIR形态的指令翻译为对应不同平台的汇编指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/Android-逐步认识ART系列二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/Android-逐步认识ART系列二/" itemprop="url">Android 逐步认识ART系列二</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-28T11:33:34+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/12/28/Android-逐步认识ART系列二/" class="leancloud_visitors" data-flag-title="Android 逐步认识ART系列二">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="boot-oat"><a href="#boot-oat" class="headerlink" title="boot.oat"></a>boot.oat</h1><ul>
<li>Contains libs and frameworks in boot class path<br>  – To be pre-loaded in all apps（系统启动路径下的的需要预加载库和框架）</li>
</ul>
<p>任何应用程序都不是孤立存在的，几乎所有应用程序都会依赖Android Framework中提供的基础类，例如Activity，Intent，Parcel等类。所以在应用程序的代码中，自然少不了对于这些类的引用.</p>
<p>考虑到几乎所有应用都存在这种引用关系，在运行时都会依赖于Framework中的类，因此系统如何处理这部分逻辑就是非常重要的了，因为这个处理的方法将影响到所有应用程序。</p>
<p>在AOSP编译时，会将所有这些公共类放到专门的一个Oat文件中，这个文件就是：boot.oat。与之配合的还有一个boot.art文件。</p>
<p>boot.oat可以在两个地方找到：</p>
<ol>
<li><p>/system/framework/[platform]/boot.oat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/system/framework/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     50767704 2014-11-20 19:07 boot.oat</span><br></pre></td></tr></table></figure>
</li>
<li><p>/data/dalvik-cache/[platform]/system@<a href="mailto:framework@boot.oat" target="_blank" rel="noopener">framework@boot.oat</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/data/dalvik-cache/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     51003824 1970-05-29 01:45 system@framework@boot.oat</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/dex2oat --image=/data/dalvik-cache/system@framework@boot.art --runtime-arg</span><br><span class="line">-Xms64m --runtime-arg -Xmx64m --dex-file=/system/framework/core-libart.jar --dex-file=/</span><br><span class="line">system/framework/conscrypt.jar --dex-file=/system/framework/okhttp.jar --dex-file=/</span><br><span class="line">system/framework/core-junit.jar --dex-file=/system/framework/bouncycastle.jar --dexfile=/system/framework/ext.jar --dex-file=/system/framework/framework.jar --dex-file=/</span><br><span class="line">system/framework/framework2.jar --dex-file=/system/framework/telephony-common.jar --</span><br><span class="line">dex-file=/system/framework/voip-common.jar --dex-file=/system/framework/mms-common.jar</span><br><span class="line">--dex-file=/system/framework/android.policy.jar --dex-file=/system/framework/</span><br><span class="line">services.jar --dex-file=/system/framework/apache-xml.jar --dex-file=/system/framework/</span><br><span class="line">webviewchromium.jar --oat-file=/data/dalvik-cache/system@framework@boot.oat --runtimearg -implicit-checks:none --instruction-set=arm --instruction-set-features=default --</span><br><span class="line">base=0x70000000 --image-classes-zip=/system/framework/framework.jar</span><br></pre></td></tr></table></figure>
<p><strong>上面命令编译进boot.oat中的jar:</strong><br>/system/framework/core-libart.jar<br>/system/framework/conscrypt.jar<br>/system/framework/okhQp.jar<br>/system/framework/core-junit.jar<br>/system/framework/bouncycastle.jar<br>/system/framework/ext.jar<br>/system/framework/framework.jar<br>/system/framework/framework2.jar<br>/system/framework/telephony-common.jar<br>/system/framework/voip-common.jar<br>/system/framework/mms-common.jar<br>/system/framework/android.policy.jar<br>/system/framework/services.jar<br>/system/framework/apache-xml.jar<br>/system/framework/webviewchromium.jar  </p>
<h1 id="boot-art-boot-image"><a href="#boot-art-boot-image" class="headerlink" title="boot.art(boot image)"></a>boot.art(boot image)</h1><ul>
<li>contains absolute pointers for methods in boot.oat(以绝对地址指向boot.oat中的方法)</li>
<li>boot.art和boot.oat的加载地址都是32位，在64位的系统上，高32位都是0</li>
</ul>
<p>boot.art中包含了指向boot.oat中方法代码的指针，它被称之为启动镜像（Boot Image），并且被加载的位置是固定的。boot.oat被加载的地址紧随着boot.art。</p>
<p>boot.art可以在两个地方找到：</p>
<ol>
<li><p>/system/framework/[platform]/boot.art</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/system/framework/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     11829248 2014-11-20 19:07 boot.art</span><br></pre></td></tr></table></figure>
</li>
<li><p>/data/dalvik-cache/[platform]/system@<a href="mailto:framework@boot.art" target="_blank" rel="noopener">framework@boot.art</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/data/dalvik-cache/arm # ls -l</span><br><span class="line">-rw-r--r-- root     root     11829248 1970-05-29 01:45 system@framework@boot.art</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h1><ul>
<li>By default,ART compiles methods regardless of impact on performance(ART编译方法时，不会考虑对性能的影响)</li>
<li>Profiling feature allows ART to be more selective on which methods to compile(profile能够控制dex2oat具体要对哪些方法进行编译优化)</li>
<li>Profiling配置默认可能是关闭的。可以通过setprop手动打开</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setprop dalvik.vm.profiler 1</span><br></pre></td></tr></table></figure>
<p>- No AOT compilation upon app install(在App安装时不会进行AOT优化，一方面时为了减少安装时间、另一方面时节省存储空间)</p>
<ul>
<li>Profiling data is collected while app is runing(在App运行期间，会收集profile数据)</li>
<li>Profile files are placed in /data/dalvik-cache/profiles</li>
<li>Profile file name is the package name</li>
<li>Profile data is used to determine if AOT compilation will be done</li>
</ul>
<p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">42/2/352  </span><br><span class="line">android.database.Cursor com.android.email.provider.EmailProvider.uiAccounts(java.lang.String[])/1/128  </span><br><span class="line">void com.android.email.NotificationController.ensureHandlerExists()/1/37</span><br><span class="line">int com.android.email.provider.EmailProvider.getFolderTypeFromMailboxType(int)/2/56</span><br><span class="line">boolean com.android.mail.browse.ConversationCursor$ConversationProvider.onCreate()/1/49</span><br><span class="line">com.google.common.collect.ImmutableList com.google.common.collect.ImmutableList.of()/1/3</span><br><span class="line">&lt;snip&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>First line is the summary inforamtion<blockquote>
<p>count/Null methods count/Boot path methods count</p>
</blockquote>
</li>
<li>Subsequent lines are the profile data<blockquote>
<p>Methods name/Count/Size</p>
</blockquote>
</li>
</ul>
<h1 id="App-Image"><a href="#App-Image" class="headerlink" title="App Image"></a>App Image</h1><ul>
<li>/data/app/xxx/oat/arm/base.art</li>
<li>/data/app/xxx/oat/rm/base.odex</li>
</ul>
<p>base.art 就是对应的App image文件。主要记录已经编译好的类的具体信息以及函数在oat文件的位置，相当于缓存，在app运行的时候会加载到虚拟机，可以加快启动速度。</p>
<p><strong>在Android7.0上，dex2oat的参数 compiler-filter被指定为profile类型的几个compiler-filter之一时，dex2oat还会生成app-image文件。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/27/Android-逐步认识ART系列一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/27/Android-逐步认识ART系列一/" itemprop="url">Android 逐步认识ART系列一</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-27T22:52:11+08:00">
                2018-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/12/27/Android-逐步认识ART系列一/" class="leancloud_visitors" data-flag-title="Android 逐步认识ART系列一">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料：<br>原文：<a href="https://blog.csdn.net/hl09083253cy/article/details/78418809" target="_blank" rel="noopener">https://blog.csdn.net/hl09083253cy/article/details/78418809</a><br>原文：<a href="https://paul.pub/android-art-vm/#id-art-vs-dalvik" target="_blank" rel="noopener">https://paul.pub/android-art-vm/#id-art-vs-dalvik</a><br>Android Source：<a href="https://source.android.com.devices/tech/dalvik/configure" target="_blank" rel="noopener">https://source.android.com.devices/tech/dalvik/configure</a>  </p>
<h1 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h1><p>我们知道，C/C++的效率要比 Java好，因为C/C++会被直接编译成汇编指令，CPU可以直接读取运行；而Java却是需要虚拟机一步一步的解释每一条 java bytecode。</p>
<p>而Dalvik 中使用了一个技术，叫做JIT，会在解释执行一个java方法或者一个java代码段时，进行trace，并在不断的执行过程中找到 hotspot，</p>
<p>然后将相应的方法或者代码片段编译为对应的汇编指令，下次再执行到该方法时，会直接执行其对应的汇编指令，依次来提升部分效率。</p>
<p>可以理解为：运行时追踪，并对hotspot进行编译生成高效的可执行指令。</p>
<p>JIT的运行流程</p>
<ol>
<li>用户运行应用，而这随后就会触发 ART 加载 .dex 文件。<ol>
<li>如果有 .oat 文件（即 .dex 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 .oat 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。</li>
<li>如果没有 .oat 文件，则 ART 会通过 JIT 或解释器执行 .dex 文件。如果有 .oat 文件，ART 将一律使用这类文件。否则，它将在内存中使用并解压 APK 文件，从而得到 .dex 文件，但是这会导致消耗大量内存（相当于 dex 文件的大小）。</li>
</ol>
</li>
<li>针对任何未根据speed编译过滤器编译（见下文）的应用启用JIT（也就是说，要尽可能多地编译应用中的代码）。</li>
<li>将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。</li>
<li>AOT 编译 dex2oat 守护进程通过解析该文件来推进其编译。</li>
</ol>
<p>要开启 JIT 日志记录，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.extra-opts -verbose:jit</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure>
<p>要停用 JIT，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.usejit false</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure>
<h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><p>Ahead-of-time（AOT）是相对于Just-in-time（JIT）而言的。JIT是在运行时进行字节码到本地机器码的编译，这也是为什么Java普遍被认为效率比C++差的原因。无论是解释器的解释还是运行过程中即时编译，都比C++编译出的本地机器码执行多了一个耗费时间的过程。而AOT就是向C++编译过程靠拢的一项技术：当APK在安装的时候，系统会通过一个名称为dex2oat的工具将APK中的dex文件编译成包含本地机器码的oat文件存放下来。这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。</p>
<h1 id="单纯的JIT存在的问题"><a href="#单纯的JIT存在的问题" class="headerlink" title="单纯的JIT存在的问题"></a>单纯的JIT存在的问题</h1><ol>
<li>执行效率差</li>
</ol>
<h1 id="单纯的AOT存在的问题"><a href="#单纯的AOT存在的问题" class="headerlink" title="单纯的AOT存在的问题"></a>单纯的AOT存在的问题</h1><ol>
<li>应用安装时间长</li>
<li>系统更新后，要重新编译所有应用</li>
<li>浪费存储空间（为所有方法执行编译）</li>
</ol>
<h1 id="AOT-JIT"><a href="#AOT-JIT" class="headerlink" title="AOT+JIT"></a>AOT+JIT</h1><p>从Android 7.0（代号Nougat,简称N）开始，ART组合使用了AOT、JIT和配置文件引导型编译。所有这些编译模式的组合均可配置。例如，在Pixel设备上，相应的配置如下：</p>
<ol>
<li>最初在安装应用程序的时候不执行任何AOT编译。应用程序运行的前几次都将使用解释模式，<strong>并且经常执行的方法将被JIT编译</strong>。</li>
<li><strong>当设备处于空闲状态并正在充电时</strong>，编译守护进程会根据第一次运行期间生成的Profile文件对<strong>常用代码</strong>运行AOT编译。</li>
<li>应用程序的<strong>下一次重新启动将使用Profile文件引导的代码</strong>，并<strong>避免在运行时为已编译的方法进行JIT编译</strong>。在<strong>新运行期间得到JIT编译的方法将被添加到Profile文件中</strong>，然后被编译守护进程使用。</li>
</ol>
<p>ART包含一个编译器（dex2oat工具）和一个为启动zygote而加载的运行时（libart.so）。在应用程序安装时，APK文件会传递给dex2oat工具，该工具会为根据APK文件生成一个或多个编译产物，这些产物文件名和扩展名可能会在不同版本之间发生变化，但从Android 8.0版本开始，生成的文件是：</p>
<ul>
<li>.vdex：包含APK的未压缩Dex代码，以及一些额外的元数据用来加速验证。</li>
<li>.odex：包含APK中方法的AOT编译代码。（注意，虽然Dalvik虚拟机时代也会生成odex文件，但和这里的odex文件仅仅是后缀一样，文件内容已经完全不同了）</li>
<li>.art（可选）：包含APK中列出的一些字符串和类的ART内部表示，用于加速应用程序的启动    </li>
</ul>
<h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><p>ART的编译选项分为以下两个类别：</p>
<ol>
<li>系统ROM配置：编译系统映像时，会对哪些代码进行AOT编译。</li>
<li>运行时配置：ART如何在设备上编译和运行应用。</li>
</ol>
<p>用于配置这两个类别的一个核心ART选项就是”编译过滤器“，编译过滤器可控制ART如何编译DEX代码，是一个传递给dex2oat工具的选项。从Android 8.0开始，有四个官方支持的过滤器：</p>
<ol>
<li>verify：只运行DEX代码验证</li>
<li>quicken：运行DEX代码验证，并优化一些DEX指令，以获得更好的解释器性能。</li>
<li>speed：运行DEX代码验证，并对所有方法进行AOT编译。</li>
<li><p>speed-profile：运行DEX代码验证，并对配置文件中列出的方法进行AOT编译</p>
<h2 id="系统ROM配置"><a href="#系统ROM配置" class="headerlink" title="系统ROM配置"></a>系统ROM配置</h2><p>有一些编译选项可用于配置系统ROM，如何配置这些选项取决于/system的可用存储空间以及预先安装的应用数量。编译到系统AROM中的JAR/APK可以分为以下四个类别：</p>
<ol>
<li>启动类路径代码：默认使用speed编译过滤器进行编译 </li>
<li>系统服务代码：默认使用speed编译过滤器进行编译</li>
<li>产品专属的核心应用：默认使用speed编译过滤器进行编译</li>
<li>所有其他应用：默认使用quicken编译过滤器进行编译</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/dex2oat源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/dex2oat源码分析/" itemprop="url">Android-逐步认识ART系列三</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T17:52:49+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/12/26/dex2oat源码分析/" class="leancloud_visitors" data-flag-title="Android-逐步认识ART系列三">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>dex2oat是将dex文件编译成Oat文件的工具，位于/system/bin/dex2oat</p>
<p>dex2oat生成的oat文件位于设备上/data/dalvik-cache/目录下,同时，由于32位和64位的机器码有所区别，因此这个目录下还会通过子文件夹对oat文件进行分类。例如，手机上通常会有下面两个目录：  </p>
<ul>
<li>/data/dalvik-cache/arm/  </li>
<li>/data/dalvik-cache/arm64/</li>
</ul>
<h1 id="dex2oat："><a href="#dex2oat：" class="headerlink" title="dex2oat："></a>dex2oat：</h1><ul>
<li>Retrieve classes.dex from APK (从apk中检索classes.dex)</li>
<li>verify each class（验证每个类）</li>
<li>verify each method（验证每个方法）</li>
<li>verify each dalvik instruction（验证每条dalvik指令）</li>
</ul>
<h1 id="dex2oat编译过程"><a href="#dex2oat编译过程" class="headerlink" title="dex2oat编译过程"></a>dex2oat编译过程</h1><p>依次编译输入参数中的所有dex文件;  每个dex文件又按照单个class进行编译; 对于每个class，依次编译其除abstract函数、\<cinit>之外的所有函数，包括 native（jni）/static/及一般函数，进行生成native code，并存放在compiler中。</cinit></p>
<p>当编译完成后，会从compiler中把native code， dex文件，以及必要的组织信息，写入到OAT文件中；如果指定了生成app-image，还会再生成一份 app-image文件。</p>
<h1 id="dex2oat的触发时机"><a href="#dex2oat的触发时机" class="headerlink" title="dex2oat的触发时机"></a>dex2oat的触发时机</h1><p>dex2oat进程的启动，可以分为两大类：一类是 installd进程触发的dex2oat；另一类是由 app中直接调用的dex2oat。</p>
<h2 id="installd中触发dex2oat有以下几个场景："><a href="#installd中触发dex2oat有以下几个场景：" class="headerlink" title="installd中触发dex2oat有以下几个场景："></a>installd中触发dex2oat有以下几个场景：</h2><pre><code>1. 应用安装，包括普通安装和通过shellCmd安装），安装一个app时，安装过程中需要编译dex文件，会通知installd来触发一个dex2oat进程。
2. 开机扫描，开机过程中，PMS扫描已安装app过程，判断需要优化时，则会对install发出通知。
3. BackgroundDexOptService，（空闲时段或者开机之后触发的Backgroud的 Job），会通知installd进行dex2oat
4. OTADexoptService，好象是OAT过程中的触发的，这个场景没有进行过实际的验证
</code></pre><h2 id="app中调用dex2oat"><a href="#app中调用dex2oat" class="headerlink" title="app中调用dex2oat"></a>app中调用dex2oat</h2><p>一般是App的进程fork出一个子进程，子进程用来执行dex2oat，编译相关的dex，而父进程进行 waitpid 等待，等待完成后再运行其他逻辑。<br>例如：  </p>
<ol>
<li>微信安装后的首次启动，是有dex2oat的调用</li>
<li>淘宝安装后的首次搜索，也有dex2oat的调用</li>
</ol>
<p>这个也是其首次启动或者搜索的一个耗时点。</p>
<p> 由系统触发的dex2oat，都是通过通知installd来进行编译业务。</p>
<p> 由应用触发的dex2oat，一般都是自行构建参数，直接调用dex2oat。</p>
<h1 id="compiler-backend-类型"><a href="#compiler-backend-类型" class="headerlink" title="compiler-backend 类型"></a>compiler-backend 类型</h1><ul>
<li>Portable</li>
<li>Quick</li>
<li><p>Optimizing</p>
<h2 id="Quick-Backend"><a href="#Quick-Backend" class="headerlink" title="Quick Backend"></a>Quick Backend</h2><blockquote>
<p>MIR -&gt; LIR -&gt; Native Code</p>
</blockquote>
<ul>
<li>Medium level IR(DEX ByteCode)</li>
<li>Low level IR</li>
<li>Native Code</li>
<li>some optimizations at each stage</li>
</ul>
<h2 id="Optimizing-Backend"><a href="#Optimizing-Backend" class="headerlink" title="Optimizing Backend"></a>Optimizing Backend</h2><ul>
<li>Basically Quick with additional optimizations</li>
</ul>
<h2 id="Portable-Backend"><a href="#Portable-Backend" class="headerlink" title="Portable Backend"></a>Portable Backend</h2><blockquote>
<p>MIR -&gt; LLVM Bitcode -&gt; LLVM optimizer -&gt; LLVM Backend -&gt; native code</p>
</blockquote>
<ul>
<li>Uses LLVM Bitcode as its LIR</li>
<li>Optimizations using LLVM optimizer</li>
<li>Code generation is done by LLVM backends</li>
</ul>
</li>
</ul>
<h1 id="编译优化条件和对象（没太搞明白的地方）"><a href="#编译优化条件和对象（没太搞明白的地方）" class="headerlink" title="编译优化条件和对象（没太搞明白的地方）"></a>编译优化条件和对象（没太搞明白的地方）</h1><h2 id="什么情况下App需要使用dex2oat进行编译优化"><a href="#什么情况下App需要使用dex2oat进行编译优化" class="headerlink" title="什么情况下App需要使用dex2oat进行编译优化?"></a>什么情况下App需要使用dex2oat进行编译优化?</h2><ul>
<li><p>Number of methods comprising 90% of called methods has changed by &gt; 10%.(被调用方法的比例若大于10%，则会触发dex2oat编译优化)</p>
<h2 id="若要使用dex2oat-哪些方法会被dex2oat考虑进去？"><a href="#若要使用dex2oat-哪些方法会被dex2oat考虑进去？" class="headerlink" title="若要使用dex2oat,哪些方法会被dex2oat考虑进去？"></a>若要使用dex2oat,哪些方法会被dex2oat考虑进去？</h2></li>
<li>Methods comprising 90% of called methods.()</li>
</ul>
<h1 id="dex2oat命令行参数"><a href="#dex2oat命令行参数" class="headerlink" title="dex2oat命令行参数"></a>dex2oat命令行参数</h1><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/dex2oat --zip-fd=6 --zip-location=/system/app/</span><br><span class="line">Email.apk --oat-fd=7 --oat-location=/data/dalvik-cache/</span><br><span class="line">system@app@Email.apk@classes.dex --profile-file=/data/</span><br><span class="line">dalvik-cache/profiles/com.android.email</span><br></pre></td></tr></table></figure></p>
<p>参数说明：<br>–zip-fd=\<file-descriptor>:包含classes.dex文件的zip文件描述符。<br>–oat-fd=\<number>:通过此文件描述符指定输出的oat文件的路径。<br>–oat-location=\<oat-name>:指定一个与–oat-fd指定的文件描述符相对应的象征性名字。<br>–profile-file：引导dex2oat编译优化的配置文件。文件位置：/data/dalvik-cache/profiles/应用包名</oat-name></number></file-descriptor></p>
<p>其他重要参数说明(参考android7.0.0源码)：<br>-j\<number>:指定进行编译优化时要用到的线程总数。默认根据硬件适配，例如：-j12<br>–dex-file=\<dex-file>:指定要编译的文件，后缀可以是.dex、.jar、.apk，例如：–dex-file=/system/framework/core.jar<br>–dex-location=\<dex-location>:dex文件路径,与–dex-file相对应，例如：–dex-file=/home/build//out/system/framework/core.jar;–dex-location=/system/framework/core.jar。<br>–zip-location=\<zip-location>:zip文件路径。例如：–zip-location=/system/app/Calculator.apk<br>–oat-file=\&lt;file.oat&gt;:输出的oat文件名。例如：–oat-file=/system/framework/boot.oat。<br>–oat-symbols=\&lt;file.oat&gt;:指定输出完整符号的oat路径。例如：–oat-symbols=/symbols/system/framework/boo.art。<br>–instruction-set=(arm|arm64|mips|mips64|x86|x86_64):指定指令集架构类型，默认为arm。<br>–compile-backend=(Quick|Optimizing):指定编译器后端。默认为Optimizing。<br>–compiler-filter=(verify-none|verify-at-runtime|verify-profile|interpret-only|time|space-profile|space|balanced|speed-profile|speed|everything-profile|everything):指定编译器过滤模式，默认为speed。</zip-location></dex-location></dex-file></number></p>
<h1 id="dex2oat主要流程"><a href="#dex2oat主要流程" class="headerlink" title="dex2oat主要流程"></a>dex2oat主要流程</h1><p>main函数入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int result = art::dex2oat(argc, argv);</span><br><span class="line">  // Everything was done, do an explicit exit here to avoid running Runtime destructors that take</span><br><span class="line">  // time (bug 10645725) unless we&apos;re a debug build or running on valgrind. Note: The Dex2Oat class</span><br><span class="line">  // should not destruct the runtime in this case.</span><br><span class="line">  if (!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL == 0)) &#123;</span><br><span class="line">    exit(result);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dex2oat函数入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static int dex2oat(int argc, char** argv) &#123;</span><br><span class="line">  b13564922();</span><br><span class="line">    </span><br><span class="line">  TimingLogger timings(&quot;compiler&quot;, false, false);</span><br><span class="line"></span><br><span class="line">  // Allocate `dex2oat` on the heap instead of on the stack, as Clang</span><br><span class="line">  // might produce a stack frame too large for this function or for</span><br><span class="line">  // functions inlining it (such as main), that would not fit the</span><br><span class="line">  // requirements of the `-Wframe-larger-than` option.</span><br><span class="line">  std::unique_ptr&lt;Dex2Oat&gt; dex2oat = MakeUnique&lt;Dex2Oat&gt;(&amp;timings);</span><br><span class="line"></span><br><span class="line">  // Parse arguments. Argument mistakes will lead to exit(EXIT_FAILURE) in UsageError.</span><br><span class="line">  dex2oat-&gt;ParseArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">  // If needed, process profile information for profile guided compilation.</span><br><span class="line">  // This operation involves I/O.</span><br><span class="line">  if (dex2oat-&gt;UseProfileGuidedCompilation()) &#123;</span><br><span class="line">    if (!dex2oat-&gt;LoadProfile()) &#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; &quot;Failed to process profile file&quot;;</span><br><span class="line">      return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Check early that the result of compilation can be written</span><br><span class="line">  if (!dex2oat-&gt;OpenFile()) &#123;</span><br><span class="line">    return EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Print the complete line when any of the following is true:</span><br><span class="line">  //   1) Debug build</span><br><span class="line">  //   2) Compiling an image</span><br><span class="line">  //   3) Compiling with --host</span><br><span class="line">  //   4) Compiling on the host (not a target build)</span><br><span class="line">  // Otherwise, print a stripped command line.</span><br><span class="line">  if (kIsDebugBuild || dex2oat-&gt;IsBootImage() || dex2oat-&gt;IsHost() || !kIsTargetBuild) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; CommandLine();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; StrippedCommandLine();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!dex2oat-&gt;Setup()) &#123;</span><br><span class="line">    dex2oat-&gt;EraseOatFiles();</span><br><span class="line">    return EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool result;</span><br><span class="line">  if (dex2oat-&gt;IsImage()) &#123;//App Image 或者Boot Image</span><br><span class="line">    result = CompileImage(*dex2oat);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = CompileApp(*dex2oat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dex2oat-&gt;Shutdown();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当使用profile-guide 编译app时，会先 LoadProfile(),进行解析出 class index 和 method index，放到 ProfileCompilationinfo 中;<br>如果当前的编译要生成 image时，走CompileImage流程，否则走CompileApp流程;</p>
</blockquote>
<p>不论是编译image还是App都会包含以下一个工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dex2oat.Compile();//核心</span><br><span class="line"></span><br><span class="line">dex2oat.WriteOatFiles();//嵌入ELF</span><br><span class="line"></span><br><span class="line">dex2oat.FlushCloseOatFiles();</span><br><span class="line"></span><br><span class="line"> dex2oat.DumpTiming()</span><br></pre></td></tr></table></figure></p>
<p>CompileApp和CompileImage的区别是：</p>
<ol>
<li>编译image时需要 LoadClassProfileDescriptors() 产生 image_classes_ 集合，和生成 image（HandleImage()）;</li>
<li>在生成的app image中将会包含 image_classes_ 集合中类的对象，不在 image_classes_集合中的app的类的对象，将不会被生成到 app-image中。</li>
<li>LoadClassProfileDescriptors（）在从 profile信息中获取 image_classes_集合时，将会把 app dex 中的类以外的类，都过滤掉，比如 classpath dex 对应的类将不会生成到 app-image;</li>
</ol>
<p>dex2oat工作流程总结：</p>
<ol>
<li>根据dex2oat接收到的参数，组织编译参数</li>
<li>如果是 profile-guide 编译，则先进行 load app对应的 profile</li>
<li>收集参数中包含的所有dex file，启动 Compiler 编译这些dex file（classpath中对应的dex file，即uses-library 引用的jar文件，不会被编译），编译生成的数据放在compiler-driver中</li>
<li>使用 compiler-driver 中的数据，依据 oat文件设计的格式，组织成oat文件，嵌入到 ELF文件中</li>
<li>如果指定需要生成 app-image，则使用 HandleImage()， 生成app-image， 即 ***.art 文件</li>
</ol>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/Android-部分系统版本变更行为/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Android-部分系统版本变更行为/" itemprop="url">Android 部分系统版本变更行为</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T17:34:14+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/12/26/Android-部分系统版本变更行为/" class="leancloud_visitors" data-flag-title="Android 部分系统版本变更行为">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>主要关注安全方面</strong></p>
<h1 id="Android-6-0部分变更行为："><a href="#Android-6-0部分变更行为：" class="headerlink" title="Android 6.0部分变更行为："></a>Android 6.0部分变更行为：</h1><ul>
<li>运行时权限</li>
</ul>
<p>此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。</p>
<ul>
<li>低电耗模式和应用待机模式</li>
</ul>
<p>此版本引入了针对空闲设备和应用的最新节能优化技术。</p>
<ul>
<li>低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。</li>
<li>应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。</li>
</ul>
<ul>
<li>取消支持 Apache HTTP 客户端</li>
</ul>
<p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 HttpURLConnection 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 build.gradle 文件中声明以下编译时依赖项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary &apos;org.apache.http.legacy&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Boring SSL</li>
</ul>
<p>Android 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。</p>
<ul>
<li>运行时</li>
</ul>
<p>ART 运行时环境现在可正确实现 newInstance() 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 setAccessible() 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。</p>
<p>此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。</p>
<p>现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。</p>
<p>在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。</p>
<ul>
<li>APK验证</li>
</ul>
<p>该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。</p>
<h1 id="Android-7-0部分变更行为："><a href="#Android-7-0部分变更行为：" class="headerlink" title="Android 7.0部分变更行为："></a>Android 7.0部分变更行为：</h1><ul>
<li>配置文件指导的 JIT/AOT 编译</li>
</ul>
<p>在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。</p>
<p>配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。</p>
<p>除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。</p>
<p>Android 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。</p>
<ul>
<li>快速的应用安装路径</li>
</ul>
<p>Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤</p>
<p><strong>关于JIT的回归</strong></p>
<p>在Android 5.0上，系统在安装APK时会直接将dex文件中的代码编译成机器码。编译一个应用就已经很耗时，若编译所有应用，等待时间将会使人难以忍受。</p>
<p>例如：<br>应用程序编译生成的OAT文件会引用Framework中的代码。一旦系统发生升级，Framework中的实现发生变化，就需要重新修正所有应用程序的OAT文件，使得它们的引用是正确的，这就需要重新编译所有的应用。</p>
<p>由此可以看到单纯的AOT编译会存在以下问题：</p>
<ul>
<li>应用安装时间过长。</li>
<li>系统每次更新都要重新编译所有应用。</li>
<li>编译生成的Oat文件中，既包含了原先的Dex文件，又包含了编译后的机器代码。而实际上，对于用户来说，并非会用到应用程序中的所有功能，因此很多时候编译生成的机器码是一直用不到的。一份数据存在两份结果（尽管它们的格式是不一样的）显然是一种存储空间的浪费。</li>
</ul>
<p>因此，为了解决上述问题，Android 7.0(代号Nougat,简称N)中添加了JIT编译器和配置文件引导型编译。JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。</p>
<p>JIT编译器补充了ART当前的预先AOT编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT编译器，JIT编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 OTA 更新期间）时拖慢系统速度。</p>
<p>尽管JIT和AOT使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 OnStackReplacement 编译成为可能，而这一切都会使其生成的代码略有不同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/Android系统版本分布/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heinz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heinz Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Android系统版本分布/" itemprop="url">Android系统版本分布</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T15:56:56+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/12/26/Android系统版本分布/" class="leancloud_visitors" data-flag-title="Android系统版本分布">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android 信息中心：<a href="https://developer.android.com/about/dashboards/?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/about/dashboards/?hl=zh-cn</a></p>
<p>Android各个系统版本市场占有率表：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9c984ab2b3606d4f688dee72ff7fb30f?method=download&amp;shareKey=288a168344f4c3da4e4930c699d19ee2" alt="image"><br>Android各个系统版本市场占有率图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB75a72b0c1a2257ce5215bc18bb38a8d4?method=download&amp;shareKey=cc627bcace397474e82ad2ad8355057c" alt="image"></p>
<p>总结，由上表和上图可知：</p>
<ul>
<li>Android6.0、Android7.0,7.1、Android8.0,8.1占据了3/4的Android市场。</li>
<li>单个系统版本市场占有率最高的为Android 6.0，即API 23 </li>
<li>复合系统版本市场占有率最高的为Android 7.0系列，其中7.0为18.1%，7.1为10.1%</li>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Heinz">
            
              <p class="site-author-name" itemprop="name">Heinz</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/itmayi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:799902881@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heinz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jypPJXy89LBDsg88boqicDg9-gzGzoHsz", "7z1xPLru7WIRw9p0A6SE779N");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
